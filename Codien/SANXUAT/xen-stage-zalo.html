<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C√¥ng ƒëo·∫°n X√©n - Carton Manager</title>
  <!-- Bootstrap Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <!-- Universal Stage CSS -->
  <link rel="stylesheet" href="universal-stage.css">
  <!-- Sidebar Generator -->
  <script src="sidebar-generator.js"></script>
  <!-- Custom Logout Handler -->
  <script>
    // ƒê·ªãnh nghƒ©a handleLogout tr∆∞·ªõc khi auth.js load
    window.handleLogout = function() {
      // X√≥a session
      localStorage.removeItem('user_session');
      
      // ·∫®n th√¥ng tin user
      updateUserInfo();
      
      // Hi·ªÉn th·ªã login popup
      showLoginPopup({
        onLoginSuccess: function(userData) {
          updateUserInfo();
          refreshData();
        }
      });
    };
  </script>
  
  <!-- Auth Manager -->
  <script src="../js/auth.js"></script>
  <!-- Login Popup Component -->
  <script src="../js/login-popup.js"></script>

  <!-- Custom CSS for Shifts Tab -->
  <style>
    /* Shifts Tab Styles */
    .shifts-container {
      padding: 0;
    }
    
    .shifts-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #e9ecef;
    }
    
    .shifts-header h6 {
      margin: 0;
      color: #495057;
      font-weight: 600;
    }
    
    .shifts-loading {
      display: flex;
      align-items: center;
      color: #6c757d;
      font-size: 0.875rem;
    }
    
    .shifts-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .shifts-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: #f8fafc;
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid #e2e8f0;
    }

    .stat-number {
      font-size: 24px;
      font-weight: 700;
      color: #2563eb;
      margin-bottom: 4px;
    }

    .stat-label {
      font-size: 12px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .shift-item {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .shift-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      border-color: #2563eb;
    }

    .shift-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: #2563eb;
    }
    
    .shift-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    
    .shift-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: #1f2937;
    }

    .shift-title i {
      color: #2563eb;
      font-size: 16px;
    }
    
    .shift-status {
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .shift-status.completed {
      background: #dcfce7;
      color: #16a34a;
    }
    
    .shift-status.in_progress {
      background: #fef3c7;
      color: #ca8a04;
    }
    
    .shift-status.waiting {
      background: #e0e7ff;
      color: #2563eb;
    }
    
    .shift-status.paused {
      background: #fecaca;
      color: #dc2626;
    }
    
    .shift-status.handed_over {
      background: #cffafe;
      color: #0891b2;
    }
    
    .shift-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .shift-detail {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .shift-detail-label {
      font-size: 12px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }
    
    .shift-detail-value {
      font-size: 14px;
      font-weight: 600;
      color: #1f2937;
    }
    
    .shift-times {
      display: flex;
      gap: 24px;
      padding-top: 16px;
      border-top: 1px solid #e2e8f0;
      font-size: 13px;
      color: #6b7280;
    }

    .shift-times span {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .shift-times i {
      font-size: 14px;
    }

    .shift-progress {
      margin-top: 12px;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
    }

    .progress-bar {
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #16a34a, #2563eb);
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 12px;
      color: #6b7280;
      text-align: center;
    }

    .shift-actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e2e8f0;
    }

    .btn-action {
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .btn-view {
      background: #2563eb;
      color: white;
    }

    .btn-view:hover {
      background: #1d4ed8;
      color: white;
    }

    .btn-edit {
      background: #ca8a04;
      color: white;
    }

    .btn-edit:hover {
      background: #a16207;
      color: white;
    }

    .empty-state {
      text-align: center;
      padding: 48px 24px;
      color: #6b7280;
    }

    .empty-state i {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .empty-state h5 {
      margin-bottom: 8px;
      color: #1f2937;
    }

    .empty-state p {
      margin: 0;
      font-size: 14px;
    }

    @media (max-width: 768px) {
      .shifts-stats {
        grid-template-columns: 1fr;
      }
      
      .shift-details {
        grid-template-columns: 1fr;
      }
      
      .shift-times {
        flex-direction: column;
        gap: 8px;
      }
    }
    
    .shift-summary {
      background: #e9ecef;
      border-radius: 6px;
      padding: 1rem;
      margin-top: 1rem;
    }
    
    .shift-summary h6 {
      margin-bottom: 0.75rem;
      color: #495057;
      font-weight: 600;
    }
    
    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.75rem;
    }
    
    .summary-stat {
      text-align: center;
      padding: 0.5rem;
      background: white;
      border-radius: 4px;
    }
    
    .summary-stat-value {
      font-size: 1.25rem;
      font-weight: 600;
      color: #495057;
    }
    
    .summary-stat-label {
      font-size: 0.75rem;
      color: #6c757d;
      margin-top: 0.25rem;
    }
    
    .no-shifts {
      text-align: center;
      padding: 2rem;
      color: #6c757d;
    }
    
    .no-shifts i {
      font-size: 2rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }
    
    .shifts-container {
      min-height: 200px;
      border: 1px solid #ddd;
      padding: 15px;
      background: #fff;
    }
    
    /* Button styles for shift handover */
    .btn-info-custom {
      background: linear-gradient(135deg, #17a2b8, #138496);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 120px;
      justify-content: center;
    }
    
    .btn-info-custom:hover {
      background: linear-gradient(135deg, #138496, #117a8b);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(23, 162, 184, 0.3);
    }
    
    .btn-info-custom:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(23, 162, 184, 0.3);
    }
  </style>

</head>
<body data-stage="xen">
  <!-- Sidebar will be generated by JavaScript -->

  <!-- Main Content -->
  <div class="main-content sidebar-collapsed" id="mainContent">
    <div class="content-area">
    <div class="container-fluid p-4">
      
      <!-- Stage Header -->
      <div class="stage-header">
        <div class="d-flex justify-content-between align-items-center">
          <div>
            <h1>
              <i class="bi bi-bullseye me-2"></i>
              C√¥ng ƒëo·∫°n X√©n
            </h1>

            <p class="mb-0">X√©n gi·∫•y - Qu·∫£n l√Ω chi ti·∫øt s·∫£n xu·∫•t</p>
          </div>
          
          <div class="user-controls">
            <div class="user-info d-flex align-items-center me-3">
              <i class="fas fa-user-circle me-2"></i>
              <span id="userName" class="fw-bold me-2">Loading...</span>
              <!-- <span class="badge bg-primary" id="userRole">...</span> -->
            </div>
            <button class="btn btn-outline-primary btn-sm" onclick="handleLogout()">
              <i class="fas fa-sign-out-alt me-1"></i>ƒêƒÉng xu·∫•t
            </button>
          </div>
        </div>
      </div>
      
      <!-- Statistics -->
      <div class="row mb-4" id="stageStats">
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalOrders">0</div>
            <div class="stat-label">T·ªïng l·ªánh</div>
          </div>
        </div>
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalPlan">0</div>
            <div class="stat-label">SL K·∫ø ho·∫°ch</div>
          </div>
        </div>
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalGood">0</div>
            <div class="stat-label">SL ƒê·∫°t</div>
          </div>
        </div>
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalNg">0</div>
            <div class="stat-label">SL NG</div>
          </div>
        </div>
      </div>
      
      <!-- Main Card -->
      <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
                          <h5 class="mb-0">Danh s√°ch l·ªánh s·∫£n xu·∫•t </h5>
          <div class="d-flex align-items-center">

            <!-- Main Actions -->
            <button class="btn btn-primary me-2" onclick="refreshData()">
              <i class="bi bi-arrow-clockwise me-1"></i>L√†m m·ªõi
            </button>
            <button class="btn btn-outline-primary me-2" onclick="loadDataWithDateFilter()">
              <i class="bi bi-calendar-range me-1"></i>T·∫£i theo ng√†y
            </button>
          </div>
        </div>
        
        <div class="card-body">
          <!-- Filters -->
          <div class="card mb-3">
            <div class="card-header bg-light">
              <div class="d-flex justify-content-between align-items-center">
                <h6 class="mb-0">
                  <i class="bi bi-funnel me-2"></i>B·ªô l·ªçc d·ªØ li·ªáu
                </h6>
                <button class="btn btn-outline-secondary btn-sm" onclick="clearFilters()" title="X√≥a t·∫•t c·∫£ b·ªô l·ªçc">
                  <i class="bi bi-x-circle me-1"></i>X√≥a b·ªô l·ªçc
                </button>
              </div>
            </div>
            <div class="card-body">
              <div class="row g-3">
                <div class="col-md-3">
                  <label class="form-label fw-bold">
                    <i class="bi bi-calendar me-1"></i>T·ª´ ng√†y:
                  </label>
                  <input type="date" class="form-control" id="fromDateFilter" placeholder="Ch·ªçn ng√†y b·∫Øt ƒë·∫ßu">
                </div>
                <div class="col-md-3">
                  <label class="form-label fw-bold">
                    <i class="bi bi-calendar me-1"></i>ƒê·∫øn ng√†y:
                  </label>
                  <input type="date" class="form-control" id="toDateFilter" placeholder="Ch·ªçn ng√†y k·∫øt th√∫c">
                </div>
                <!-- <div class="col-md-2">
                  <label class="form-label fw-bold">
                    <i class="bi bi-clock me-1"></i>Ca:
                  </label>
                  <select class="form-select" id="shiftFilter">
                    <option value="">T·∫•t c·∫£</option>
                    <option value="Ca 1">Ca 1</option>
                    <option value="Ca 2">Ca 2</option>
                    <option value="Ca 3">Ca 3</option>
                    <option value="K√≠p 1">K√≠p 1</option>
                    <option value="K√≠p 2">K√≠p 2</option>
                  </select>
                </div> -->
                <!-- <div class="col-md-2">
                  <label class="form-label fw-bold">
                    <i class="bi bi-gear me-1"></i>M√°y:
                  </label>
                  <select class="form-select" id="machineFilter">
                    <option value="">T·∫•t c·∫£</option>
                    <option value="X·∫£ 1">X·∫£ 1</option>
                    <option value="X·∫£ 2">X·∫£ 2</option>
                    <option value="X·∫£ 3">X·∫£ 3</option>
                  </select>
                </div> -->
                <div class="col-md-5">
                  <label class="form-label fw-bold">
                    <i class="bi bi-search me-1"></i>T√¨m ki·∫øm:
                  </label>
                  <div class="input-group">
                    <input type="text" class="form-control" id="searchInput" placeholder="T√¨m theo m√£ l·ªánh, s·∫£n ph·∫©m, m√°y, th·ª£...">
                    <button class="btn btn-primary" type="button" onclick="applyFilters()">
                      <i class="bi bi-search"></i>
                    </button>
                  </div>
                  <!-- <small class="text-muted">T·ª± ƒë·ªông t√¨m ki·∫øm khi nh·∫≠p (300ms delay)</small> -->
                </div>
              </div>
            </div>
          </div>
          
          <!-- Tabs Navigation -->
          <ul class="nav nav-tabs mb-3" id="machineTabs" role="tablist">
            <!-- Dynamic tabs will be generated here -->
          </ul>
          
          <!-- Tab Content -->
          <div class="tab-content" id="machineTabContent">
            <!-- Dynamic tab content will be generated here -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // === C·∫§U H√åNH C√îNG ƒêO·∫†N HI·ªÜN T·∫†I ===
    const $stage_now = 'xen'; // Thay ƒë·ªïi gi√° tr·ªã n√†y ƒë·ªÉ chuy·ªÉn sang c√¥ng ƒëo·∫°n kh√°c: xa, xen, in_offset, boi, be, dan, kho
    
    // === C·∫§U H√åNH STAGE T·ª∞ ƒê·ªòNG ===
    const STAGE_CONFIGS = {
        xa: { KEY: 'xa', NAME: 'X·∫¢', DISPLAY: 'X·∫¢ GI·∫§Y CU·ªòN' },
        xen: { KEY: 'xen', NAME: 'X√âN', DISPLAY: 'X√âN GI·∫§Y' },
        in_offset: { KEY: 'in_offset', NAME: 'IN OFFSET', DISPLAY: 'IN OFFSET' },
        boi: { KEY: 'boi', NAME: 'B·ªíI', DISPLAY: 'B·ªíI GI·∫§Y' },
        be: { KEY: 'be', NAME: 'B·∫æ', DISPLAY: 'B·∫æ GI·∫§Y' },
        dan: { KEY: 'dan', NAME: 'D√ÅN', DISPLAY: 'D√ÅN GI·∫§Y' },
        kho: { KEY: 'kho', NAME: 'KHO', DISPLAY: 'KHO TH√ÄNH PH·∫®M' }
    };
    
    const STAGE_CONFIG = STAGE_CONFIGS[$stage_now];
    
    // === HELPER FUNCTIONS FOR DYNAMIC FIELD NAMES ===
    function getFieldName(field) {
        return `${STAGE_CONFIG.KEY}_${field}`;
    }
    
    function getOrderField(order, field) {
        const fieldName = getFieldName(field);
        return order[fieldName] || order[field] || 0;
    }
    
    function setOrderField(order, field, value) {
        const fieldName = getFieldName(field);
        order[fieldName] = value;
    }
    
    /**
     * =================================================================
     * ${STAGE_CONFIG.NAME} STAGE MANAGEMENT - QU·∫¢N L√ù C√îNG ƒêO·∫†N ${STAGE_CONFIG.NAME}
     * =================================================================
     * Ch·ª©c nƒÉng ch√≠nh:
     * 1. Hi·ªÉn th·ªã danh s√°ch l·ªánh s·∫£n xu·∫•t ·ªü c√¥ng ƒëo·∫°n ${STAGE_CONFIG.NAME}
     * 2. Ho√†n th√†nh c√¥ng ƒëo·∫°n ${STAGE_CONFIG.NAME} (c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng OK, NG)
     * 3. B√†n giao sang c√¥ng ƒëo·∫°n ti·∫øp theo theo workflow_definition
     */

    // === C·∫§U H√åNH API & WEBHOOK ===
    const API_BASE_URL = 'https://api.autoslp.com/api';
    const WEBHOOK_BASE_URL = 'https://api.autoslp.com:5678/webhook';

    // === BI·∫æN GLOBAL ===
    let ordersData = [];        // D·ªØ li·ªáu l·ªánh s·∫£n xu·∫•t
    let currentEditingOrder = null;  // ƒê∆°n h√†ng ƒëang ch·ªânh s·ª≠a
    let machineStatusData = []; // D·ªØ li·ªáu tr·∫°ng th√°i m√°y

    /**
     * =================================================================
     * MACHINE STATUS FUNCTIONS - H√ÄM QU·∫¢N L√ù TR·∫†NG TH√ÅI M√ÅY
     * =================================================================
     */

    /**
     * T·∫£i d·ªØ li·ªáu tr·∫°ng th√°i m√°y t·ª´ API
     */
    async function loadMachineStatus() {
        try {
            console.log('üîç Loading machine status from API...');
            const response = await fetch(`${API_BASE_URL}/data/production_machines`);
            if (response.ok) {
                machineStatusData = await response.json();
                console.log('‚úÖ Machine status loaded:', machineStatusData);
            } else {
                console.error('‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu m√°y:', response.status);
                machineStatusData = [];
            }
        } catch (error) {
            console.error('‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu m√°y:', error);
            machineStatusData = [];
        }
    }

    /**
     * Ki·ªÉm tra xem m√°y c√≥ ƒëang s·∫£n xu·∫•t l·ªánh n√†o kh√¥ng
     * @param {string} machineName - T√™n m√°y
     * @returns {object|null} - Th√¥ng tin l·ªánh ƒëang s·∫£n xu·∫•t ho·∫∑c null
     */
    function getMachineCurrentOrder(machineName) {
        if (!machineStatusData || machineStatusData.length === 0) {
            return null;
        }
        
        const machine = machineStatusData.find(m => m.machine_name === machineName);
        return machine && machine.current_order_id ? machine : null;
    }

    /**
     * Ki·ªÉm tra xem m√°y c·ª• th·ªÉ c√≥ ƒëang ch·∫°y l·ªánh kh√¥ng
     * @param {string} machineName - T√™n m√°y c·∫ßn ki·ªÉm tra
     * @returns {object} - { isRunning: boolean, runningOrder: object|null }
     */
    function checkMachineStatus(machineName) {
        const machine = machineStatusData.find(m => m.machine_name === machineName);
        
        if (!machine) {
            return { isRunning: false, runningOrder: null };
        }
        
        const isRunning = !!(machine.current_order_id && machine.current_order_id !== null);
        
        return {
            isRunning: isRunning,
            runningOrder: isRunning ? machine : null
        };
    }

    /**
     * Ki·ªÉm tra xem l·ªánh c√≥ thu·ªôc m√°y n√†o kh√¥ng
     * @param {object} order - L·ªánh s·∫£n xu·∫•t
     * @returns {string|null} - T√™n m√°y ho·∫∑c null
     */
    function getOrderMachine(order) {
        const assignedMachine = order.assigned_machine || '';
        
        // L·ªçc c√°c m√°y thu·ªôc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // T√¨m m√°y ${STAGE_CONFIG.NAME} trong danh s√°ch m√°y ƒë∆∞·ª£c g√°n
        for (const MStageMachine of MStageMachines) {
            if (assignedMachine.includes(MStageMachine.machine_name)) {
                return MStageMachine.machine_name;
            }
        }
        
        return null;
    }



    /**
     * Ki·ªÉm tra xem l·ªánh c√≥ ƒëang ch·∫°y kh√¥ng
     * @param {object} order - L·ªánh s·∫£n xu·∫•t
     * @returns {object} - { isRunning: boolean, reason: string }
     */
    function isOrderRunning(order) {
        // Ki·ªÉm tra xem c√≥ m√°y n√†o ƒëang s·∫£n xu·∫•t l·ªánh n√†y kh√¥ng
        const machineWithThisOrder = machineStatusData.find(machine => 
            machine.current_order_id == order.id
        );

        // N·∫øu l·ªánh n√†y ƒëang ƒë∆∞·ª£c s·∫£n xu·∫•t b·ªüi m·ªôt m√°y n√†o ƒë√≥
        if (machineWithThisOrder) {
            return { isRunning: true, reason: `L·ªánh hi·ªán t·∫°i c·ªßa m√°y ${machineWithThisOrder.machine_name}` };
        }

        // N·∫øu kh√¥ng c√≥ m√°y n√†o ƒëang s·∫£n xu·∫•t l·ªánh n√†y
        return { isRunning: false, reason: 'L·ªánh kh√¥ng ƒëang ƒë∆∞·ª£c s·∫£n xu·∫•t' };
    }

    /**
     * =================================================================
     * ENHANCED API FUNCTIONS - API C·∫¢I TI·∫æN
     * =================================================================
     */

    /**
     * Fetch v·ªõi timeout v√† retry
     */
    async function fetchWithTimeout(url, options = {}, timeout = 10000) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);

        try {
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            return response;
        } catch (error) {
            clearTimeout(timeoutId);
            throw error;
        }
    }

    /**
     * Fetch v·ªõi retry logic
     */
    async function fetchWithRetry(url, options = {}, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const timeout = attempt === 1 ? 10000 : 3000;
                const response = await fetchWithTimeout(url, options, timeout);
                
                if (response.ok) {
                    return response;
                }
                
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
            } catch (error) {
                lastError = error;
                
                if (attempt < maxRetries) {
                    const delay = Math.min(1000 * attempt, 2000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        throw lastError;
    }


    /**
     * Cache key cho filter ng√†y
     */
    const DATE_FILTER_CACHE_KEY = `date_filter_${STAGE_CONFIG.KEY}`;
    
    /**
     * L∆∞u gi√° tr·ªã filter ng√†y v√†o cache
     */
    function saveDateFilterToCache() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (fromDateInput && toDateInput) {
            const cacheData = {
                fromDate: fromDateInput.value,
                toDate: toDateInput.value,
                timestamp: Date.now()
            };
            localStorage.setItem(DATE_FILTER_CACHE_KEY, JSON.stringify(cacheData));
        }
    }
    
    /**
     * Kh√¥i ph·ª•c gi√° tr·ªã filter ng√†y t·ª´ cache
     */
    function loadDateFilterFromCache() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (!fromDateInput || !toDateInput) return false;
        
        try {
            const cachedData = localStorage.getItem(DATE_FILTER_CACHE_KEY);
            if (cachedData) {
                const data = JSON.parse(cachedData);
                
                // Ki·ªÉm tra cache c√≥ h·ª£p l·ªá kh√¥ng (kh√¥ng qu√° 7 ng√†y)
                const cacheAge = Date.now() - data.timestamp;
                const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 ng√†y
                
                if (cacheAge < maxAge && data.fromDate && data.toDate) {
                    fromDateInput.value = data.fromDate;
                    toDateInput.value = data.toDate;
                    return true;
                }
            }
        } catch (error) {
            console.error('L·ªói khi load cache filter ng√†y:', error);
        }
        
        return false;
    }
    
    /**
     * Set gi√° tr·ªã m·∫∑c ƒë·ªãnh cho filter ng√†y
     */
    function setDefaultDateFilter() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (fromDateInput && toDateInput) {
            // Th·ª≠ load t·ª´ cache tr∆∞·ªõc
            const cacheLoaded = loadDateFilterFromCache();
            
            // N·∫øu kh√¥ng c√≥ cache, set gi√° tr·ªã m·∫∑c ƒë·ªãnh
            if (!cacheLoaded) {
                const today = new Date();
                const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
                
                fromDateInput.value = oneWeekAgo.toISOString().split('T')[0];
                toDateInput.value = today.toISOString().split('T')[0];
            }
        }
    }
    
    /**
     * Reset filter ng√†y v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh v√† x√≥a cache
     */
    function resetDateFilter() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (fromDateInput && toDateInput) {
            // X√≥a cache
            localStorage.removeItem(DATE_FILTER_CACHE_KEY);
            
            // Set gi√° tr·ªã m·∫∑c ƒë·ªãnh
            const today = new Date();
            const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
            
            fromDateInput.value = oneWeekAgo.toISOString().split('T')[0];
            toDateInput.value = today.toISOString().split('T')[0];
            
            // Reload d·ªØ li·ªáu
            refreshData();
            
            showNotification('ƒê√£ reset filter ng√†y v·ªÅ m·∫∑c ƒë·ªãnh', 'info');
        }
    }

    /**
     * T·∫£i d·ªØ li·ªáu v·ªõi filter ng√†y c·ª• th·ªÉ
     */
    async function loadDataWithDateFilter() {
        const fromDateFilter = document.getElementById('fromDateFilter')?.value;
        const toDateFilter = document.getElementById('toDateFilter')?.value;
        
        if (!fromDateFilter || !toDateFilter) {
            showNotification('Vui l√≤ng ch·ªçn c·∫£ ng√†y b·∫Øt ƒë·∫ßu v√† ng√†y k·∫øt th√∫c', 'warning');
            return;
        }
        
        if (fromDateFilter > toDateFilter) {
            showNotification('Ng√†y b·∫Øt ƒë·∫ßu kh√¥ng th·ªÉ l·ªõn h∆°n ng√†y k·∫øt th√∫c', 'warning');
            return;
        }
        
        showLoading('ƒêang t·∫£i d·ªØ li·ªáu theo kho·∫£ng ng√†y...');
        await loadOrdersData();
        hideLoading();
        showNotification(`ƒê√£ t·∫£i d·ªØ li·ªáu t·ª´ ${fromDateFilter} ƒë·∫øn ${toDateFilter}`, 'success');
    }

    /**
     * T·∫£i d·ªØ li·ªáu l·ªánh s·∫£n xu·∫•t t·ª´ API
     */
    async function loadOrdersData() {
        const timingKey = 'loadOrdersData';
        try {
            // Load d·ªØ li·ªáu m√°y tr∆∞·ªõc
            await loadMachineStatus();
            // Load d·ªØ li·ªáu theo ng√†y t·ª´ filter ho·∫∑c m·∫∑c ƒë·ªãnh 30 ng√†y tr∆∞·ªõc
            const fromDateFilter = document.getElementById('fromDateFilter')?.value;
            const toDateFilter = document.getElementById('toDateFilter')?.value;
            
            // Th√™m event listener cho filter ng√†y
            const fromDateInput = document.getElementById('fromDateFilter');
            const toDateInput = document.getElementById('toDateFilter');
            if (fromDateInput && toDateInput) {
                // Set gi√° tr·ªã m·∫∑c ƒë·ªãnh: t·ª´ 1 tu·∫ßn tr∆∞·ªõc ƒë·∫øn h√¥m nay
                if (!fromDateInput.value && !toDateInput.value) {
                    const today = new Date();
                    const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
                    fromDateInput.value = oneWeekAgo.toISOString().split('T')[0];
                    toDateInput.value = today.toISOString().split('T')[0];
                }
                
                fromDateInput.addEventListener('change', () => {
                    // L∆∞u cache khi thay ƒë·ªïi ng√†y
                    saveDateFilterToCache();
                    
                    if (fromDateInput.value && toDateInput.value) {
                        refreshData(); // Reload d·ªØ li·ªáu khi c√≥ ƒë·ªß c·∫£ 2 ng√†y
                    }
                });
                toDateInput.addEventListener('change', () => {
                    // L∆∞u cache khi thay ƒë·ªïi ng√†y
                    saveDateFilterToCache();
                    
                    if (fromDateInput.value && toDateInput.value) {
                        refreshData(); // Reload d·ªØ li·ªáu khi c√≥ ƒë·ªß c·∫£ 2 ng√†y
                    }
                });
            }
            
            let fromDate, toDate;
            if (fromDateFilter && toDateFilter) {
                // S·ª≠ d·ª•ng ng√†y t·ª´ filter
                fromDate = fromDateFilter;
                toDate = toDateFilter;
            } else {
                // M·∫∑c ƒë·ªãnh 1 tu·∫ßn tr∆∞·ªõc ƒë·∫øn hi·ªán t·∫°i
                const today = new Date();
                const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
                fromDate = oneWeekAgo.toISOString().split('T')[0];
                toDate = today.toISOString().split('T')[0];
            }
            
            // S·ª≠ d·ª•ng date range thay v√¨ limit ƒë·ªÉ tr√°nh qu√° t·∫£i
            const url = `${API_BASE_URL}/data/production_orders?stage=${STAGE_CONFIG.KEY}&from_date=${fromDate}&to_date=${toDate}`;
            
            // G·ªçi API ƒë·ªÉ l·∫•y t·∫•t c·∫£ d·ªØ li·ªáu
            const response = await fetchWithRetry(url, {}, 3);
            const apiData = await response.json();
            
            // Ki·ªÉm tra d·ªØ li·ªáu raw t·ª´ API
            if (apiData.length > 0) {
                // Log c√°c m·∫´u ƒë·ªÉ ki·ªÉm tra start_time
                apiData.slice(0, 3).forEach((record, idx) => {
                    // Sample data logging removed
                });
                
                // ƒê·∫øm s·ªë b·∫£n ghi c√≥ start_time
                const recordsWithStartTime = apiData.filter(r => getOrderField(r, 'start_time')).length;
            }
            
            const allData = Array.isArray(apiData) ? apiData : [];
            ordersData = transformApiData(allData);
            
            // Ki·ªÉm tra d·ªØ li·ªáu sau khi transform v√† l·ªçc
            if (ordersData.length > 0) {
                // Log c√°c m·∫´u ƒë·ªÉ ki·ªÉm tra start_time
                ordersData.slice(0, 3).forEach((record, idx) => {
                    // Sample transformed data logging removed
                });
                
                // ƒê·∫øm s·ªë b·∫£n ghi c√≥ start_time
                const recordsWithStartTime = ordersData.filter(r => getOrderField(r, 'start_time')).length;
            }
            
            // L∆∞u d·ªØ li·ªáu g·ªëc cho filtering
            originalOrdersData = [...ordersData];
            filteredOrdersData = [...ordersData];
            
            // Log sample data ƒë·ªÉ debug
            if (ordersData.length > 0) {
                // Sample orders data logging removed
            }
        } catch (error) {
            ordersData = [];
            showNotification('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu: ' + error.message, 'error');
        }
    }

    /**
     * Transform API data
     */
    function transformApiData(apiData) {
        if (!Array.isArray(apiData)) {
            return [];
        }

        const transformedData = [];
        
        for (let i = 0; i < apiData.length; i++) {
            transformedData[i] = transformOrder(apiData[i]);
        }
        
        return transformedData;
    }

    /**
     * Transform m·ªôt order
     */
    function transformOrder(order) {
        let workflowDef = order.workflow_definition;
        
        // Log d·ªØ li·ªáu th√¥ t·ª´ API ƒë·ªÉ debug
        
        if (getOrderField(order, 'start_time')) {
            // API Data logging removed
        }
        
        const nextStage = getNextStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY);
        
        // T·∫°o ƒë·ªëi t∆∞·ª£ng k·∫øt qu·∫£
        const transformedOrder = {
            id: order.id || order.order_id || order.production_order_id,
            production_order: order.order_code || order.production_order,
            order_type: order.order_type || '', // Th√™m tr∆∞·ªùng lo·∫°i LSX
            product_name: order.product_name,
            internal_product_code: order.internal_product_code,
            customer_name: order.customer_name,
            total_quantity: order.quantity || order.total_quantity,
            deployed_quantity: order.deployed_quantity || 0, // Th√™m deployed_quantity
            sheet_count: order.sheet_count || 0, // Th√™m sheet_count
            [getFieldName('input_quantity')]: order.quantity || order.total_quantity || 0,
            [getFieldName('output_quantity')]: getOrderField(order, 'output_quantity'),
            [getFieldName('good_quantity')]: getOrderField(order, 'good_quantity'),
            [getFieldName('ng_quantity')]: getOrderField(order, 'ng_quantity'),
            [getFieldName('handover_quantity')]: getOrderField(order, 'handover_quantity'),
            [getFieldName('status')]: getOrderField(order, 'status') || 'waiting',
            [getFieldName('machine_name')]: getOrderField(order, 'machine_name'),
            [getFieldName('worker_name')]: getOrderField(order, 'worker_name'),
            [getFieldName('note')]: getOrderField(order, 'note') || order.notes || '',
            [getFieldName('start_time')]: getOrderField(order, 'start_time'),
            [getFieldName('end_time')]: getOrderField(order, 'end_time'),
            paper_type: order.paper_type || '',
            paper_weight: order.paper_weight || 0,
            paper_length: order.paper_length  || 0,
            paper_width: order.paper_width  || 0,
            blank_count: order.blank_count|| 0, // S·ªë ph√¥i
            [getFieldName('shift')]: getOrderField(order, 'shift'),
            delivery_date: order.delivery_date,
            deployment_date: order.deployment_date || order.created_at,
            assigned_machine: order.assigned_machine || '', // Th√™m tr∆∞·ªùng assigned_machine
            workflow_definition: workflowDef,
            next_stage: nextStage,
            previous_stage: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY),
            
            // D·ªØ li·ªáu t·ª´ stage tr∆∞·ªõc
            previous_stage_good_quantity: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_good_quantity`] || 0) : 0,
            previous_stage_ng_quantity: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_ng_quantity`] || 0) : 0,
            previous_stage_handover_quantity: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_handover_quantity`] || 0) : 0,
            previous_stage_status: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_status`] || 'waiting') : null,
            previous_stage_worker_name: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_worker_name`] || '') : '',
            previous_stage_machine_name: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_machine_name`] || '') : '',
            previous_stage_start_time: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_start_time`] || null) : null,
            previous_stage_end_time: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_end_time`] || null) : null,
            
            // D·ªØ li·ªáu t·ª´ stage ti·∫øp theo
            next_stage_good_quantity: nextStage ? (order[`${nextStage}_good_quantity`] || 0) : 0,
            next_stage_ng_quantity: nextStage ? (order[`${nextStage}_ng_quantity`] || 0) : 0,
            next_stage_handover_quantity: nextStage ? (order[`${nextStage}_handover_quantity`] || 0) : 0,
            next_stage_status: nextStage ? (order[`${nextStage}_status`] || 'waiting') : null,
            next_stage_worker_name: nextStage ? (order[`${nextStage}_worker_name`] || '') : '',
            next_stage_machine_name: nextStage ? (order[`${nextStage}_machine_name`] || '') : '',
            next_stage_start_time: nextStage ? (order[`${nextStage}_start_time`] || null) : null,
            next_stage_end_time: nextStage ? (order[`${nextStage}_end_time`] || null) : null,
            
            created_at: order.created_at,
            updated_at: order.updated_at
        };
        
        // Log d·ªØ li·ªáu sau khi transform ƒë·ªÉ debug
        if (transformedOrder[getFieldName('start_time')]) {
            // Transformed data logging removed
        }
        
        return transformedOrder;
    }

    /**
     * =================================================================
     * WORKFLOW FUNCTIONS - H√ÄM X·ª¨ L√ù WORKFLOW
     * =================================================================
     */

    /**
     * L·∫•y stage ti·∫øp theo t·ª´ workflow definition
     * @param {string} workflowDef - Workflow definition (VD: "xa,xen,in" ho·∫∑c "xa,in_offset")
     * @param {string} currentStage - Stage hi·ªán t·∫°i
     * @returns {string|null} Stage ti·∫øp theo ho·∫∑c null n·∫øu l√† stage cu·ªëi
     */
    function getNextStageFromWorkflow(workflowDef, currentStage) {
        if (!workflowDef) {
            return null;
        }
        
        const stages = workflowDef.split(',').map(s => s.trim());
        const currentIndex = stages.indexOf(currentStage);
        
        if (currentIndex === -1 || currentIndex >= stages.length - 1) {
            return null; // Kh√¥ng t√¨m th·∫•y ho·∫∑c ƒë√£ l√† stage cu·ªëi
        }
        
        const nextStage = stages[currentIndex + 1];
        return nextStage;
    }

    /**
     * L·∫•y stage tr∆∞·ªõc ƒë√≥ t·ª´ workflow
     * @param {string} workflowDef - ƒê·ªãnh nghƒ©a workflow
     * @param {string} currentStage - Stage hi·ªán t·∫°i
     * @returns {string|null} Stage tr∆∞·ªõc ƒë√≥ ho·∫∑c null n·∫øu l√† stage ƒë·∫ßu
     */
    function getPreviousStageFromWorkflow(workflowDef, currentStage) {
        if (!workflowDef) {
            return null;
        }
        
        const stages = workflowDef.split(',').map(s => s.trim());
        const currentIndex = stages.indexOf(currentStage);
        
        if (currentIndex === -1 || currentIndex <= 0) {
            return null; // Kh√¥ng t√¨m th·∫•y ho·∫∑c ƒë√£ l√† stage ƒë·∫ßu
        }
        
        const previousStage = stages[currentIndex - 1];
        return previousStage;
    }

    /**
     * L·∫•y t√™n hi·ªÉn th·ªã c·ªßa stage
     * @param {string} stageKey - Key c·ªßa stage
     * @returns {string} T√™n hi·ªÉn th·ªã
     */
    function getStageDisplayName(stageKey) {
        const stageNames = {
            'xa': 'X·∫£',
            'xen': 'X√©n', 
            'in_offset': 'In Offset',
            'boi': 'B·ªìi',
            'be': 'B·∫ø',
            'dan': 'D√°n',
            'kho': 'Kho'
        };
        
        return stageNames[stageKey] || stageKey.toUpperCase();
    }

    /**
     * L·∫•y m√†u s·∫Øc theo stage
     * @param {string} stageKey - Key c·ªßa stage
     * @returns {string} CSS class m√†u s·∫Øc
     */
    function getStageColor(stageKey) {
        const stageColors = {
            'xa': 'primary',
            'xen': 'success',
            'in_offset': 'purple',
            'boi': 'warning',
            'be': 'danger',
            'dan': 'dark',
            'kho': 'secondary'
        };
        
        return stageColors[stageKey] || 'secondary';
    }

        

    /**
     * =================================================================
     * KH·ªûI T·∫†O TRANG - PAGE INITIALIZATION
     * =================================================================
     */
    
    // Kh·ªüi t·∫°o khi trang ƒë∆∞·ª£c load
    document.addEventListener('DOMContentLoaded', function() {
        initializePage();
    });

    /**
     * Kh·ªüi t·∫°o trang - load d·ªØ li·ªáu v√† setup UI
     */
    async function initializePage() {

        
        try {
            showLoading('ƒêang t·∫£i d·ªØ li·ªáu...');
            
            // Set gi√° tr·ªã m·∫∑c ƒë·ªãnh cho filter ng√†y
            setDefaultDateFilter();
            
            // T·∫£i d·ªØ li·ªáu t·ª´ API
            await loadOrdersData();
            await loadMachineStatus();
            
            // Kh·ªüi t·∫°o tabs tr∆∞·ªõc khi render
            await initializeTabs();
            
            // C·∫≠p nh·∫≠t filter options sau khi c√≥ d·ªØ li·ªáu m√°y
            updateMachineFilterOptions();
            
            // Render giao di·ªán
            renderOrdersTable();
            updateStatistics();
            
            // Kh·ªüi t·∫°o filters
            setupFilterChangeListeners();
            setupSearchDebounce();
            
            // Log t·ªïng th·ªùi gian
            // logTotalLoadTime();
            
            // showNotification('ƒê√£ t·∫£i d·ªØ li·ªáu th√†nh c√¥ng', 'success');
            
        } catch (error) {
            showNotification('L·ªói t·∫£i d·ªØ li·ªáu: ' + error.message, 'error');
            
   
            
            renderOrdersTable();
            updateStatistics();
        } finally {
            hideLoading();
        }
    }

    

    /**
     * Render b·∫£ng danh s√°ch l·ªánh s·∫£n xu·∫•t v·ªõi tab structure
     */
    function renderOrdersTable() {
        // Ki·ªÉm tra c√≥ d·ªØ li·ªáu kh√¥ng
        if (ordersData.length === 0) {
            // Hi·ªÉn th·ªã th√¥ng b√°o tr·ªëng cho t·∫•t c·∫£ c√°c tab
            const emptyMessage = `
                <tr>
                    <td colspan="13" class="text-center text-muted py-4">
                        <i class="bi bi-inbox fs-1 mb-2 d-block"></i>
                        Kh√¥ng c√≥ l·ªánh s·∫£n xu·∫•t n√†o cho c√¥ng ƒëo·∫°n ${STAGE_CONFIG.NAME}
                    </td>
                </tr>
            `;
            
            // L·∫•y t·∫•t c·∫£ c√°c tab body ƒë√£ ƒë∆∞·ª£c t·∫°o ƒë·ªông
            const tabBodies = document.querySelectorAll('[id$="TableBody"]');
            tabBodies.forEach(tbody => {
                tbody.innerHTML = emptyMessage;
            });
            
            // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho c√°c tab
            updateTabCountsDynamic();
            return;
        }
        
        // L·ªçc c√°c m√°y thu·ªôc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Ph√¢n lo·∫°i d·ªØ li·ªáu theo m√°y (hi·ªÉn th·ªã t·∫•t c·∫£ l·ªánh ch∆∞a b√†n giao, k·ªÉ c·∫£ ch∆∞a s·∫µn s√†ng)
        const machineOrders = {};
        MStageMachines.forEach(machine => {
            const machineName = machine.machine_name;
            machineOrders[machineName] = ordersData.filter(order => {
                const assignedMachine = order.assigned_machine || '';
                const inputQuantity = getInputQuantityFromPreviousStage(order);
                
                // T√≠nh t·ªïng s·ªë l∆∞·ª£ng b√†n giao v√† input
                const previousStageHandover = order.previous_stage_handover_quantity || 0;
                const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
                const currentStageInput = getOrderField(order, 'input_quantity') || 0;
                
 
                
                return assignedMachine.includes(machineName);
            });
        });
        
        // Render t·ª´ng tab m√°y
        MStageMachines.forEach(machine => {
            const machineName = machine.machine_name;
            const machineId = `machine-${machineName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            const tableBodyId = `${machineId}TableBody`;
            renderTabTable(tableBodyId, machineOrders[machineName] || []);
        });
        
        // Render tab "T·∫•t c·∫£" (hi·ªÉn th·ªã t·∫•t c·∫£ l·ªánh, k·ªÉ c·∫£ ƒë√£ ho√†n th√†nh)
        const activeOrders = ordersData.filter(order => {
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // T√≠nh t·ªïng s·ªë l∆∞·ª£ng b√†n giao v√† input
            const previousStageHandover = order.previous_stage_handover_quantity || 0;
            const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
            const currentStageInput = getOrderField(order, 'input_quantity') || 0;
            

            
            return true; // Hi·ªÉn th·ªã t·∫•t c·∫£ l·ªánh
        });
        renderTabTable('allTableBody', activeOrders);
        
        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho c√°c tab
        updateTabCountsDynamic(machineOrders);
        
        // Load d·ªØ li·ªáu b√°o c√°o
        loadReportData();
    }
    

    
    /**
     * Render b·∫£ng cho m·ªôt tab c·ª• th·ªÉ
     */
    function renderTabTable(tableBodyId, orders) {
        const tableBody = document.getElementById(tableBodyId);
        if (!tableBody) {
            console.error(`Table body not found: ${tableBodyId}`);
            return;
        }
        
        // X√≥a d·ªØ li·ªáu c≈©
        tableBody.innerHTML = '';
        
        // Ki·ªÉm tra c√≥ d·ªØ li·ªáu kh√¥ng
        if (orders.length === 0) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="13" class="text-center text-muted py-4">
                        <i class="bi bi-inbox fs-1 mb-2 d-block"></i>
                        Kh√¥ng c√≥ l·ªánh s·∫£n xu·∫•t n√†o
                    </td>
                </tr>
            `;
            return;
        }

        // S·∫Øp x·∫øp orders: l·ªánh s·∫µn s√†ng l√™n ƒë·∫ßu, sau ƒë√≥ l·ªánh b·ªã disable, cu·ªëi c√πng theo th·ªùi gian b·∫Øt ƒë·∫ßu
        const sortedOrders = [...orders].sort((a, b) => {
            // Ki·ªÉm tra l·ªánh n√†o ƒëang ch·∫°y
            const aIsRunning = isOrderRunning(a).isRunning;
            const bIsRunning = isOrderRunning(b).isRunning;
            
            // Ki·ªÉm tra l·ªánh n√†o s·∫µn s√†ng (kh√¥ng b·ªã disable)
            const aIsReady = isPreviousStageReady(a) && getOrderMachine(a);
            const bIsReady = isPreviousStageReady(b) && getOrderMachine(b);
            
            // ∆Øu ti√™n 1: L·ªánh ƒëang ch·∫°y
            if (aIsRunning && !bIsRunning) return -1;
            if (!aIsRunning && bIsRunning) return 1;
            
            // ∆Øu ti√™n 2: L·ªánh s·∫µn s√†ng (kh√¥ng b·ªã disable) l√™n ƒë·∫ßu
            if (aIsReady && !bIsReady) return -1;
            if (!aIsReady && bIsReady) return 1;
            
            // ∆Øu ti√™n 3: N·∫øu c·∫£ hai ƒë·ªÅu s·∫µn s√†ng ho·∫∑c ƒë·ªÅu kh√¥ng s·∫µn s√†ng, s·∫Øp x·∫øp theo th·ªùi gian b·∫Øt ƒë·∫ßu
            const aStartTime = getOrderField(a, 'start_time') ? new Date(getOrderField(a, 'start_time')).getTime() : 0;
            const bStartTime = getOrderField(b, 'start_time') ? new Date(getOrderField(b, 'start_time')).getTime() : 0;
            
            // L·ªánh b·∫Øt ƒë·∫ßu s·ªõm h∆°n l√™n ƒë·∫ßu (th·ªùi gian l·ªõn h∆°n = m·ªõi h∆°n)
            return bStartTime - aStartTime;
        });

        
        const fragment = document.createDocumentFragment();
        
        sortedOrders.forEach((order, index) => {
            try {
                const row = createOrderTableRow(order, index);
                fragment.appendChild(row);
            } catch (error) {
                console.error(`Error creating row for order ${order.id}:`, error);
                // Create a simple error row
                const errorRow = document.createElement('tr');
                errorRow.innerHTML = `
                    <td colspan="13" class="text-center text-danger">
                        L·ªói hi·ªÉn th·ªã l·ªánh ${order.id || 'N/A'}
                    </td>
                `;
                fragment.appendChild(errorRow);
            }
        });
        
        tableBody.appendChild(fragment);
    }
    
    /**
     * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng hi·ªÉn th·ªã tr√™n c√°c tab ƒë·ªông
     */
    function updateTabCountsDynamic(machineOrders = {}) {
        // L·ªçc c√°c m√°y thu·ªôc Stage hi·ªán t·∫°i
        const stageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho t·ª´ng m√°y
        stageMachines.forEach(machine => {
            const machineName = machine.machine_name;
            const machineId = `machine-${machineName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            const countElement = document.getElementById(`${machineId}-count`);
            if (countElement) {
                const orderCount = machineOrders[machineName] ? machineOrders[machineName].length : 0;
                countElement.textContent = orderCount;
            }
        });
        
        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho tab "T·∫•t c·∫£" (ch·ªâ l·ªánh ch∆∞a b√†n giao)
        const allCountElement = document.getElementById('all-count');
        if (allCountElement) {
            const activeOrders = ordersData.filter(order => {
                const inputQuantity = getInputQuantityFromPreviousStage(order);
                return inputQuantity > 0;
            });
            allCountElement.textContent = activeOrders.length;
        }
        
        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho tab "B√°o c√°o"
        const handedOverOrders = ordersData.filter(order => {
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // T√≠nh t·ªïng s·ªë l∆∞·ª£ng b√†n giao v√† input
            const previousStageHandover = order.previous_stage_handover_quantity || 0;
            const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
            const currentStageInput = getOrderField(order, 'input_quantity') || 0;

            
            return inputQuantity <= 0 && previousStageHandover > 0;
        });
        updateReportCount(handedOverOrders.length);
    }


    /**
     * Kh·ªüi t·∫°o tab functionality
     */
    async function initializeTabs() {
        // T·∫£i d·ªØ li·ªáu m√°y t·ª´ API
        await loadMachineStatus();
        
        // T·∫°o c√°c tab ƒë·ªông d·ª±a tr√™n d·ªØ li·ªáu m√°y
        await createDynamicTabs();
        
        // Th√™m event listeners cho c√°c tab
        const tabs = document.querySelectorAll('#machineTabs .nav-link');
        tabs.forEach(tab => {
            tab.addEventListener('click', function(e) {
                // C·∫≠p nh·∫≠t active state
                tabs.forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // Hi·ªÉn th·ªã tab content t∆∞∆°ng ·ª©ng
                const targetId = this.getAttribute('data-bs-target');
                const targetContent = document.querySelector(targetId);
                
                if (targetContent) {
                    document.querySelectorAll('.tab-pane').forEach(pane => {
                        pane.classList.remove('show', 'active');
                    });
                    targetContent.classList.add('show', 'active');
                }
                
                // N·∫øu click v√†o tab b√°o c√°o, load d·ªØ li·ªáu b√°o c√°o
                if (targetId === '#report-content') {
                    loadReportData();
                }
                
                // C·∫≠p nh·∫≠t URL hash ƒë·ªÉ bookmark
                window.location.hash = targetId.replace('#', '');
            });
        });
        
        // Kh√¥i ph·ª•c tab t·ª´ URL hash n·∫øu c√≥
        const hash = window.location.hash;
        if (hash) {
            const targetTab = document.querySelector(`[data-bs-target="${hash}"]`);
            if (targetTab) {
                // X√≥a active class t·ª´ t·∫•t c·∫£ tabs v√† content
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                    link.setAttribute('aria-selected', 'false');
                });
                document.querySelectorAll('.tab-pane').forEach(pane => {
                    pane.classList.remove('show', 'active');
                });
                
                // K√≠ch ho·∫°t tab ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
                targetTab.classList.add('active');
                targetTab.setAttribute('aria-selected', 'true');
                
                const targetContent = document.querySelector(hash);
                if (targetContent) {
                    targetContent.classList.add('show', 'active');
                }
            }
        }
    }
    
    /**
     * T·∫°o c√°c tab ƒë·ªông d·ª±a tr√™n d·ªØ li·ªáu m√°y t·ª´ production_machines
     */
    async function createDynamicTabs() {
        const machineTabsContainer = document.getElementById('machineTabs');
        const tabContentContainer = document.getElementById('machineTabContent');
        
        console.log('üîç Creating dynamic tabs for stage:', STAGE_CONFIG.KEY);
        console.log('üîç Available machines:', machineStatusData);
        
        // L∆∞u tab "B√°o c√°o" n·∫øu c√≥
        const reportTab = machineTabsContainer.querySelector('#report-tab');
        const reportContent = tabContentContainer.querySelector('#report-content');
        
        // X√≥a n·ªôi dung c≈© (nh∆∞ng gi·ªØ l·∫°i tab "B√°o c√°o")
        machineTabsContainer.innerHTML = '';
        tabContentContainer.innerHTML = '';
        
        // L·ªçc c√°c m√°y thu·ªôc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        console.log('üîç Filtered machines for stage:', MStageMachines);
        
        // T·∫°o tab cho t·ª´ng m√°y ${STAGE_CONFIG.NAME}
        MStageMachines.forEach((machine, index) => {
            const machineName = machine.machine_name;
            // T·∫°o ID an to√†n cho CSS selector (kh√¥ng b·∫Øt ƒë·∫ßu b·∫±ng s·ªë)
            const machineId = `machine-${machineName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            const tabId = `${machineId}-tab`;
            const contentId = `${machineId}-content`;
            
            // T·∫°o tab navigation
            const tabItem = document.createElement('li');
            tabItem.className = 'nav-item';
            tabItem.setAttribute('role', 'presentation');
            
            const isFirstTab = index === 0;
            tabItem.innerHTML = `
                <button class="nav-link ${isFirstTab ? 'active' : ''}" id="${tabId}" 
                        data-bs-toggle="tab" data-bs-target="#${contentId}" 
                        type="button" role="tab" aria-controls="${contentId}" 
                        aria-selected="${isFirstTab}">
                    <i class="bi bi-gear me-1"></i>${machineName}
                    <!-- <span class="badge bg-primary ms-1" id="${machineId}-count">0</span> -->
                </button>
            `;
            
            machineTabsContainer.appendChild(tabItem);
            
            // T·∫°o tab content
            const tabPane = document.createElement('div');
            tabPane.className = `tab-pane fade ${isFirstTab ? 'show active' : ''}`;
            tabPane.id = contentId;
            tabPane.setAttribute('role', 'tabpanel');
            tabPane.setAttribute('aria-labelledby', tabId);
            
            tabPane.innerHTML = `
                <div class="table-container">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th style="width: 40px!important; min-width: 40px!important;" class="text-center">#</th>
                                <th style="width: 150px!important; min-width: 120px!important;" class="text-center">L·ªánh SX</th>
                                <th style="width: 70px!important; min-width: 50px!important;" class="text-center">Lo·∫°i LSX</th>
                                <th style="width: 260px!important; min-width: 150px!important;" class="text-center">S·∫£n ph·∫©m</th>
                                <th style="width: 130px!important; min-width: 130px!important;" class="text-center">Lo·∫°i gi·∫•y</th>
                                <th style="width: 90px!important; min-width: 90px!important;" class="text-center">ƒê·ªãnh l∆∞·ª£ng</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">K·∫ø ho·∫°ch</th>
                                <th style="width: 150px!important; min-width: 150px!important;" class="text-center">Tri·ªÉn khai</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT x·∫£</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT x·∫£</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">S·ªë ph√¥i</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Ti·∫øn ƒë·ªô</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">M√°y/Th·ª£</th>
                            </tr>
                        </thead>
                        <tbody id="${machineId}TableBody">
                        </tbody>
                    </table>
                </div>
            `;
            
            tabContentContainer.appendChild(tabPane);
        });
        
        // Th√™m tab "T·∫•t c·∫£" ·ªü cu·ªëi
        const allTabItem = document.createElement('li');
        allTabItem.className = 'nav-item';
        allTabItem.setAttribute('role', 'presentation');
        
        // N·∫øu kh√¥ng c√≥ m√°y n√†o, "T·∫•t c·∫£" tab s·∫Ω l√† active m·∫∑c ƒë·ªãnh
        const isAllTabActive = MStageMachines.length === 0;
        
        allTabItem.innerHTML = `
            <button class="nav-link ${isAllTabActive ? 'active' : ''}" id="all-tab" 
                    data-bs-toggle="tab" data-bs-target="#all-content" 
                    type="button" role="tab" aria-controls="all-content" 
                    aria-selected="${isAllTabActive}">
                <i class="bi bi-list-ul me-1"></i>T·∫•t c·∫£
                <span class="badge bg-secondary ms-1" id="all-count">0</span>
            </button>
        `;
        
        machineTabsContainer.appendChild(allTabItem);
        
        // Th√™m content cho tab "T·∫•t c·∫£"
        const allTabPane = document.createElement('div');
        allTabPane.className = `tab-pane fade ${isAllTabActive ? 'show active' : ''}`;
        allTabPane.id = 'all-content';
        allTabPane.setAttribute('role', 'tabpanel');
        allTabPane.setAttribute('aria-labelledby', 'all-tab');
        
        allTabPane.innerHTML = `
            <div class="table-container">
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            <th style="width: 40px!important; min-width: 40px!important;" class="text-center">#</th>
                            <th style="width: 150px!important; min-width: 120px!important;" class="text-center">L·ªánh SX</th>
                            <th style="width: 70px!important; min-width: 50px!important;" class="text-center">Lo·∫°i LSX</th>
                            <th style="width: 260px!important; min-width: 150px!important;" class="text-center">S·∫£n ph·∫©m</th>
                            <th style="width: 130px!important; min-width: 130px!important;" class="text-center">Lo·∫°i gi·∫•y</th>
                            <th style="width: 90px!important; min-width: 90px!important;" class="text-center">ƒê·ªãnh l∆∞·ª£ng</th>
                            <th style="width: 100px!important; min-width: 100px!important;" class="text-center">K·∫ø ho·∫°ch</th>
                            <th style="width: 150px!important; min-width: 150px!important;" class="text-center">Tri·ªÉn khai</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT ${STAGE_CONFIG.KEY}</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT ${STAGE_CONFIG.KEY}</th>
                            <th style="width: 100px!important; min-width: 100px!important;" class="text-center">S·ªë ph√¥i</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Ti·∫øn ƒë·ªô</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">M√°y/Th·ª£</th>
                        </tr>
                    </thead>
                    <tbody id="allTableBody">
                    </tbody>
                </table>
            </div>
        `;
        
        tabContentContainer.appendChild(allTabPane);
        
        // Th√™m l·∫°i tab "B√°o c√°o" n·∫øu c√≥
        if (reportTab) {
            machineTabsContainer.appendChild(reportTab);
        } else {
            // T·∫°o tab "B√°o c√°o" n·∫øu ch∆∞a c√≥
            const reportTabItem = document.createElement('li');
            reportTabItem.className = 'nav-item';
            reportTabItem.setAttribute('role', 'presentation');
            
            reportTabItem.innerHTML = `
                <button class="nav-link" id="report-tab" 
                        data-bs-toggle="tab" data-bs-target="#report-content" 
                        type="button" role="tab" aria-controls="report-content" 
                        aria-selected="false">
                    <i class="bi bi-file-earmark-text me-1"></i>B√°o c√°o
                    <span class="badge bg-info ms-1" id="report-count">0</span>
                </button>
            `;
            
            machineTabsContainer.appendChild(reportTabItem);
        }
        
        if (reportContent) {
            tabContentContainer.appendChild(reportContent);
        } else {
            // T·∫°o content cho tab "B√°o c√°o" n·∫øu ch∆∞a c√≥
            const reportTabPane = document.createElement('div');
            reportTabPane.className = 'tab-pane fade';
            reportTabPane.id = 'report-content';
            reportTabPane.setAttribute('role', 'tabpanel');
            reportTabPane.setAttribute('aria-labelledby', 'report-tab');
            
            reportTabPane.innerHTML = `
                <div class="table-container">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th style="width: 40px!important; min-width: 40px!important;" class="text-center">#</th>
                                <th style="width: 150px!important; min-width: 120px!important;" class="text-center">L·ªánh SX</th>
                                <th style="width: 70px!important; min-width: 50px!important;" class="text-center">Lo·∫°i LSX</th>
                                <th style="width: 260px!important; min-width: 150px!important;" class="text-center">S·∫£n ph·∫©m</th>
                                <th style="width: 130px!important; min-width: 130px!important;" class="text-center">Lo·∫°i gi·∫•y</th>
                                <th style="width: 90px!important; min-width: 90px!important;" class="text-center">ƒê·ªãnh l∆∞·ª£ng</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">K·∫ø ho·∫°ch</th>
                                <th style="width: 150px!important; min-width: 150px!important;" class="text-center">Tri·ªÉn khai</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT x·∫£</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT x·∫£</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">S·ªë ph√¥i</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Ti·∫øn ƒë·ªô</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">M√°y/Th·ª£</th>
                            </tr>
                        </thead>
                        <tbody id="reportTableBody">
                        </tbody>
                    </table>
                </div>
            `;
            
            tabContentContainer.appendChild(reportTabPane);
        }
        
        // Load d·ªØ li·ªáu b√°o c√°o ngay khi t·∫°o tab
        loadReportData();
    }

    /**
     * L·ªçc d·ªØ li·ªáu theo tab hi·ªán t·∫°i
     */
    function filterDataByCurrentTab() {
        const activeTab = document.querySelector('#machineTabs .nav-link.active');
        if (!activeTab) return ordersData;
        
        const tabId = activeTab.id;
        
        // N·∫øu l√† tab "T·∫•t c·∫£"
        if (tabId === 'all-tab') {
            return ordersData;
        }
        
        // L·∫•y t√™n m√°y t·ª´ tab ID
        const machineName = tabId.replace('-tab', '').replace(/-/g, ' ');
        
        // L·ªçc theo m√°y ƒë∆∞·ª£c g√°n
        return ordersData.filter(order => {
            const assignedMachine = order.assigned_machine || '';
            return assignedMachine.includes(machineName);
        });
    }
    
    /**
     * C·∫≠p nh·∫≠t hi·ªÉn th·ªã tab d·ª±a tr√™n filter m√°y
     */
    function updateTabBasedOnMachineFilter() {
        const machineFilter = document.getElementById('machineFilter');
        if (!machineFilter) {
            return;
        }
        if (!machineFilter.value) return;
        
        const machineValue = machineFilter.value;
        let targetTabId = 'all-tab';
        
        // L·ªçc c√°c m√°y thu·ªôc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Ki·ªÉm tra m√°y ƒë∆∞·ª£c ch·ªçn v√† chuy·ªÉn ƒë·∫øn tab t∆∞∆°ng ·ª©ng
        for (const machine of MStageMachines) {
            if (machineValue.includes(machine.machine_name)) {
                const machineId = `machine-${machine.machine_name.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                targetTabId = `${machineId}-tab`;
                break;
            }
        }
        
        const targetTab = document.getElementById(targetTabId);
        if (targetTab) {
            targetTab.click();
        }
    }
    
    /**
     * L·∫•y danh s√°ch t·∫•t c·∫£ m√°y c·ªßa stage hi·ªán t·∫°i c√≥ s·∫µn
     * @returns {Array} - M·∫£ng c√°c m√°y c·ªßa stage hi·ªán t·∫°i
     */
    function getAvailableStageMachines() {
        if (!machineStatusData || machineStatusData.length === 0) {
            return [];
        }
        
        return machineStatusData.filter(machine => 
            machine.stage_machine && 
            machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`) &&
            machine.machine_name
        ).map(machine => machine.machine_name);
    }

    /**
     * L·∫•y s·ªë l∆∞·ª£ng t·ª´ stage tr∆∞·ªõc ƒë√≥ cho b·∫•t k·ª≥ stage n√†o
     * @param {object} order - L·ªánh s·∫£n xu·∫•t
     * @param {string} currentStage - Stage hi·ªán t·∫°i (m·∫∑c ƒë·ªãnh: STAGE_CONFIG.KEY)
     * @returns {number} - S·ªë l∆∞·ª£ng t·ª´ stage tr∆∞·ªõc
     */
    function getInputQuantityFromPreviousStage(order, currentStage = STAGE_CONFIG.KEY) {
        if (!order || !order.workflow_definition) {
            return 0;
        }

        // S·ª≠ d·ª•ng function getPreviousStageFromWorkflow ƒë·ªÉ l·∫•y stage tr∆∞·ªõc
        const previousStage = getPreviousStageFromWorkflow(order.workflow_definition, currentStage);
        
        if (!previousStage) {
            // Stage hi·ªán t·∫°i l√† stage ƒë·∫ßu ti√™n ho·∫∑c kh√¥ng t√¨m th·∫•y
            // ∆Øu ti√™n sheet_count, fallback v·ªÅ quantity
            return order.sheet_count || order.quantity || 0;
        }

        // S·ª≠ d·ª•ng d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c transform s·∫µn t·ª´ previous_stage_handover_quantity
        if (order.previous_stage_handover_quantity && order.previous_stage_handover_quantity > 0) {
            return order.previous_stage_handover_quantity;
        }
        
        if (order.previous_stage_good_quantity && order.previous_stage_good_quantity > 0) {
            return order.previous_stage_good_quantity;
        }

        // Fallback v·ªÅ c√°ch c≈© n·∫øu d·ªØ li·ªáu transform ch∆∞a c√≥
        const handoverField = `${previousStage}_handover_quantity`;
        const goodField = `${previousStage}_good_quantity`;
        
        // L·∫•y s·ªë l∆∞·ª£ng t·ª´ stage tr∆∞·ªõc
        const handoverQty = order[handoverField] || 0;
        const goodQty = order[goodField] || 0;
        
        // ∆Øu ti√™n handover_quantity, fallback v·ªÅ good_quantity
        return handoverQty > 0 ? handoverQty : goodQty;
    }

    /**
     * L·∫•y t√™n m√°y t·ª´ tr∆∞·ªùng assigned_machine cho c√¥ng ƒëo·∫°n hi·ªán t·∫°i
     */
    function getStageMachineFromAssigned(assignedMachine) {
        if (!assignedMachine) return '';
        
        const machines = assignedMachine.split(',').map(m => m.trim());
        
        // L·ªçc c√°c m√°y thu·ªôc Stage hi·ªán t·∫°i
        const stageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // T√¨m m√°y c·ªßa stage hi·ªán t·∫°i trong danh s√°ch m√°y ƒë∆∞·ª£c g√°n
        for (const stageMachine of stageMachines) {
            if (machines.some(machine => machine.includes(stageMachine.machine_name))) {
                return stageMachine.machine_name;
            }
        }
        
        return '';
    }
    
    /**
     * Ki·ªÉm tra xem assigned_machine c√≥ ch·ª©a m√°y c·ªßa stage hi·ªán t·∫°i kh√¥ng
     */
    function hasStageMachine(assignedMachine) {
        if (!assignedMachine) return false;
        
        const machines = assignedMachine.split(',').map(m => m.trim());
        
        // L·ªçc c√°c m√°y thu·ªôc Stage hi·ªán t·∫°i
        const stageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Ki·ªÉm tra xem c√≥ m√°y c·ªßa stage hi·ªán t·∫°i n√†o trong danh s√°ch m√°y ƒë∆∞·ª£c g√°n
        return stageMachines.some(stageMachine => 
            machines.some(machine => machine.includes(stageMachine.machine_name))
        );
    }
    
    /**
     * Ki·ªÉm tra xem stage tr∆∞·ªõc ƒë√£ ho√†n th√†nh v√† s·∫µn s√†ng cho stage hi·ªán t·∫°i ch∆∞a
     * @param {object} order - L·ªánh s·∫£n xu·∫•t
     * @returns {boolean} - true n·∫øu stage tr∆∞·ªõc ƒë√£ ho√†n th√†nh ho·∫∑c kh√¥ng c√≥ stage tr∆∞·ªõc
     */
    function isPreviousStageReady(order) {
        if (!order.previous_stage) {
            return true; // Kh√¥ng c√≥ stage tr∆∞·ªõc = s·∫µn s√†ng
        }
        
        const previousStageStatus = order.previous_stage_status;
        const currentStageStatus = getOrderField(order, 'status');
        
        // N·∫øu stage tr∆∞·ªõc ch∆∞a ho√†n th√†nh v√† stage hi·ªán t·∫°i ch∆∞a b·∫Øt ƒë·∫ßu
        if (previousStageStatus && 
            previousStageStatus !== 'completed' && 
            previousStageStatus !== 'handed_over' && 
            currentStageStatus === 'waiting') {
            return false; // Stage tr∆∞·ªõc ch∆∞a s·∫µn s√†ng
        }
        
        return true; // Stage tr∆∞·ªõc ƒë√£ s·∫µn s√†ng
    }

    /**
     * T·∫°o m·ªôt d√≤ng trong b·∫£ng cho m·ªôt l·ªánh s·∫£n xu·∫•t
     */
    function createOrderTableRow(order, index) {
        const row = document.createElement('tr');
        row.className = 'order-row';
        row.setAttribute('data-order-id', order.id);
        
        // T√≠nh to√°n tr·∫°ng th√°i v√† ti·∫øn ƒë·ªô
        const status = getOrderField(order, 'status') || 'waiting';
        
        // L·∫•y m√°y ƒë∆∞·ª£c g√°n cho l·ªánh n√†y
        const orderMachine = getOrderMachine(order);
        
        let isDisabled = false;
        let displayReason = '';
        
        // Ki·ªÉm tra stage tr∆∞·ªõc ƒë√£ s·∫µn s√†ng ch∆∞a
        const isPreviousReady = isPreviousStageReady(order);
        
        if (!orderMachine) {
            // L·ªánh kh√¥ng ƒë∆∞·ª£c g√°n cho m√°y n√†o ‚Üí b·ªã m·ªù
            isDisabled = true;
            displayReason = `L·ªánh kh√¥ng ƒë∆∞·ª£c g√°n cho m√°y ${STAGE_CONFIG.NAME}`;
        } else {
            // Ki·ªÉm tra s·ªë l∆∞·ª£ng c·∫ßn s·∫£n xu·∫•t
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            if (inputQuantity <= 0) {
                // Kh√¥ng c√≥ s·ªë l∆∞·ª£ng t·ª´ stage tr∆∞·ªõc ‚Üí b·ªã m·ªù
                isDisabled = true;
                const previousStage = order.previous_stage;
                const previousStageName = previousStage ? getStageDisplayName(previousStage) : 'C√¥ng ƒëo·∫°n tr∆∞·ªõc';
                displayReason = `Ch·ªù ${previousStageName} cung c·∫•p s·ªë l∆∞·ª£ng`;
            } else {
                // Ki·ªÉm tra tr·∫°ng th√°i m√°y ƒë∆∞·ª£c g√°n
                const machineStatus = checkMachineStatus(orderMachine);
                
                if (!machineStatus.isRunning) {
                    // M√°y ƒëang tr·ªëng ‚Üí c√≥ th·ªÉ b·∫Øt ƒë·∫ßu
                    isDisabled = false;
                    displayReason = `M√°y ${orderMachine} ƒëang tr·ªëng`;
                } else {
                    // M√°y ƒëang ch·∫°y
                    if (machineStatus.runningOrder && machineStatus.runningOrder.current_order_id == order.id) {
                        // M√°y ƒëang ch·∫°y ch√≠nh l·ªánh n√†y ‚Üí hi·ªÉn th·ªã b√¨nh th∆∞·ªùng
                        isDisabled = false;
                        displayReason = `L·ªánh hi·ªán t·∫°i c·ªßa m√°y ${orderMachine}`;
                    } else {
                        // M√°y ƒëang ch·∫°y l·ªánh kh√°c ‚Üí b·ªã m·ªù
                        isDisabled = true;
                        displayReason = `M√°y ${orderMachine} ƒëang s·∫£n xu·∫•t l·ªánh ${machineStatus.runningOrder ? machineStatus.runningOrder.current_order_code : 'N/A'}`;
                    }
                }
            }
        }
        
        // Th√™m class t∆∞∆°ng ·ª©ng v·ªõi tr·∫°ng th√°i
        if (isDisabled) {
            row.classList.add('disabled-order');
        } else {
            // Ki·ªÉm tra xem l·ªánh c√≥ ƒëang ch·∫°y kh√¥ng
            const orderRunningCheck = isOrderRunning(order);
            if (orderRunningCheck.isRunning) {
                // L·ªánh ƒëang ch·∫°y
                row.classList.add('running-order');
            }
        }
        const inputQty = getOrderField(order, 'input_quantity') || 0;
        const sheet_count = order.sheet_count || 0; // S·ª≠a: l·∫•y s·ªë t·ªù gi·∫•y
        const goodQty = getOrderField(order, 'good_quantity') || 0;
        const ngQty = getOrderField(order, 'ng_quantity') || 0;
        const deployedQty = order.deployed_quantity || 0;
        const progressPercent = inputQty > 0 ? Math.round((goodQty / inputQty) * 100) : 0;
        
        // X√°c ƒë·ªãnh icon v√† m√†u s·∫Øc theo tr·∫°ng th√°i
        let statusIcon = 'bi-clock';
        let statusClass = 'text-warning';
        let statusText = 'Ch·ªù x·ª≠ l√Ω';
        
        switch (status) {
            case 'in_progress':
                statusIcon = 'bi-play-circle';
                statusClass = 'text-primary';
                statusText = 'ƒêang x·ª≠ l√Ω';
                break;
            case 'completed':
                statusIcon = 'bi-check-circle';
                statusClass = 'text-success';
                statusText = 'Ho√†n th√†nh';
                break;
            case 'paused':
                statusIcon = 'bi-pause-circle';
                statusClass = 'text-warning';
                statusText = 'T·∫°m d·ª´ng';
                break;
            case 'handed_over':
                statusIcon = 'bi-arrow-right-circle';
                statusClass = 'text-info';
                statusText = 'ƒê√£ b√†n giao';
                break;
        }
        
        // T·∫°o HTML cho d√≤ng
        row.innerHTML = `
            <td class="text-center">
                <span class="badge bg-light text-dark">${index + 1}</span>
            </td>

            <td>
                <div class="d-flex align-items-center">
                    <i class="bi ${statusIcon} ${statusClass} me-2"></i>
                    <div>
                        <div class="fw-bold ${isDisabled ? 'text-muted' : ''}">${order.production_order}</div>
                        <small class="text-muted">${formatDate(order.deployment_date)} - ${getOrderField(order, 'shift')}</small>
                        <small class="${isDisabled ? 'text-danger' : 'text-success'} d-block">${displayReason}</small>
                    </div>
                </div>
            </td>
            
            <td class="text-center">
                <span class="fw-bold">${order.order_type || ''}</span>
            </td>
            <td>
                <div>
                    <div class="fw-bold">${order.internal_product_code}</div>
                    <small class="text-muted" title="${order.product_name}">${truncateText(order.product_name, 100)}</small>
                </div>
            </td>
            <td class="text-center">
                <span class="badge bg-secondary">${order.paper_type || 'N/A'}</span>
            </td>
            <td class="text-center">
                <span class="fw-bold">${order.paper_weight || 0} gsm</span>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(deployedQty)}</div>
                <small class="text-muted">pcs</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-primary">${formatNumber(sheet_count)}</div>
                <small class="text-muted">t·ªù gi·∫•y</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-success">${formatNumber(order.paper_length || 0)}</div>
                <small class="text-muted">chi·ªÅu d√†i</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-danger">${formatNumber(order.paper_width || 0)}</div>
                <small class="text-muted">chi·ªÅu r·ªông</small>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(order.blank_count || 0)}</div>
                <small class="text-muted">ph√¥i</small>
            </td>
            <td class="text-center">
                <div class="progress" style="height: 20px;">
                    <div class="progress-bar ${progressPercent >= 100 ? 'bg-success' : 'bg-primary'}" 
                         style="width: ${Math.min(progressPercent, 100)}%">
                        ${progressPercent}%
                    </div>
                </div>
                <small class="text-muted">${statusText}</small>
            </td>
            <td class="text-center">
                <small class="text-muted d-block" title="${order.assigned_machine || 'Ch∆∞a g√°n'}">${truncateText(order.assigned_machine || 'Ch∆∞a g√°n', 15)}</small>
            </td>

        `;
        
        // Add data attribute for order ID
        row.setAttribute('data-order-id', order.id);
        
        // Cho ph√©p click n·∫øu l·ªánh kh√¥ng b·ªã disable
        if (!isDisabled) {
            row.style.cursor = 'pointer';
            row.onclick = (e) => {
                // NgƒÉn ch·∫∑n event bubbling ƒë·ªÉ tr√°nh ƒë√≥ng panel
                e.stopPropagation();
                showOrderDetails(order.id);
            };
        } else {
            row.style.cursor = 'not-allowed';
            row.onclick = (e) => {
                e.stopPropagation();
                showNotification(displayReason, 'warning');
            };
        }
        
        return row;
    }


    
    

 
    


    /**
     * C·∫≠p nh·∫≠t th·ªëng k√™ t·ªïng quan
     */
    function updateStatistics() {
        const totalOrders = ordersData.length;
        const totalPlan = ordersData.reduce((sum, order) => sum + (getOrderField(order, 'input_quantity') || 0), 0);
        const totalGood = ordersData.reduce((sum, order) => sum + (getOrderField(order, 'good_quantity') || 0), 0);
        const totalNg = ordersData.reduce((sum, order) => sum + (getOrderField(order, 'ng_quantity') || 0), 0);
        
        // C·∫≠p nh·∫≠t c√°c th·∫ª th·ªëng k√™
        updateElementText('totalOrders', totalOrders);
        updateElementText('totalPlan', formatNumber(totalPlan));
        updateElementText('totalGood', formatNumber(totalGood));
        updateElementText('totalNg', formatNumber(totalNg));
    }

    /**
     * =================================================================
     * X·ª¨ L√ù S·ª∞ KI·ªÜN - EVENT HANDLERS
     * =================================================================
     */


    /**
     * Setup event listeners cho wizard form
     */
    function setupWizardEventListeners() {
        // Event listeners cho c√°c input trong wizard
        const wizardGoodQty = document.getElementById('wizardGoodQty');
        const wizardNgQty = document.getElementById('wizardNgQty');
        const wizardHandoverQty = document.getElementById('wizardHandoverQty');
        
        if (wizardGoodQty) {
            wizardGoodQty.addEventListener('input', function() {
                updateWizardHandoverQuantity();
                if (wizardCurrentStep === 3) updateWizardConfirmation();
            });
        }
        
        if (wizardNgQty) {
            wizardNgQty.addEventListener('input', function() {
                updateWizardHandoverQuantity();
                if (wizardCurrentStep === 3) updateWizardConfirmation();
            });
        }
        
        if (wizardHandoverQty) {
            wizardHandoverQty.addEventListener('input', function() {
                if (wizardCurrentStep === 3) updateWizardConfirmation();
            });
        }
    }

    /**
     * L√†m m·ªõi d·ªØ li·ªáu
     */
    async function refreshData() {
        try {
            showLoading('ƒêang l√†m m·ªõi d·ªØ li·ªáu...');
            await loadOrdersData();
            renderOrdersTable();
            updateStatistics();
            // showNotification('ƒê√£ l√†m m·ªõi d·ªØ li·ªáu th√†nh c√¥ng', 'info');
        } catch (error) {

            showNotification('L·ªói l√†m m·ªõi d·ªØ li·ªáu: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }





    /**
     * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng b√†n giao khi thay ƒë·ªïi s·ªë l∆∞·ª£ng OK
     */
    function updateHandoverQuantity() {
        const goodQty = getElementValue('completeGoodQty') || 0;
        setElementValue('handoverQty', goodQty);
    }
    
    /**
     * Alias cho updateHandoverQuantity (ƒë∆∞·ª£c g·ªçi t·ª´ HTML)
     */
    function updateHandoverQty() {
        updateHandoverQuantity();
    }





    /**
     * =================================================================
     * WIZARD FUNCTIONS - C√ÅC H√ÄM X·ª¨ L√ù WIZARD FORM
     * =================================================================
     */

    let wizardCurrentStep = 1;
    const wizardTotalSteps = 3;

    /**
     * Reset wizard v·ªÅ b∆∞·ªõc 1
     */
    function resetWizard() {
        wizardCurrentStep = 1;
        updateWizardStepDisplay();
    }

    /**
     * C·∫≠p nh·∫≠t hi·ªÉn th·ªã b∆∞·ªõc wizard
     */
    function updateWizardStepDisplay() {
        // Update step indicators
        document.querySelectorAll('.step').forEach((step, index) => {
            const stepNum = index + 1;
            step.classList.remove('active', 'completed');
            
            if (stepNum < wizardCurrentStep) {
                step.classList.add('completed');
            } else if (stepNum === wizardCurrentStep) {
                step.classList.add('active');
            }
        });
        
        // Update step content
        document.querySelectorAll('.step-content').forEach((content, index) => {
            content.classList.remove('active');
            if (index + 1 === wizardCurrentStep) {
                content.classList.add('active');
            }
        });
        
        // Update buttons
        const prevBtn = document.getElementById('wizardPrevBtn');
        const nextBtn = document.getElementById('wizardNextBtn');
        const finishBtn = document.getElementById('wizardFinishBtn');
        
        prevBtn.style.display = wizardCurrentStep > 1 ? 'inline-block' : 'none';
        nextBtn.style.display = wizardCurrentStep < wizardTotalSteps ? 'inline-block' : 'none';
        finishBtn.style.display = wizardCurrentStep === wizardTotalSteps ? 'inline-block' : 'none';
        
        // Update step indicator
        document.getElementById('wizardCurrentStep').textContent = wizardCurrentStep;
        
        // Update handover quantity in step 1
        if (wizardCurrentStep === 1) {
            updateWizardHandoverQuantity();
        }
        
        // Update confirmation data in step 3
        if (wizardCurrentStep === 3) {
            updateWizardConfirmation();
        }
    }

    /**
     * Chuy·ªÉn ƒë·∫øn b∆∞·ªõc ti·∫øp theo
     */
    function wizardNextStep() {
        if (wizardCurrentStep < wizardTotalSteps) {
            // Validate current step
            if (!validateWizardCurrentStep()) {
                return;
            }
            
            wizardCurrentStep++;
            updateWizardStepDisplay();
        }
    }

    /**
     * Quay l·∫°i b∆∞·ªõc tr∆∞·ªõc
     */
    function wizardPreviousStep() {
        if (wizardCurrentStep > 1) {
            wizardCurrentStep--;
            updateWizardStepDisplay();
        }
    }

    /**
     * Validate b∆∞·ªõc hi·ªán t·∫°i
     */
    function validateWizardCurrentStep() {
        switch (wizardCurrentStep) {
            case 1:
                const goodQty = parseInt(getElementValue('wizardGoodQty')) || 0;
                const ngQty = parseInt(getElementValue('wizardNgQty')) || 0;
                if (goodQty + ngQty === 0) {
                    showNotification('T·ªïng s·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0', 'error');
                    return false;
                }
                break;
            case 2:
                const handoverQty = parseInt(getElementValue('wizardHandoverQty')) || 0;
                if (handoverQty <= 0) {
                    showNotification('S·ªë l∆∞·ª£ng b√†n giao ph·∫£i l·ªõn h∆°n 0', 'error');
                    return false;
                }
                break;
        }
        return true;
    }



    /**
     * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng b√†n giao trong wizard
     */
    function updateWizardHandoverQuantity() {
        const goodQty = parseInt(getElementValue('wizardGoodQty')) || 0;
        setElementValue('wizardHandoverQty', goodQty);
    }

    /**
     * C·∫≠p nh·∫≠t d·ªØ li·ªáu x√°c nh·∫≠n trong wizard
     */
    function updateWizardConfirmation() {
        const goodQty = parseInt(getElementValue('wizardGoodQty')) || 0;
        const ngQty = parseInt(getElementValue('wizardNgQty')) || 0;
        const handoverQty = parseInt(getElementValue('wizardHandoverQty')) || 0;
        const total = goodQty + ngQty;
        const progress = total > 0 ? Math.round((goodQty / total) * 100) : 0;
        const machine = getElementValue('wizardMachine');
        const worker = getElementValue('wizardWorker');
        const shift = getElementValue('wizardShift');
        const handoverPerson = getElementValue('wizardHandoverPerson');
        const receiverPerson = getElementValue('wizardReceiverPerson');
        const handoverNotes = getElementValue('wizardHandoverNotes');
        
        // Update confirmation data
        updateElementText('confirmOrderCode', getElementValue('wizardOrderCode'));
        updateElementText('confirmProductCode', getElementValue('wizardProductCode'));
        updateElementText('confirmProductName', getElementValue('wizardProductName'));
        updateElementText('confirmPaperType', getElementValue('wizardPaperType'));
        updateElementText('confirmPaperWeight', getElementValue('wizardPaperWeight'));
        updateElementText('confirmQuantity', getElementValue('wizardQuantity'));
        updateElementText('confirmGoodQty', goodQty.toLocaleString());
        updateElementText('confirmNgQty', ngQty.toLocaleString());
        updateElementText('confirmProgress', progress + '%');
        updateElementText('confirmMachine', machine);
        updateElementText('confirmWorker', worker || 'Ch∆∞a nh·∫≠p');
        updateElementText('confirmShift', shift || 'Ca 1');
        updateElementText('confirmHandoverQty', handoverQty.toLocaleString());
        updateElementText('confirmHandoverPerson', handoverPerson || 'Ch∆∞a nh·∫≠p');
        updateElementText('confirmReceiverPerson', receiverPerson || 'Ch∆∞a nh·∫≠p');
        updateElementText('confirmHandoverNotes', handoverNotes || 'Kh√¥ng c√≥');
    }



    /**
     * =================================================================
     * UTILITY FUNCTIONS - C√ÅC H√ÄM TI·ªÜN √çCH
     * =================================================================
     */

    // Hi·ªÉn th·ªã loading
    function showLoading(message = 'ƒêang t·∫£i...') {
        const loading = document.getElementById('loadingOverlay');
        if (loading) {
            loading.style.display = 'flex';
            const loadingText = loading.querySelector('.loading-text');
            if (loadingText) loadingText.textContent = message;
        }
    }

    // ·∫®n loading  
    function hideLoading() {
        const loading = document.getElementById('loadingOverlay');
        if (loading) loading.style.display = 'none';
    }

    // Hi·ªÉn th·ªã th√¥ng b√°o
    function showNotification(message, type = 'success') {
        // T·∫°o toast notification ƒë∆°n gi·∫£n
        const toast = document.createElement('div');
        toast.className = `alert alert-${type === 'error' ? 'danger' : type === 'warning' ? 'warning' : 'success'} position-fixed`;
        toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px; animation: fadeIn 0.3s ease;';
        toast.innerHTML = `
            <div class="d-flex align-items-center">
                <i class="bi bi-${type === 'error' ? 'exclamation-triangle' : type === 'warning' ? 'exclamation-triangle' : 'check-circle'} me-2"></i>
                <span>${message}</span>
                <button type="button" class="btn-close ms-auto" onclick="this.parentElement.parentElement.remove()"></button>
            </div>
        `;
        document.body.appendChild(toast);
        
        // T·ª± ƒë·ªông x√≥a sau 5 gi√¢y
        setTimeout(() => {
            if (toast.parentElement) {
                toast.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }
        }, 5000);
    }

    // Format s·ªë theo ƒë·ªãnh d·∫°ng Vi·ªát Nam
    function formatNumber(num) {
        if (!num && num !== 0) return '';
        return new Intl.NumberFormat('vi-VN').format(num);
    }

    // Format ng√†y
    function formatDate(date, format = 'dd/mm/yyyy') {
        if (!date) return '';
        const d = new Date(date);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        
        return format
            .replace('dd', day)
            .replace('mm', month)
            .replace('yyyy', year);
    }

    // C·∫≠p nh·∫≠t text c·ªßa element
    function updateElementText(elementId, text) {
        const element = document.getElementById(elementId);
        if (element) element.textContent = text;
    }

    // Set gi√° tr·ªã cho element
    function setElementValue(elementId, value) {
        const element = document.getElementById(elementId);
        if (element) {
            if (element.type === 'checkbox') {
                element.checked = value;
            } else {
                element.value = value;
            }
        }
    }

    // L·∫•y gi√° tr·ªã t·ª´ element
    function getElementValue(elementId) {
        const element = document.getElementById(elementId);
        if (!element) return '';
        
        if (element.type === 'checkbox') {
            return element.checked;
        } else {
            return element.value;
        }
    }

    // C·∫Øt ng·∫Øn text
    function truncateText(text, maxLength) {
        if (!text) return '';
        return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
    }

    // Chuy·ªÉn ƒë·ªïi status th√†nh text
    function getStatusText(status) {
        const statusMap = {
            'waiting': 'Ch·ªù x·ª≠ l√Ω',
            'in_progress': 'ƒêang x·ª≠ l√Ω', 
            'completed': 'Ho√†n th√†nh',
            'paused': 'T·∫°m d·ª´ng',
            'handed_over': 'ƒê√£ b√†n giao'
        };
        return statusMap[status] || 'Kh√¥ng x√°c ƒë·ªãnh';
    }

    /**
     * =================================================================
     * SIDEBAR TOGGLE - ƒêI·ªÄU KHI·ªÇN SIDEBAR
     * =================================================================
     * ƒê√£ ƒë∆∞·ª£c chuy·ªÉn sang sidebar-generator.js
     */

    /**
     * =================================================================
     * DETAILS PANEL - PANEL CHI TI·∫æT
     * =================================================================
     */

    function showOrderDetails(orderId) {
        // T√¨m order trong c·∫£ ordersData v√† originalOrdersData
        let order = ordersData.find(o => o.id == orderId); // S·ª≠ d·ª•ng == ƒë·ªÉ so s√°nh loose
        
        if (!order) {
            order = originalOrdersData.find(o => o.id == orderId);
        }
        
        if (!order) {

            
            // Th·ª≠ t√¨m b·∫±ng production_order n·∫øu orderId c√≥ th·ªÉ l√† production_order
            const orderByProductionOrder = ordersData.find(o => o.production_order == orderId);
            if (orderByProductionOrder) {
                order = orderByProductionOrder;
            } else {
                const orderByProductionOrderOriginal = originalOrdersData.find(o => o.production_order == orderId);
                if (orderByProductionOrderOriginal) {
                    order = orderByProductionOrderOriginal;
                } else {
                    return;
                }
            }
        }

        // Update current editing order
        currentEditingOrder = order;
        
        // Ki·ªÉm tra shift hi·ªán t·∫°i ƒë·ªÉ l·∫•y start_time t·ª´ b·∫£ng production_orders_shift
        checkCurrentShiftStatus();
        
        // Chi ti·∫øt log ƒë·ªÉ debug th√¥ng tin th·ªùi gian

        // C·∫≠p nh·∫≠t m√£ l·ªánh trong ti√™u ƒë·ªÅ
        const orderCodeBadge = document.getElementById('detailOrderCode');
        if (orderCodeBadge) {
            orderCodeBadge.textContent = order.production_order || `#${order.id}`;
        }

        // Add logging to debug start time

        // Remove previous selection
        const previousSelected = document.querySelector('.table tbody tr.selected');
        if (previousSelected) {
            previousSelected.classList.remove('selected');
        }

        // Add selection to current row
        const currentRow = document.querySelector(`[data-order-id="${orderId}"]`);
        if (currentRow) {
            currentRow.classList.add('selected');
        }

        // Show details panel
        const detailsPanel = document.getElementById('detailsPanel');
        const contentArea = document.querySelector('.content-area');
        
        detailsPanel.classList.add('show');
        contentArea.classList.add('details-open');

        // Generate dynamic HTML content for the sidebar
        detailsPanel.innerHTML = generateSidebarHTML(order);
        
        // Initialize multi-select for workers
        initializeWorkerMultiSelect(order);

        // Active tab "S·ªë l∆∞·ª£ng" n·∫øu ƒë√£ c√≥ th·ªùi gian b·∫Øt ƒë·∫ßu
        if (getOrderField(order, 'start_time')) {
            setTimeout(() => {
                const quantityTab = document.querySelector('.details-panel .tab-btn[onclick*="quantity"]');
                if (quantityTab) {
                    // Remove active class from all tabs
                    document.querySelectorAll('.details-panel .tab-btn').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.details-panel .tab-panel').forEach(panel => panel.classList.remove('active'));
                    
                    // Add active class to quantity tab
                    quantityTab.classList.add('active');
                    const quantityPanel = document.getElementById('quantity-panel');
                    if (quantityPanel) {
                        quantityPanel.classList.add('active');
                    }
                }
            }, 100);
        }

        // B·∫Øt ƒë·∫ßu timer n·∫øu ƒë√£ c√≥ th·ªùi gian b·∫Øt ƒë·∫ßu v√† ch∆∞a k·∫øt th√∫c
        if (window.currentShiftStartTime && !getOrderField(order, 'end_time')) {
            setTimeout(() => {
                startProductionTimer();
            }, 100);
        } else if (window.currentShiftStartTime && getOrderField(order, 'end_time')) {
            // N·∫øu ƒë√£ k·∫øt th√∫c, hi·ªÉn th·ªã th·ªùi gian c·ªë ƒë·ªãnh
            setTimeout(() => {
                const statusTimeElement = document.getElementById('statusTime');
                const runningTimeInfoElement = document.getElementById('runningTimeInfo');
                
                if (statusTimeElement) {
                    const fixedTime = calculateWorkTime(window.currentShiftStartTime, getOrderField(order, 'end_time'));
                    statusTimeElement.textContent = `Th·ªùi gian: ${fixedTime}`;
                }
                
                // Th·ªùi gian ch·∫°y trong tab th√¥ng tin ƒë√£ ƒë∆∞·ª£c hi·ªÉn th·ªã ƒë√∫ng t·ª´ HTML generation
                // Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t v√¨ ƒë√£ c√≥ gi√° tr·ªã c·ªë ƒë·ªãnh t·ª´ calculateWorkTime
            }, 100);
        }

        // Th√™m event listener ƒë·ªÉ t·ª± ƒë·ªông c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng chuy·ªÉn giao
        setTimeout(() => {
            const goodQtyInput = document.getElementById('goodQty');
            const handoverQtyInput = document.getElementById('handoverQty');
            
            if (goodQtyInput && handoverQtyInput) {
                goodQtyInput.addEventListener('input', function() {
                    const goodQty = parseInt(this.value) || 0;
                    handoverQtyInput.value = goodQty;
                    updateTotalQuantityDisplay(); // C·∫≠p nh·∫≠t validation real-time
                });
            }
            
                    // Th√™m event listeners cho validation real-time
        const quantityInputs = ['goodQty', 'ngQty', 'ngStartEndQty', 'returnQty'];
        quantityInputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                input.addEventListener('input', updateTotalQuantityDisplay);
                input.addEventListener('blur', updateTotalQuantityDisplay);
                input.addEventListener('input', updateStatisticsDisplay);
                input.addEventListener('blur', updateStatisticsDisplay);
            }
        });
        
        // Kh·ªüi t·∫°o hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng v√† th·ªëng k√™
        updateTotalQuantityDisplay();
        updateStatisticsDisplay();
        
        // T·ª± ƒë·ªông ƒë·ªÅ xu·∫•t ca l√†m vi·ªác hi·ªán t·∫°i
        const shiftSelect = document.getElementById('shift');
        if (shiftSelect) {
            const currentShift = getCurrentShift();
            shiftSelect.value = currentShift;
        }
        
        // Reset form ƒë·ªÉ nh·∫≠p d·ªØ li·ªáu m·ªõi (kh√¥ng load t·ª´ database)
        // resetProductionForm();
        
        // Load s·ªë l∆∞·ª£ng c√≤n l·∫°i
        loadRemainingQuantity();
        
        // Ki·ªÉm tra tr·∫°ng th√°i shift hi·ªán t·∫°i
        checkCurrentShiftStatus();
        }, 150);
    }

    /**
     * T√≠nh s·ªë l∆∞·ª£ng c·∫ßn s·∫£n xu·∫•t c√≤n l·∫°i
     * = S·ªë l∆∞·ª£ng t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc - (T·ªïng s·ªë l∆∞·ª£ng b√†n giao + NG c·ªßa c√°c ca ƒë√£ l√†m)
     */
    async function getRemainingQuantity(order) {
        try {
            // L·∫•y s·ªë l∆∞·ª£ng t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // L·∫•y t·ªïng s·ªë l∆∞·ª£ng b√†n giao v√† NG c·ªßa c√°c ca ƒë√£ l√†m
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            let totalHandoverQuantity = 0;
            let totalNgQuantity = 0;
            if (shiftsData.shifts && Array.isArray(shiftsData.shifts)) {
                shiftsData.shifts.forEach(shift => {
                    totalHandoverQuantity += (parseInt(shift.handover_quantity) || 0);
                    totalNgQuantity += (parseInt(shift.ng_quantity) || 0);
                });
            }
            
            // S·ªë l∆∞·ª£ng c√≤n l·∫°i = Input t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc - (B√†n giao + NG c·ªßa c√°c ca tr∆∞·ªõc)
            const remainingQuantity = Math.max(0, inputQuantity - totalHandoverQuantity - totalNgQuantity);
            console.log('üìä S·ªë l∆∞·ª£ng c√≤n l·∫°i:', {
                inputQuantity,
                totalHandoverQuantity,
                totalNgQuantity,
                remainingQuantity
            });
            
            return remainingQuantity;
        } catch (error) {
            console.error('‚ùå L·ªói t√≠nh s·ªë l∆∞·ª£ng c√≤n l·∫°i:', error);
            return getInputQuantityFromPreviousStage(order); // Fallback
        }
    }

    /**
     * Generate dynamic sidebar HTML for the order
     */
    function generateSidebarHTML(order) {
        const nextStage = order.next_stage;
        const nextStageName = nextStage ? getStageDisplayName(nextStage) : 'HO√ÄN TH√ÄNH';
        
        // Get status info
        let statusBadgeStyle = '';
        let statusText = '';
        
        if (getOrderField(order, 'status') === 'in_progress') {
            statusBadgeStyle = 'background: linear-gradient(135deg, var(--primary-green), #20c997);';
            statusText = 'ƒêang s·∫£n xu·∫•t';
        } else if (getOrderField(order, 'status') === 'completed') {
            statusBadgeStyle = 'background: linear-gradient(135deg, var(--primary-blue), #0dcaf0);';
            statusText = 'Ho√†n th√†nh';
        } else if (getOrderField(order, 'status') === 'handed_over') {
            statusBadgeStyle = 'background: linear-gradient(135deg, var(--primary-orange), #fd7e14);';
            statusText = 'ƒê√£ b√†n giao';
        } else {
            statusBadgeStyle = 'background: linear-gradient(135deg, #6c757d, #adb5bd);';
            statusText = 'Ch∆∞a b·∫Øt ƒë·∫ßu';
        }

        // Calculate statistics - kh√¥ng s·ª≠ d·ª•ng d·ªØ li·ªáu t·ª´ database
        const totalProduced = 0; // S·∫Ω ƒë∆∞·ª£c t√≠nh t·ª´ form nh·∫≠p li·ªáu
        const inputQuantity = getInputQuantityFromPreviousStage(order);
        const efficiency = 0; // S·∫Ω ƒë∆∞·ª£c t√≠nh t·ª´ form nh·∫≠p li·ªáu
        const ngRate = 0; // S·∫Ω ƒë∆∞·ª£c t√≠nh t·ª´ form nh·∫≠p li·ªáu

        return `
            <div class="sidebar-header">
                <h5><i class="bi bi-clipboard-data me-2"></i>B√°o c√°o l·ªánh: <strong>${order.production_order || `#${order.id}`}</strong></h5>
                <button type="button" class="detail-close" onclick="closeDetailsPanel()">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>

            <div class="sidebar-content">
                <!-- Tab Navigation -->
                <div class="tab-navigation">
                    <button class="tab-btn active" onclick="switchTab('info')">
                        <div class="tab-icon"><i class="bi bi-person-fill"></i></div>
                        <div>Th√¥ng tin</div>
                    </button>
                    <button class="tab-btn" onclick="switchTab('quantity')">
                        <div class="tab-icon"><i class="bi bi-calculator-fill"></i></div>
                        <div>S·ªë l∆∞·ª£ng</div>
                    </button>
      
                    <button class="tab-btn" onclick="switchTab('shifts')">
                        <div class="tab-icon"><i class="bi bi-clock-history"></i></div>
                        <div>Th√¥ng tin ca</div>
                    </button>
                    
                    <button class="tab-btn" onclick="switchTab('notes')">
                        <div class="tab-icon"><i class="bi bi-chat-text-fill"></i></div>
                        <div>Ghi ch√∫</div>
                    </button>
                </div>

                <!-- Tab Content -->
                <div class="tab-content">
                    <!-- Info Tab -->
                    <div id="info-panel" class="tab-panel active">
                        <div class="form-group">
                            <div class="multi-select-container">
                                <div class="multi-select-input" id="workerMultiSelect">
                                    <div class="selected-items" id="selectedWorkers"></div>
                                    <input type="text" class="multi-select-search" id="workerSearch" placeholder="T√¨m ki·∫øm th·ª£...">
                                </div>
                                <div class="multi-select-dropdown" id="workerDropdown" style="display: none;">
                                    <div class="dropdown-items" id="workerOptions">
                                        <!-- Options will be populated by JavaScript -->
                                    </div>
                                </div>
                            </div>
                            <label class="form-label">
                                <i class="bi bi-person-badge"></i>
                                T√™n th·ª£ ph·ª• tr√°ch
                            </label>
                            <input type="hidden" id="worker" value="${getOrderField(order, 'worker_name') || ''}">
                        </div>

                        <div class="form-group">
                            <select class="form-control-custom" id="shift">
                                <option value="">Ch·ªçn ca l√†m vi·ªác</option>
                                <option value="Ca 1" ${getOrderField(order, 'shift') === 'Ca 1' ? 'selected' : ''}>Ca 1 (6:00 - 14:00)</option>
                                <option value="Ca 2" ${getOrderField(order, 'shift') === 'Ca 2' ? 'selected' : ''}>Ca 2 (14:00 - 22:00)</option>
                                <option value="Ca 3" ${getOrderField(order, 'shift') === 'Ca 3' ? 'selected' : ''}>Ca 3 (22:00 - 6:00)</option>
                                <option value="K√≠p 1" ${getOrderField(order, 'shift') === 'K√≠p 1' ? 'selected' : ''}>K√≠p 1 (6:00 - 18:00)</option>
                                <option value="K√≠p 2" ${getOrderField(order, 'shift') === 'K√≠p 2' ? 'selected' : ''}>K√≠p 2 (18:00 - 6:00)</option>
                            </select>
                            <label class="form-label">
                                <i class="bi bi-clock"></i>
                                Ca l√†m vi·ªác
                            </label>
                        </div>

                        <div style="display: none;" class="form-group">
                            <select class="form-control-custom" id="machine">
                                <option value="">Ch·ªçn m√°y s·∫£n xu·∫•t</option>
                                ${getAvailableStageMachines().map(machineName => {
                                    const isSelected = getStageMachineFromAssigned(order.assigned_machine) === machineName;
                                    return `<option value="${machineName}" ${isSelected ? 'selected' : ''}>${machineName}</option>`;
                                }).join('')}
                            </select>
                            <label class="form-label">
                                <i class="bi bi-gear-fill"></i>
                                M√°y s·∫£n xu·∫•t
                            </label>
                        </div>

                        <div class="info-row">
                            <span class="info-label">Th·ªùi gian b·∫Øt ƒë·∫ßu</span>
                            <span class="info-value" id="startTimeInfo">${window.currentShiftStartTime ? formatDateTime(window.currentShiftStartTime) : '--'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Th·ªùi gian k·∫øt th√∫c</span>
                            <span class="info-value" id="endTimeInfo">${getOrderField(order, 'end_time') ? formatDateTime(getOrderField(order, 'end_time')) : '--'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Th·ªùi gian ch·∫°y</span>
                            <span class="info-value" id="runningTimeInfo">${window.currentShiftStartTime ?
                                (getOrderField(order, 'end_time') ? calculateWorkTime(window.currentShiftStartTime, getOrderField(order, 'end_time')) : 'ƒêang t√≠nh...') : '--'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Tr·∫°ng th√°i m√°y</span>
                            <span class="info-value">${getOrderField(order, 'status') === 'in_progress' ? 'Ho·∫°t ƒë·ªông t·ªët' : 'Ch·ªù'}</span>
                        </div>
                    </div>

                    <!-- Quantity Tab -->
                    <div id="quantity-panel" class="tab-panel">
                        <div class="quantity-grid mb-3">
                            <div class="quantity-card success">
                                <div class="quantity-label">S·ªë l∆∞·ª£ng OK</div>
                                <input type="number" class="quantity-input" id="goodQty" value="0">
                            </div>
                            <div class="quantity-card danger">
                                <div class="quantity-label">S·ªë l∆∞·ª£ng NG</div>
                                <input type="number" class="quantity-input" id="ngQty" value="0">
                            </div>
                        </div>

                        <div class="quantity-grid mb-3">
                            <div class="quantity-card ">
                                <div class="quantity-label">NG ƒë·∫ßu/cu·ªëi</div>
                                <input type="number" class="quantity-input" id="ngStartEndQty" value="0">
                            </div>
                            <div class="quantity-card ">
                                <div class="quantity-label">S·ªë l∆∞·ª£ng tr·∫£</div>
                                <input type="number" class="quantity-input" id="returnQty" value="0">
                            </div>
                        </div>


                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-arrow-right-circle"></i>
                                S·ªë l∆∞·ª£ng chuy·ªÉn giao
                            </label>
                            <input type="number" class="form-control-custom" id="handoverQty" value="0" style="font-size: 1.1rem; font-weight: 600; color: var(--primary-blue);">
                        </div>

                        <div class="info-row" style="background: linear-gradient(135deg, #e3f2fd, #e3f2fd); border-radius: 8px; padding: 12px; margin: 10px 0; ">
                            <span class="info-label" style="font-weight: 600; color: #1976d2;">üì• S·ªë l∆∞·ª£ng c·∫ßn s·∫£n xu·∫•t</span>
                            <span class="info-value" id="remainingQuantityDisplay" style="font-weight: 700; font-size: 1.1rem; color: #1565c0;">ƒêang t√≠nh...</span>
                        </div>
                        <div class="info-row" style="background: linear-gradient(135deg, #fff3cd, #fff3cd); border-radius: 8px; padding: 12px; margin: 10px 0; ">
                            <span class="info-label" style="font-weight: 600; color: #856404;">üìä T·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p</span>
                            <span class="info-value" id="totalQuantityDisplay" style="font-weight: 700; font-size: 1.1rem; color: #856404;">0 / 0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">T·ªïng s·∫£n xu·∫•t</span>
                            <span class="info-value" id="totalProducedValue">0 s·∫£n ph·∫©m</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Hi·ªáu su·∫•t</span>
                            <span class="info-value" id="efficiencyValue">0%</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">T·ª∑ l·ªá NG</span>
                            <span class="info-value" id="ngRateValue">0%</span>
                        </div>
                    </div>

                 

                    

                    <!-- Shifts Tab -->
                    <div id="shifts-panel" class="tab-panel">
                
                            <div class="shifts-header">
                                <h6><i class="bi bi-clock-history me-2"></i>L·ªãch s·ª≠ ca l√†m vi·ªác</h6>
                                <div class="shifts-loading" id="shiftsLoading" style="display: none;">
                                    <div class="spinner-border spinner-border-sm" role="status">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                    <span class="ms-2">ƒêang t·∫£i...</span>
                                </div>
                            </div>
                            
                            <div class="shifts-list" id="shiftsList">
                                <!-- Shifts will be loaded here -->
                            </div>
                        </div>
                  
                </div>

                <!-- Notes Tab -->
                    <div id="notes-panel" class="tab-panel">
                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-journal-text"></i>
                                Ghi ch√∫ s·∫£n xu·∫•t
                            </label>
                            <div class="note-area">
                                <textarea class="note-textarea" id="note" placeholder="Nh·∫≠p ghi ch√∫ v·ªÅ qu√° tr√¨nh s·∫£n xu·∫•t...">${getOrderField(order, 'note') || ''}</textarea>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-lightbulb"></i>
                                ƒê·ªÅ xu·∫•t c·∫£i ti·∫øn
                            </label>
                            <div class="note-area">
                                <textarea class="note-textarea" id="improvement" placeholder="Nh·∫≠p ƒë·ªÅ xu·∫•t c·∫£i ti·∫øn...">${order.improvement_suggestions || ''}</textarea>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-tag"></i>
                                Tags
                            </label>
                            <input type="text" class="form-control-custom" id="tags" value="${order.tags || ''}" placeholder="Nh·∫≠p c√°c tag, c√°ch nhau b·ªüi d·∫•u ph·∫©y">
                        </div>
                    </div>

                <!-- Production Controls -->
                <div class="production-controls">
                    <!-- Production Status -->
                    <div class="production-status ${getOrderField(order, 'status') === 'in_progress' ? 'running' : 'stopped'}" id="productionStatus">
                        <div class="status-text">
                            <i class="bi bi-${getOrderField(order, 'status') === 'in_progress' ? 'play-circle-fill text-success' : 'stop-circle-fill text-danger'}"></i>
                            <span id="productionStatusText">${statusText}</span>
                        </div>
                        <div class="status-time" id="statusTime">Th·ªùi gian: </div>
                    </div>

                    <!-- Control Buttons -->
                    <div class="control-row">
                        <button class="btn-custom btn-success-custom" id="startBtn" onclick="startProduction()">
                            <i class="bi bi-play-fill"></i>
                            B·∫Øt ƒë·∫ßu
                        </button>
         
                        <button class="btn-custom btn-info-custom" id="handoverShiftBtn" onclick="startHandoverConfirmationFlow()" ${getOrderField(order, 'status') === 'not_started' || getOrderField(order, 'status') === 'handed_over' ? 'disabled' : ''} style="${getOrderField(order, 'start_time') && !getOrderField(order, 'end_time') ? 'display: flex;' : 'display: none;'}">
                            <i class="bi bi-clock-history"></i>
                            B√†n giao ca
                        </button>

                          <button class="btn-custom btn-secondary-custom" id="resetBtn" onclick="resetProduction()" style="${getOrderField(order, 'start_time') && getOrderField(order, 'status') === 'in_progress' ? 'display: flex;    max-width: 100px;' : 'display: none;'}">
                            <i class="bi bi-arrow-clockwise"></i>
                            H·ªßy l√†m
                        </button>
                    </div>

          
                </div>
            </div>
        `;
    }

    // Helper functions for form manipulation
    function setElementValue(id, value) {
        const element = document.getElementById(id);
        if (element) {
            element.value = value;
        }
    }

    function getElementValue(id) {
        const element = document.getElementById(id);
        if (!element) return '';
        
        // X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho select elements
        if (element.tagName === 'SELECT') {
            const selectedOption = element.options[element.selectedIndex];
            return selectedOption ? selectedOption.value : '';
        }
        
        // X·ª≠ l√Ω cho input, textarea v√† c√°c element kh√°c
        return element.value || '';
    }

    /**
     * X√°c ƒë·ªãnh ca l√†m vi·ªác theo th·ªùi gian hi·ªán t·∫°i
     */
    function getCurrentShift() {
        const now = new Date();
        const currentHour = now.getHours();
        
        // K√≠p 1: t·ª´ 6:00 - 18:00 (6:00 ƒë·∫øn 17:59)
        if (currentHour >= 6 && currentHour < 18) {
            return 'K√≠p 1';
        }
        // K√≠p 2: t·ª´ 18:00 - 6:00 (18:00 ƒë·∫øn 5:59)
        else {
            return 'K√≠p 2';
        }
    }

    /**
     * Validate t·ªïng s·ªë l∆∞·ª£ng kh√¥ng v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng ƒë·∫ßu v√†o
     */
    function validateTotalQuantity(order, goodQty, ngQty, ngStartEndQty = 0, returnQty = 0) {
        // L·∫•y s·ªë l∆∞·ª£ng ƒë·∫ßu v√†o t·ª´ stage tr∆∞·ªõc ho·∫∑c sheet_count
        const inputQuantity = getInputQuantityFromPreviousStage(order);
        
        // T√≠nh t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
        const totalEntered = goodQty + ngQty + ngStartEndQty + returnQty;
        
        // Ki·ªÉm tra t·ªïng s·ªë l∆∞·ª£ng kh√¥ng v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng ƒë·∫ßu v√†o
        if (totalEntered > inputQuantity) {
            showNotification(`‚ö†Ô∏è T·ªïng s·ªë l∆∞·ª£ng (${totalEntered}) v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng ƒë·∫ßu v√†o (${inputQuantity})!\n\nChi ti·∫øt:\n‚Ä¢ OK: ${goodQty}\n‚Ä¢ NG: ${ngQty}\n‚Ä¢ NG ƒë·∫ßu/cu·ªëi: ${ngStartEndQty}\n‚Ä¢ Tr·∫£: ${returnQty}\n‚Ä¢ T·ªïng: ${totalEntered}\n‚Ä¢ ƒê·∫ßu v√†o: ${inputQuantity}`, 'error');
            return false;
        }
        
        return true;
    }

    /**
     * C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng v√† validation real-time
     */
    function updateTotalQuantityDisplay() {
        if (!currentEditingOrder) return;
        
        const goodQty = parseInt(getElementValue('goodQty')) || 0;
        const ngQty = parseInt(getElementValue('ngQty')) || 0;
        const ngStartEndQty = parseInt(getElementValue('ngStartEndQty')) || 0;
        const returnQty = parseInt(getElementValue('returnQty')) || 0;
        
        const totalEntered = goodQty + ngQty + ngStartEndQty + returnQty;
        
        // L·∫•y s·ªë l∆∞·ª£ng c√≤n l·∫°i t·ª´ element hi·ªÉn th·ªã
        const remainingQuantityDisplay = document.getElementById('remainingQuantityDisplay');
        let remainingQuantity = 0;
        
        if (remainingQuantityDisplay && remainingQuantityDisplay.textContent) {
            const text = remainingQuantityDisplay.textContent;
            const match = text.match(/(\d+)/);
            if (match) {
                remainingQuantity = parseInt(match[1]);
            }
        }
        
        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng
        const totalDisplay = document.getElementById('totalQuantityDisplay');
        if (totalDisplay) {
            totalDisplay.textContent = `${totalEntered} / ${remainingQuantity}`;
            
            // Thay ƒë·ªïi m√†u s·∫Øc d·ª±a tr√™n validation
            if (totalEntered > remainingQuantity) {
                totalDisplay.style.color = '#dc3545'; // ƒê·ªè
                totalDisplay.style.fontWeight = 'bold';
            } else if (totalEntered === remainingQuantity) {
                totalDisplay.style.color = '#28a745'; // Xanh l√°
                totalDisplay.style.fontWeight = 'bold';
            } else {
                totalDisplay.style.color = '#6c757d'; // X√°m
                totalDisplay.style.fontWeight = 'normal';
            }
        }
        
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i c√°c input field
        const inputs = ['goodQty', 'ngQty', 'ngStartEndQty', 'returnQty'];
        inputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                if (totalEntered > remainingQuantity) {
                    input.style.color = '#ff3030';
                    // input.style.backgroundColor = '#fff5f5';
                } else {
                    input.style.color = '';
                    // input.style.backgroundColor = '';
                }
            }
        });
    }

    /**
     * L·∫•y d·ªØ li·ªáu t·ª´ form trong sidebar
     * @returns {object} - D·ªØ li·ªáu form ƒë√£ ƒë∆∞·ª£c validate
     */
    function getFormData() {
        const formData = {
            worker: getElementValue('worker') || '',
            shift: getElementValue('shift') || '',
            machine: getElementValue('machine') || '',
            goodQty: parseInt(getElementValue('goodQty')) || 0,
            ngQty: parseInt(getElementValue('ngQty')) || 0,
            ngStartEndQty: parseInt(getElementValue('ngStartEndQty')) || 0,
            returnQty: parseInt(getElementValue('returnQty')) || 0,
            handoverQty: parseInt(getElementValue('handoverQty')) || 0,
            qualityRating: getElementValue('qualityRating') || '',
            qualityCheck: getElementValue('qualityCheck') || '',
            note: getElementValue('note') || '',
            improvement: getElementValue('improvement') || '',
            tags: getElementValue('tags') || ''
        };

        return formData;
    }

    function closeDetailsPanel() {
        const detailsPanel = document.getElementById('detailsPanel');
        const contentArea = document.querySelector('.content-area');
        
        detailsPanel.classList.remove('show');
        contentArea.classList.remove('details-open');
        
        // D·ª´ng timer khi ƒë√≥ng panel
        stopProductionTimer();
        
        // Remove selection from table row
        const selectedRow = document.querySelector('.table tbody tr.selected');
        if (selectedRow) {
            selectedRow.classList.remove('selected');
        }
    }




    function getStatusBadgeClass(status) {
        const statusMap = {
            'waiting': 'bg-warning',
            'in_progress': 'bg-primary',
            'completed': 'bg-success',
            'paused': 'bg-secondary',
            'handed_over': 'bg-info'
        };
        return statusMap[status] || 'bg-secondary';
    }

    function formatDate(dateString) {
        if (!dateString) return 'N/A';
        try {
            const date = new Date(dateString);
            return date.toLocaleDateString('vi-VN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        } catch (e) {
            return 'N/A';
        }
    }

    // Production control functions
    async function startProduction() {

        const order = currentEditingOrder;
        if (!order) {
            showNotification('L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c l·ªánh s·∫£n xu·∫•t', 'error');
            return;
        }
        
        try {
    
            showLoading('ƒêang b·∫Øt ƒë·∫ßu ca l√†m vi·ªác...');
            
            // L·∫•y th√¥ng tin t·ª´ form trong sidebar
            const formData = getFormData();
            
            // Ki·ªÉm tra ƒë√£ ch·ªçn ca l√†m vi·ªác ch∆∞a
            if (!formData.shift) {
                showNotification('‚ö†Ô∏è Vui l√≤ng ch·ªçn ca l√†m vi·ªác', 'warning');
                return;
            }
            
            // L·∫•y m√°y ƒë∆∞·ª£c g√°n th·ª±c t·∫ø cho l·ªánh n√†y
            const assignedMachine = getOrderMachine(order);
            if (!assignedMachine) {
                showNotification(`‚ö†Ô∏è L·ªánh n√†y kh√¥ng ƒë∆∞·ª£c g√°n cho m√°y ${STAGE_CONFIG.NAME} n√†o`, 'warning');
                return;
            }
            
            // Validation c∆° b·∫£n
            if (!formData.worker || !formData.worker.trim()) {
                showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n th·ª£ ph·ª• tr√°ch trong ph·∫ßn "Th√¥ng tin s·∫£n xu·∫•t"', 'warning');
                return;
            }
            
            // L·∫•y s·ªë ca ti·∫øp theo
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            const nextShiftNumber = shiftsData.shifts && shiftsData.shifts.length > 0
                ? Math.max(...shiftsData.shifts.map(s => s.shift_number)) + 1
                : 1;
            
            const now = new Date();
            const shiftDate = now.toISOString().split('T')[0];
            
            const mysqlDateTime = formatDateTimeForMySQL(now);
            
            // T·∫°o ca l√†m vi·ªác m·ªõi v·ªõi status 'in_progress'
            const createShiftData = {
                production_order_id: order.id,
                production_order: order.production_order,
                stage: STAGE_CONFIG.KEY,
                shift_number: nextShiftNumber,
                shift_name: formData.shift,
                shift_date: shiftDate,
                worker_name: formData.worker,
                machine_name: assignedMachine,
                start_time: mysqlDateTime,
                end_time: null,
                work_duration_minutes: 0,
                good_quantity: 0,
                ng_quantity: 0,
                ng_start_end_quantity: 0,
                return_quantity: 0,
                output_quantity: 0,
                handover_quantity: 0,
                efficiency_percent: 0,
                quality_score: 0,
                handover_person: '',
                receiver_person: '',
                ng_reason: '',
                quality_notes: '',
                is_overtime: 0,
                overtime_hours: 0,
                is_night_shift: 0,
                break_duration_minutes: 0,
                status: 'in_progress',
                notes: formData.note || `B·∫Øt ƒë·∫ßu ca l√†m vi·ªác ${formData.shift}`
            };
            
            // T·∫°o shift m·ªõi
            const response = await fetch(`${API_BASE_URL}/data/production_orders_shift`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(createShiftData)
            });
            
            const result = await response.json();
            
            if (response.ok) {
    
                showNotification('‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu ca l√†m vi·ªác th√†nh c√¥ng!', 'success');
                
                // L∆∞u ID v√† th·ªùi gian b·∫Øt ƒë·∫ßu c·ªßa shift hi·ªán t·∫°i ƒë·ªÉ s·ª≠ d·ª•ng khi b√†n giao
                window.currentShiftId = result.shift_id;
                window.currentShiftStartTime = mysqlDateTime;

                
                // C·∫≠p nh·∫≠t tr·∫°ng th√°i production_orders v·ªõi stage_status = 'in_progress'
                try {
                    const orderUpdateData = {
                        status: 'in_progress',
                        [`${STAGE_CONFIG.KEY}_status`]: 'in_progress',
                        [`${STAGE_CONFIG.KEY}_worker_name`]: formData.worker,
                        [`${STAGE_CONFIG.KEY}_machine_name`]: assignedMachine,
                        [`${STAGE_CONFIG.KEY}_start_time`]: mysqlDateTime
                    };
                    

                    
                    const updateOrderResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(orderUpdateData)
                    });
                    
                    if (updateOrderResponse.ok) {
                        // console.log('‚úÖ Production order status updated successfully');
                    } else {
                        const updateError = await updateOrderResponse.json();
                        console.warn('‚ö†Ô∏è Failed to update production order status:', updateError);
                    }
                } catch (updateError) {
                    console.warn('‚ö†Ô∏è Error updating production order status:', updateError);
                    // Kh√¥ng throw error v√¨ ƒë√¢y kh√¥ng ph·∫£i l·ªói nghi√™m tr·ªçng
                }
                
                // C·∫≠p nh·∫≠t UI ƒë·ªÉ hi·ªÉn th·ªã th·ªùi gian b·∫Øt ƒë·∫ßu
                const startTimeElement = document.querySelector('.detail-section .alert .row .col-6:first-child span');
                if (startTimeElement) {
                    startTimeElement.textContent = formatDateTime(new Date(mysqlDateTime));
                    startTimeElement.classList.add('text-primary');
                }
                
                // C·∫≠p nh·∫≠t th·ªùi gian b·∫Øt ƒë·∫ßu trong sidebar
                const startTimeInfo = document.getElementById('startTimeInfo');
                if (startTimeInfo) {
                    // Hi·ªÉn th·ªã th·ªùi gian ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng
                    startTimeInfo.textContent = formatDateTime(mysqlDateTime);

                }
                
                // Hi·ªÉn th·ªã ƒë·ªìng h·ªì th·ªùi gian
                const timeDisplayContainer = document.querySelector('.detail-section .alert');
                if (timeDisplayContainer) {
                    // Ki·ªÉm tra xem ƒë√£ c√≥ ph·∫ßn hi·ªÉn th·ªã th·ªùi gian ch·∫°y ch∆∞a
                    let timerSection = timeDisplayContainer.querySelector('.text-center');
                    
                    if (!timerSection) {
                        // T·∫°o ph·∫ßn hi·ªÉn th·ªã th·ªùi gian ch·∫°y n·∫øu ch∆∞a c√≥
                        const timerHtml = `
                            <hr class="my-2">
                            <div class="text-center">
                                <strong>Th·ªùi gian ƒëang ch·∫°y:</strong><br>
                                <span class="text-warning" id="productionRunningTime">ƒêang t√≠nh...</span>
                            </div>
                        `;
                        timeDisplayContainer.insertAdjacentHTML('beforeend', timerHtml);
                    }
                    
                    // B·∫Øt ƒë·∫ßu timer ngay l·∫≠p t·ª©c
                    startProductionTimer();
                }
                
                // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
                const startBtn = document.getElementById('startBtn');
                const handoverBtn = document.getElementById('handoverShiftBtn');
                const stopAndHandoverBtn = document.getElementById('stopAndHandoverBtn');
                const resetBtn = document.getElementById('resetBtn');
                
                // ·∫®n n√∫t b·∫Øt ƒë·∫ßu, hi·ªÉn th·ªã c√°c n√∫t kh√°c
                if (startBtn) {
                    startBtn.style.display = 'none';
                    startBtn.disabled = true;
                }
                
                if (handoverBtn) {
                    handoverBtn.style.display = 'flex';
                    handoverBtn.disabled = false;
                }
                
                if (stopAndHandoverBtn) {
                    stopAndHandoverBtn.style.display = 'flex';
                    stopAndHandoverBtn.disabled = false;
                }
                
                if (resetBtn) {
                    resetBtn.style.display = 'flex';
                    resetBtn.disabled = false;
                }
                
                // Refresh d·ªØ li·ªáu t·ª´ API
                await refreshData();
                
                // Refresh sidebar content
                showOrderDetails(order.id);
            } else {
                throw new Error(`API error: ${response.status} - ${result.message || result.error || 'Unknown error'}`);
            }
            
        } catch (error) {
            console.error('‚ùå L·ªói trong startProduction:', error);
            console.error('‚ùå Error stack:', error.stack);
            showNotification('L·ªói khi b·∫Øt ƒë·∫ßu s·∫£n xu·∫•t: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }
    






 /**
     * Reset l·ªánh s·∫£n xu·∫•t v·ªÅ tr·∫°ng th√°i ch∆∞a b·∫Øt ƒë·∫ßu
     */
     async function resetProduction() {
        const order = currentEditingOrder;
        
        if (!order) {
            showNotification('L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c l·ªánh s·∫£n xu·∫•t', 'error');
            return;
        }
        
        // Hi·ªÉn th·ªã dialog x√°c nh·∫≠n
        const confirmed = confirm('‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset l·ªánh s·∫£n xu·∫•t n√†y v·ªÅ tr·∫°ng th√°i ch∆∞a b·∫Øt ƒë·∫ßu?\n\nƒêi·ªÅu n√†y s·∫Ω:\n‚Ä¢ X√≥a th·ªùi gian b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c\n‚Ä¢ Reset tr·∫°ng th√°i v·ªÅ "ch∆∞a b·∫Øt ƒë·∫ßu"\n‚Ä¢ X√≥a d·ªØ li·ªáu s·∫£n xu·∫•t (s·ªë l∆∞·ª£ng, ghi ch√∫, v.v.)\n\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!');
        
        if (!confirmed) {
            return;
        }
        
        try {
            showLoading('ƒêang reset l·ªánh s·∫£n xu·∫•t...');
            
            // Chu·∫©n b·ªã d·ªØ li·ªáu reset
            const resetData = {
                stage: STAGE_CONFIG.KEY,
                reset_to_not_started: true
            };
            
            // G·ª≠i request ƒë·∫øn API ƒë·ªÉ reset
            const response = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/reset_production`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(resetData)
            });
            
            const result = await response.json();
            
            if (response.ok) {
                // D·ª´ng timer n·∫øu ƒëang ch·∫°y
                stopProductionTimer();
                
                showNotification('‚úÖ ƒê√£ reset l·ªánh s·∫£n xu·∫•t th√†nh c√¥ng!', 'success');
                
                // C·∫≠p nh·∫≠t d·ªØ li·ªáu local
                if (currentEditingOrder) {
                    setOrderField(currentEditingOrder, 'status', 'waiting');
                    setOrderField(currentEditingOrder, 'start_time', null);
                    setOrderField(currentEditingOrder, 'end_time', null);
                    setOrderField(currentEditingOrder, 'worker', '');
                    setOrderField(currentEditingOrder, 'shift', '');
                    setOrderField(currentEditingOrder, 'good_quantity', 0);
                    setOrderField(currentEditingOrder, 'ng_quantity', 0);
                    setOrderField(currentEditingOrder, 'handover_quantity', 0);
                    setOrderField(currentEditingOrder, 'note', '');
                }
                
                await refreshData();
                
                // Refresh sidebar content
                showOrderDetails(order.id);
                
            } else {
                throw new Error(`API error: ${response.status} - ${result.message || result.error || 'Unknown error'}`);
            }
            
        } catch (error) {
            console.error('Reset production error:', error);
            
            // Fallback: N·∫øu API kh√¥ng h·ªó tr·ª£ reset, th·ª±c hi·ªán reset local
            if (error.message.includes('404') || error.message.includes('not found')) {
                showNotification('‚ö†Ô∏è API reset kh√¥ng kh·∫£ d·ª•ng, th·ª±c hi·ªán reset local...', 'warning');
                
                // Reset local data
                if (currentEditingOrder) {
                    setOrderField(currentEditingOrder, 'status', 'waiting');
                    setOrderField(currentEditingOrder, 'start_time', null);
                    setOrderField(currentEditingOrder, 'end_time', null);
                    setOrderField(currentEditingOrder, 'worker', '');
                    setOrderField(currentEditingOrder, 'shift', '');
                    setOrderField(currentEditingOrder, 'good_quantity', 0);
                    setOrderField(currentEditingOrder, 'ng_quantity', 0);
                    setOrderField(currentEditingOrder, 'handover_quantity', 0);
                    setOrderField(currentEditingOrder, 'note', '');
                }
                
                // D·ª´ng timer
                stopProductionTimer();
                
                // Refresh UI
                await refreshData();
                showOrderDetails(order.id);
                
                showNotification('‚úÖ ƒê√£ reset l·ªánh s·∫£n xu·∫•t (local)!', 'success');
            } else {
                showNotification('L·ªói khi reset l·ªánh s·∫£n xu·∫•t: ' + error.message, 'error');
            }
        } finally {
            hideLoading();
        }
    }



    // Utility functions for time display
    function formatDateTime(dateString) {
        if (!dateString) return 'N/A';
    
    try {
        // X√≥a Z ƒë·ªÉ JS kh√¥ng coi l√† UTC
        const localDateString = dateString.replace('Z', '');
        const date = new Date(localDateString);

        return date.toLocaleString('vi-VN', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            day: '2-digit',
            month: '2-digit',
            year: 'numeric'
        });
    } catch (error) {
        console.error('Error formatting date:', error);
        return 'Error';
    }
    }
    
 
    
    function formatDateTimeForInput(dateString) {
        if (!dateString) return '';
        
        try {
            const date = new Date(dateString);
            
            // Ki·ªÉm tra date c√≥ h·ª£p l·ªá kh√¥ng
            if (isNaN(date.getTime())) {
                console.error('Invalid date in formatDateTimeForInput:', dateString);
                return '';
            }
            
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        } catch (error) {
            console.error('Error in formatDateTimeForInput:', error);
            return '';
        }
    }
    
    function calculateWorkTime(startTime, endTime) {
        if (!startTime || !endTime) return 'N/A';
        
        try {
            const start = new Date(startTime);
            const end = new Date(endTime);
            
            // Ki·ªÉm tra n·∫øu date kh√¥ng h·ª£p l·ªá
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                console.error('Invalid date in calculateWorkTime:', { startTime, endTime });
                return 'Invalid date';
            }
            
            const diffMs = end - start;
            
            // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p th·ªùi gian √¢m
            if (diffMs < 0) {
                console.warn('Negative time difference in calculateWorkTime:', { startTime, endTime, diffMs });
                return '00:00:00';
            }

            const hours = Math.floor(diffMs / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        } catch (error) {
            console.error('Error calculating work time:', error);
            return 'Error';
        }
    }

    // Format datetime cho MySQL (YYYY-MM-DD HH:mm:ss)
    function formatDateTimeForMySQL(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    // Bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ ID c·ªßa timer
    let productionTimerId = null;

    /**
     * =================================================================
     * TAB SWITCHING FUNCTIONS - H√ÄM CHUY·ªÇN ƒê·ªîI TAB
     * =================================================================
     */

    /**
     * Switch between tabs in the sidebar
     */
    function switchTab(tabName) {

        
        // Remove active class from all tabs and panels in sidebar only
        document.querySelectorAll('.details-panel .tab-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.details-panel .tab-panel').forEach(panel => panel.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding panel
        const clickedTab = event.target.closest('.tab-btn');
        if (clickedTab) {
            clickedTab.classList.add('active');
        }
        
        const targetPanel = document.getElementById(tabName + '-panel');
        if (targetPanel) {
            targetPanel.classList.add('active');
    
        } else {
            console.error('‚ùå Panel not found:', tabName + '-panel');
        }
        
        // Load shifts data if switching to shifts tab
        if (tabName === 'shifts' && currentEditingOrder) {
            loadShiftsData(currentEditingOrder.id);
        }
    }

    /**
     * Load shifts data for an order
     */
    async function loadShiftsData(orderId) {
        const shiftsList = document.getElementById('shiftsList');
        const shiftsLoading = document.getElementById('shiftsLoading');
        
        if (!shiftsList || !shiftsLoading) {
            console.error('Shifts elements not found');
            return;
        }
        

        
        try {
            // Show loading
            shiftsLoading.style.display = 'flex';
            shiftsList.innerHTML = '';
            
            const apiUrl = `${API_BASE_URL}/data/production_orders/${orderId}/shifts?stage=${STAGE_CONFIG.KEY}`;

            
            // Fetch shifts data
            const response = await fetch(apiUrl);

            
            const data = await response.json();
                        if (response.ok) {
                
                renderShiftsList(data.shifts);
            } else {
                console.error('‚ùå API error:', response.status, data);
                throw new Error(data.error || 'Failed to load shifts data');
            }
        } catch (error) {
            console.error('üí• Error loading shifts data:', error);
            console.error('üí• Error stack:', error.stack);
            shiftsList.innerHTML = `
                <div class="empty-state">
                    <i class="bi bi-exclamation-triangle"></i>
                    <h5>Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu ca l√†m vi·ªác</h5>
                    <p>${error.message}</p>
                </div>
            `;
        } finally {
            shiftsLoading.style.display = 'none';
        }
    }
    
    /**
     * Render shifts list
     */
    function renderShiftsList(shifts) {
        const shiftsList = document.getElementById('shiftsList');
        
        if (!shiftsList) {
            console.error('‚ùå Shifts list element not found!');
            return;
        }
        
        if (!shifts || shifts.length === 0) {
            shiftsList.innerHTML = `
                <div class="empty-state">
                    <i class="bi bi-clock-history"></i>
                    <h5>Ch∆∞a c√≥ ca l√†m vi·ªác n√†o</h5>
                    <p>Ca l√†m vi·ªác s·∫Ω ƒë∆∞·ª£c t·∫°o khi b·∫Øt ƒë·∫ßu s·∫£n xu·∫•t</p>
                </div>
            `;
            return;
        }

        // T√≠nh to√°n th·ªëng k√™
        const completedShifts = shifts.filter(s => s.status === 'completed').length;
        const inProgressShifts = shifts.filter(s => s.status === 'in_progress').length;
        const pendingShifts = shifts.filter(s => s.status === 'pending').length;
        const totalQuantity = shifts.reduce((sum, s) => sum + (parseInt(s.handover_quantity) || 0), 0);

        // T·∫°o HTML cho th·ªëng k√™
        const statsHtml = `
            <div class="shifts-stats">
                <div class="stat-card">
                    <div class="stat-number">${completedShifts}</div>
                    <div class="stat-label">ƒê√£ ho√†n th√†nh</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${inProgressShifts}</div>
                    <div class="stat-label">ƒêang ch·∫°y</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${pendingShifts}</div>
                    <div class="stat-label">Ch·ªù b·∫Øt ƒë·∫ßu</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalQuantity.toLocaleString()}</div>
                    <div class="stat-label">T·ªïng s·∫£n l∆∞·ª£ng</div>
                </div>
            </div>
        `;
        
        const shiftsHtml = shifts.map(shift => {
            const statusClass = getShiftStatusClass(shift.status);
            const statusText = getShiftStatusText(shift.status);
            const startTime = shift.start_time ? formatDateTime(shift.start_time) : '--';
            const endTime = shift.end_time ? formatDateTime(shift.end_time) : '--';
            const workDuration = shift.work_duration_minutes ? `${shift.work_duration_minutes} ph√∫t` : '--';
            const efficiency = shift.efficiency_percent && !isNaN(shift.efficiency_percent) ? 
                `${parseFloat(shift.efficiency_percent).toFixed(1)}%` : '--';
            
            // T√≠nh to√°n progress cho ca ƒëang ch·∫°y
            let progressHtml = '';
            if (shift.status === 'in_progress' && shift.start_time) {
                const start = new Date(shift.start_time);
                const now = new Date();
                const totalDuration = 8 * 60; // 8 gi·ªù = 480 ph√∫t
                const elapsed = Math.floor((now - start) / (1000 * 60));
                const progress = Math.min(100, Math.max(0, (elapsed / totalDuration) * 100));
                const remaining = Math.max(0, totalDuration - elapsed);
                const remainingHours = Math.floor(remaining / 60);
                const remainingMinutes = remaining % 60;
                
                progressHtml = `
                    <div class="shift-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <div class="progress-text">${progress.toFixed(0)}% ho√†n th√†nh - C√≤n ${remainingHours} gi·ªù ${remainingMinutes} ph√∫t</div>
                    </div>
                `;
            }
            
            return `
                <div class="shift-item">
                    <div class="shift-header">
                        <div class="shift-title">
                            <i class="bi bi-clock"></i>
                            ${shift.shift_name || `Ca ${shift.shift_number}`}
                        </div>
                        <span class="shift-status ${statusClass}">${statusText}</span>
                    </div>
                    
                    <div class="shift-details">
                        <div class="shift-detail">
                            <div class="shift-detail-label">Th·ª£ ph·ª• tr√°ch</div>
                            <div class="shift-detail-value">${shift.worker_name || '--'}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">M√°y s·∫£n xu·∫•t</div>
                            <div class="shift-detail-value">${shift.machine_name || '--'}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">S·ªë l∆∞·ª£ng OK</div>
                            <div class="shift-detail-value">${shift.handover_quantity || 0}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">S·ªë l∆∞·ª£ng NG</div>
                            <div class="shift-detail-value">${(parseInt(shift.ng_quantity) || 0) + (parseInt(shift.ng_start_end_quantity) || 0)}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">Hi·ªáu su·∫•t</div>
                            <div class="shift-detail-value">${efficiency}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">Th·ªùi gian l√†m vi·ªác</div>
                            <div class="shift-detail-value">${workDuration}</div>
                        </div>
                    </div>

                    ${progressHtml}
                    
                    <div class="shift-times">
                        <span><i class="bi bi-play-circle"></i>B·∫Øt ƒë·∫ßu: ${startTime}</span>
                        <span><i class="bi bi-stop-circle"></i>K·∫øt th√∫c: ${endTime}</span>
                    </div>

                    <div class="shift-actions">
                        <a href="#" class="btn-action btn-view" onclick="viewShiftDetails('${shift.id}')">
                            <i class="bi bi-eye"></i>Xem chi ti·∫øt
                        </a>
                        ${shift.status === 'in_progress' ? `
                            <a href="#" class="btn-action btn-edit" onclick="editShift('${shift.id}')">
                                <i class="bi bi-pencil"></i>Ch·ªânh s·ª≠a
                            </a>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join('');
        
        shiftsList.innerHTML = statsHtml + shiftsHtml;
    }
    

    
    /**
     * Get shift status class for CSS
     */
    function getShiftStatusClass(status) {
        switch (status) {
            case 'completed': return 'completed';
            case 'in_progress': return 'in_progress';
            case 'waiting': return 'waiting';
            case 'paused': return 'paused';
            case 'handed_over': return 'handed_over';
            default: return 'waiting';
        }
    }
    
    /**
     * Get shift status text
     */
    function getShiftStatusText(status) {
        switch (status) {
            case 'completed': return 'Ho√†n th√†nh';
            case 'in_progress': return 'ƒêang l√†m';
            case 'waiting': return 'Ch·ªù';
            case 'paused': return 'T·∫°m d·ª´ng';
            case 'handed_over': return 'ƒê√£ b√†n giao';
            default: return 'Ch·ªù';
        }
    }

    /**
     * View shift details
     */
    function viewShiftDetails(shiftId) {
        console.log('üîç Viewing shift details for:', shiftId);
        // TODO: Implement shift details view
        showNotification('T√≠nh nƒÉng xem chi ti·∫øt ca l√†m vi·ªác ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn', 'info');
    }

    /**
     * Edit shift
     */
    function editShift(shiftId) {
        console.log('‚úèÔ∏è Editing shift:', shiftId);
        // TODO: Implement shift editing
        showNotification('T√≠nh nƒÉng ch·ªânh s·ª≠a ca l√†m vi·ªác ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn', 'info');
    }

    /**
     * B√†n giao ca l√†m vi·ªác
     */
    async function handoverShift() {
        const order = currentEditingOrder;
        
        if (!order) {
            showNotification('L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c l·ªánh s·∫£n xu·∫•t', 'error');
            return;
        }
        
        // Ki·ªÉm tra c√≥ shift ƒëang ch·∫°y kh√¥ng
        if (!window.currentShiftId) {
            showNotification('‚ö†Ô∏è Kh√¥ng c√≥ ca l√†m vi·ªác n√†o ƒëang ch·∫°y. Vui l√≤ng b·∫Øt ƒë·∫ßu ca tr∆∞·ªõc khi b√†n giao.', 'warning');
            return;
        }
        
        // L·∫•y th√¥ng tin t·ª´ form trong sidebar
        const formData = getFormData();
        const goodQuantity = formData.goodQty;
        const ngQuantity = formData.ngQty;
        const ngStartEndQuantity = formData.ngStartEndQty;
        const returnQuantity = formData.returnQty;
        const handoverQuantity = formData.handoverQty;
        const workerName = formData.worker;
        const shift = formData.shift || getCurrentShift();
        const notes = formData.note;
        
        // L·∫•y m√°y ƒë∆∞·ª£c g√°n th·ª±c t·∫ø cho l·ªánh n√†y
        const assignedMachine = getOrderMachine(order);
        if (!assignedMachine) {
            showNotification(`‚ö†Ô∏è L·ªánh n√†y kh√¥ng ƒë∆∞·ª£c g√°n cho m√°y ${STAGE_CONFIG.NAME} n√†o`, 'warning');
            return;
        }
        
        // Validation c∆° b·∫£n
        if (!workerName || !workerName.trim()) {
            showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n th·ª£ ph·ª• tr√°ch trong ph·∫ßn "Th√¥ng tin s·∫£n xu·∫•t"', 'warning');
            return;
        }
        
        if (goodQuantity <= 0) {
            showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng s·∫£n xu·∫•t (OK ho·∫∑c NG)', 'warning');
            return;
        }
        
        if (handoverQuantity > goodQuantity) {
            showNotification('S·ªë l∆∞·ª£ng chuy·ªÉn giao kh√¥ng th·ªÉ l·ªõn h∆°n s·ªë l∆∞·ª£ng OK', 'error');
            return;
        }
        
        // Validate t·ªïng s·ªë l∆∞·ª£ng kh√¥ng v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng ƒë·∫ßu v√†o
        if (!validateTotalQuantity(order, goodQuantity, ngQuantity, ngStartEndQuantity, returnQuantity)) {
            return;
        }
        
        // Hi·ªÉn th·ªã dialog x√°c nh·∫≠n (b·ªè qua n·∫øu ƒë√£ x√°c nh·∫≠n qua webhook)
        if (!window.__skip_handover_prompt) {
            const confirmed = confirm(`üìã X√°c nh·∫≠n b√†n giao ca l√†m vi·ªác?\n\n` +
                `L·ªánh s·∫£n xu·∫•t: ${order.production_order}\n` +
                `Th·ª£ ph·ª• tr√°ch: ${workerName}\n` +
                `Ca l√†m vi·ªác: ${shift}\n\n` +
                `S·ªë l∆∞·ª£ng:\n` +
                `‚Ä¢ OK: ${goodQuantity}\n` +
                `‚Ä¢ NG: ${ngQuantity}\n` +
                `‚Ä¢ NG ƒë·∫ßu/cu·ªëi: ${ngStartEndQuantity}\n` +
                `‚Ä¢ Tr·∫£: ${returnQuantity}\n` +
                `‚Ä¢ B√†n giao: ${handoverQuantity}\n\n` +
                `Th√¥ng tin n√†y s·∫Ω ƒë∆∞·ª£c l∆∞u v√†o l·ªãch s·ª≠ ca l√†m vi·ªác.`);
            if (!confirmed) {
                return;
            }
        }
        
        try {
            showLoading('ƒêang b√†n giao ca l√†m vi·ªác...');
            
            const now = new Date();
            const outputQuantity = goodQuantity + ngQuantity + ngStartEndQuantity + returnQuantity;
            const efficiencyPercent = outputQuantity > 0 ? (goodQuantity / outputQuantity) * 100 : 0;
            
            const mysqlDateTime = formatDateTimeForMySQL(now);
            

            
            // T√≠nh th·ªùi gian l√†m vi·ªác (work_duration_minutes)
            let workDurationMinutes = 0;
            if (window.currentShiftStartTime) {
                const startTime = new Date(window.currentShiftStartTime);
                const endTime = new Date(mysqlDateTime);
                workDurationMinutes = Math.round((endTime - startTime) / (1000 * 60));
            }
            
            // C·∫≠p nh·∫≠t shift hi·ªán t·∫°i v·ªõi th√¥ng tin b√†n giao
            const updateData = {
                end_time: mysqlDateTime,
                work_duration_minutes: workDurationMinutes,
                good_quantity: goodQuantity,
                ng_quantity: ngQuantity,
                ng_start_end_quantity: ngStartEndQuantity,
                return_quantity: returnQuantity,
                output_quantity: outputQuantity,
                handover_quantity: handoverQuantity,
                efficiency_percent: efficiencyPercent,
                handover_person: workerName,
                machine_name: assignedMachine,
                status: 'completed',
                notes: notes
            };
            
        
            const updateResponse = await fetch(`${API_BASE_URL}/data/production_orders_shift/${window.currentShiftId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(updateData)
            });
            
            const updateResult = await updateResponse.json();
            
            if (updateResponse.ok) {
                
                // Ki·ªÉm tra logic status: n·∫øu t·ªïng s·ªë l∆∞·ª£ng nh·∫≠p b·∫±ng s·ªë l∆∞·ª£ng c√≤n s·∫£n xu·∫•t c√≤n l·∫°i th√¨ status=handed_over
                try {
                    // Log th√¥ng tin order tr∆∞·ªõc khi x·ª≠ l√Ω
                    console.log('üîç [handoverShift] Th√¥ng tin order tr∆∞·ªõc khi x·ª≠ l√Ω:', {
                        orderId: order.id,
                        orderCode: order.production_order,
                        nextStage: order.next_stage,
                        currentStageStatus: order[`${STAGE_CONFIG.KEY}_status`],
                        allStageFields: Object.keys(order).filter(key => key.includes('_status'))
                    });
                    
                    const inputQuantity = getInputQuantityFromPreviousStage(order);
                    const remainingQuantity = await getRemainingQuantity(order);
              
                    
                    // N·∫øu s·ªë l∆∞·ª£ng c√≤n l·∫°i sau ca n√†y = 0, th√¨ status = 'handed_over'
                    const newStatus = remainingQuantity <= 0 ? 'handed_over' : 'waiting';
                    
                    // X√°c ƒë·ªãnh c√¥ng ƒëo·∫°n ti·∫øp theo
                    const nextStage = order.next_stage;
                    
                    const orderUpdateData = {
                        status: remainingQuantity <= 0 ? 'Ho√†n th√†nh' : 'ƒêang s·∫£n xu·∫•t',
                        [`${STAGE_CONFIG.KEY}_status`]: newStatus
                    };
                    
                    // Log th√¥ng tin tr∆∞·ªõc khi c·∫≠p nh·∫≠t
                    console.log('üîç [handoverShift] Th√¥ng tin tr∆∞·ªõc khi c·∫≠p nh·∫≠t:', {
                        orderId: order.id,
                        orderCode: order.production_order,
                        nextStage: nextStage,
                        handoverQuantity: handoverQuantity,
                        handoverQty: handoverQty,
                        newStatus: newStatus,
                        remainingQuantity: remainingQuantity,
                        currentStage: STAGE_CONFIG.KEY
                    });
                    
                    // N·∫øu c√≥ c√¥ng ƒëo·∫°n ti·∫øp theo v√† c√≥ s·ªë l∆∞·ª£ng b√†n giao, c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng ƒëo·∫°n ti·∫øp theo th√†nh 'waiting'
                    if (nextStage && handoverQuantity > 0) {
                        orderUpdateData[`${nextStage}_status`] = 'waiting';
                        console.log(`üîÑ [handoverShift] C·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng ƒëo·∫°n ti·∫øp theo ${nextStage} th√†nh 'waiting'`);
                    } else {
                        console.log(`‚ö†Ô∏è [handoverShift] Kh√¥ng c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng ƒëo·∫°n ti·∫øp theo:`, {
                            hasNextStage: !!nextStage,
                            hasHandoverQty: handoverQuantity > 0,
                            nextStage: nextStage,
                            handoverQuantity: handoverQuantity
                        });
                    }
                    
                    console.log('üì§ [handoverShift] D·ªØ li·ªáu g·ª≠i l√™n API:', orderUpdateData);
                    
                    const updateOrderResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(orderUpdateData)
                    });
                    
                    if (updateOrderResponse.ok) {
                        const updateResult = await updateOrderResponse.json();
                        console.log(`‚úÖ [handoverShift] Production order status updated successfully:`, {
                            mainStatus: orderUpdateData.status,
                            stageStatus: newStatus,
                            nextStage: nextStage ? nextStage + ' -> waiting' : 'N/A',
                            apiResponse: updateResult,
                            updatedFields: updateResult.updated_fields || []
                        });
                        
                        // Ki·ªÉm tra xem c√≥ c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng ƒëo·∫°n ti·∫øp theo kh√¥ng
                        if (nextStage && updateResult.updated_fields) {
                            const nextStageField = `${nextStage}_status`;
                            const hasNextStageUpdate = updateResult.updated_fields.includes(nextStageField);
                            console.log(`üîç [handoverShift] Ki·ªÉm tra c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng ƒëo·∫°n ti·∫øp theo:`, {
                                nextStageField: nextStageField,
                                hasNextStageUpdate: hasNextStageUpdate,
                                allUpdatedFields: updateResult.updated_fields
                            });
                        }
                    } else {
                        const updateError = await updateOrderResponse.json();
                        console.warn('‚ö†Ô∏è [handoverShift] Failed to update production order status after handover:', updateError);
                    }
                } catch (updateError) {
                    console.warn('‚ö†Ô∏è Error updating production order status after handover:', updateError);
                    // Kh√¥ng throw error v√¨ ƒë√¢y kh√¥ng ph·∫£i l·ªói nghi√™m tr·ªçng
                }
                
                showNotification('‚úÖ ƒê√£ b√†n giao ca l√†m vi·ªác th√†nh c√¥ng!', 'success');
            } else {
                console.error('‚ùå Update shift failed:', updateResult);
                throw new Error(`C·∫≠p nh·∫≠t ca: ${updateResult.error || 'Unknown error'}`);
            }
            
            // Reset c·ªù x√°c nh·∫≠n qua webhook (n·∫øu c√≥)
            window.__skip_handover_prompt = false;

            // Reset form s·ªë l∆∞·ª£ng
            setElementValue('goodQty', '0');
            setElementValue('ngQty', '0');
            setElementValue('ngStartEndQty', '0');
            setElementValue('returnQty', '0');
            setElementValue('handoverQty', '0');
            
            // Enable n√∫t "B·∫Øt ƒë·∫ßu", disable n√∫t "B√†n giao ca"
            const startBtn = document.querySelector('button[onclick="startProduction()"]');
            const handoverBtn = document.querySelector('button[onclick="handoverShift()"]');
            if (startBtn) startBtn.disabled = false;
            if (handoverBtn) handoverBtn.disabled = true;
            
            // D·ª´ng timer
            stopProductionTimer();
            
            // C·∫≠p nh·∫≠t d·ªØ li·ªáu local
            await refreshData();
            
            // Refresh sidebar content
            showOrderDetails(order.id);
            
            // Chuy·ªÉn sang tab "Th√¥ng tin ca" ƒë·ªÉ xem k·∫øt qu·∫£
            setTimeout(() => {
                const shiftsTab = document.querySelector('.details-panel .tab-btn[onclick*="shifts"]');
                if (shiftsTab) {
                    shiftsTab.click();
                }
            }, 500);
            
                        } catch (error) {
                    console.error('üí• Error in handoverShift:', error);
                    console.error('üí• Error stack:', error.stack);
                    console.error('üí• Error message:', error.message);
                    showNotification('L·ªói khi b√†n giao ca l√†m vi·ªác: ' + error.message, 'error');
                } finally {
            hideLoading();
        }
    }

    // B·∫ÆT ƒê·∫¶U LU·ªíNG X√ÅC NH·∫¨N TR∆Ø·ªöC KHI B√ÄN GIAO
    async function startHandoverConfirmationFlow() {
        const order = currentEditingOrder;
        if (!order) {
            showNotification('L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c l·ªánh s·∫£n xu·∫•t', 'error');
            return;
        }
        const formData = getFormData();
        const assignedMachine = getOrderMachine(order);
        if (!assignedMachine) {
            showNotification(`‚ö†Ô∏è L·ªánh n√†y kh√¥ng ƒë∆∞·ª£c g√°n cho m√°y ${STAGE_CONFIG.NAME} n√†o`, 'warning');
            return;
        }
        if (!formData.worker || !formData.worker.trim()) {
            showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n th·ª£ ph·ª• tr√°ch trong ph·∫ßn "Th√¥ng tin s·∫£n xu·∫•t"', 'warning');
            return;
        }
        if (!formData.shift) {
            showNotification('‚ö†Ô∏è Vui l√≤ng ch·ªçn ca l√†m vi·ªác', 'warning');
            return;
        }
        if ((formData.goodQty || 0) <= 0) {
            showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng s·∫£n xu·∫•t (OK > 0)', 'warning');
            return;
        }
        if (formData.handoverQty > formData.goodQty) {
            showNotification('S·ªë l∆∞·ª£ng chuy·ªÉn giao kh√¥ng th·ªÉ l·ªõn h∆°n s·ªë l∆∞·ª£ng OK', 'error');
            return;
        }

        // Hi·ªÉn th·ªã popup ch·ªù x√°c nh·∫≠n
        openConfirmWaitModal({
            orderCode: order.production_order,
            worker: formData.worker,
            shift: formData.shift,
            goodQty: formData.goodQty,
            ngQty: formData.ngQty,
            ngStartEndQty: formData.ngStartEndQty,
            returnQty: formData.returnQty,
            handoverQty: formData.handoverQty
        });

        // G·ª≠i y√™u c·∫ßu x√°c nh·∫≠n qua webhook (l∆∞u v√†o DB production_confirm)
        try {
            const info = {
                type: 'handover_request',
                stage: STAGE_CONFIG.KEY,
                order_code: order.production_order,
                machine_name: assignedMachine,
                shift_name: formData.shift,
                worker_name: formData.worker,
                quantities: {
                    good: formData.goodQty,
                    ng: formData.ngQty,
                    ng_start_end: formData.ngStartEndQty,
                    return: formData.returnQty,
                    handover: formData.handoverQty
                },
                requested_at: new Date().toISOString()
            };
            const payload = {
                production_order_id: order.id,
                info_confirm_json: JSON.stringify(info)
            };
            const res = await fetch(`${WEBHOOK_BASE_URL}/confirmations`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const data = await res.json();
            if (!res.ok) {
                throw new Error(data.message || data.error || 'T·∫°o y√™u c·∫ßu x√°c nh·∫≠n th·∫•t b·∫°i');
            }
            // B·∫Øt ƒë·∫ßu polling tr·∫°ng th√°i (d·ª±a tr√™n production_order_id, kh√¥ng c·∫ßn id)
            pollConfirmationStatusForOrder(order.id, 120, 3000);
        } catch (e) {
            closeConfirmWaitModal();
            showNotification('L·ªói g·ª≠i y√™u c·∫ßu x√°c nh·∫≠n: ' + e.message, 'error');
        }
    }

    function openConfirmWaitModal(info) {
        const modal = document.getElementById('confirmWaitModal');
        if (!modal) return;
        const body = modal.querySelector('#confirmWaitBody');
        if (body) {
            body.innerHTML = `
                <div class="mb-2"><strong>L·ªánh:</strong> ${info.orderCode}</div>
                <div class="mb-2"><strong>Th·ª£:</strong> ${info.worker}</div>
                <div class="mb-2"><strong>Ca:</strong> ${info.shift}</div>
                <div class="mb-2"><strong>S·ªë l∆∞·ª£ng:</strong>
                    OK: ${formatNumber(info.goodQty)}; NG: ${formatNumber(info.ngQty)}; NG ƒë·∫ßu/cu·ªëi: ${formatNumber(info.ngStartEndQty)}; Tr·∫£: ${formatNumber(info.returnQty)}; B√†n giao: ${formatNumber(info.handoverQty)}
                </div>
                <div id="confirmStatusBox" class="alert alert-info d-flex align-items-center" role="alert">
                    <i class="bi bi-hourglass-split me-2"></i>
                    <div><span id="confirmStatusText">ƒêang ch·ªù qu·∫£n l√Ω x√°c nh·∫≠n...</span></div>
                </div>
                <div class="d-flex gap-2">
                    <button id="proceedHandoverBtn" class="btn btn-primary btn-sm" style="display:none;" onclick="proceedAfterApproved()">
                        <i class="bi bi-check2-circle me-1"></i>Ti·∫øn h√†nh b√†n giao
                    </button>
                    <button class="btn btn-outline-secondary btn-sm" onclick="closeConfirmWaitModal()">ƒê√≥ng</button>
                </div>
            `;
        }
        modal.style.display = 'flex';
        try { document.body.style.overflow = 'hidden'; } catch (e) {}
    }

    function closeConfirmWaitModal() {
        const modal = document.getElementById('confirmWaitModal');
        if (modal) modal.style.display = 'none';
        try { document.body.style.overflow = ''; } catch (e) {}
    }

    async function pollConfirmationStatus(id, maxAttempts = 120, intervalMs = 3000, cb) {
        let attempts = 0;
        const timer = setInterval(async () => {
            attempts++;
            try {
                // DB-oriented status endpoint
                const res = await fetch(`${WEBHOOK_BASE_URL}/get_status_confirmations?id=${encodeURIComponent(id)}`);
                const data = await res.json();
                if (res.ok && data) {
                    const status = data.status || data[0]?.status;
                    if (status) updateConfirmWaitModalStatus(status);
                    if (status === 'approved' || status === 'rejected') clearInterval(timer);
                }
            } catch (e) {
                // ignore transient errors
            }
            if (attempts >= maxAttempts) {
                clearInterval(timer);
                closeConfirmWaitModal();
                showNotification('H·∫øt th·ªùi gian ch·ªù x√°c nh·∫≠n. Vui l√≤ng th·ª≠ l·∫°i.', 'warning');
            }
        }, intervalMs);
    }

    // Poll theo production_order_id, kh√¥ng c·∫ßn truy·ªÅn id
    async function pollConfirmationStatusForOrder(orderId, maxAttempts = 120, intervalMs = 3000) {
        let attempts = 0;
        const timer = setInterval(async () => {
            attempts++;
            try {
                const res = await fetch(`${WEBHOOK_BASE_URL}/get_status_confirmations`);
                const data = await res.json();
                if (res.ok && data) {
                    let row = null;
                    if (Array.isArray(data)) {
                        // T√¨m theo production_order_id
                        const candidates = data.filter(r => String(r.production_order_id) === String(orderId));
                        if (candidates.length > 0) {
                            // L·∫•y b·∫£n ghi m·ªõi nh·∫•t theo updated_at/created_at n·∫øu c√≥
                            candidates.sort((a,b) => new Date(b.updated_at||b.created_at||0) - new Date(a.updated_at||a.created_at||0));
                            row = candidates[0];
                        }
                    } else if (data.production_order_id && String(data.production_order_id) === String(orderId)) {
                        row = data;
                    }

                    if (row && row.status) {
                        updateConfirmWaitModalStatus(row.status);
                        if (row.status === 'approved' || row.status === 'rejected') {
                            clearInterval(timer);
                        }
                    }
                }
            } catch (e) {
                // ignore
            }
            if (attempts >= maxAttempts) {
                clearInterval(timer);
                closeConfirmWaitModal();
                showNotification('H·∫øt th·ªùi gian ch·ªù x√°c nh·∫≠n. Vui l√≤ng th·ª≠ l·∫°i.', 'warning');
            }
        }, intervalMs);
    }

    function updateConfirmWaitModalStatus(status) {
        const box = document.getElementById('confirmStatusBox');
        const text = document.getElementById('confirmStatusText');
        const proceedBtn = document.getElementById('proceedHandoverBtn');
        if (!box || !text) return;
        if (status === 'approved') {
            box.className = 'alert alert-success d-flex align-items-center';
            text.textContent = 'ƒê√£ ƒë∆∞·ª£c ph√™ duy·ªát. B·∫°n c√≥ th·ªÉ ti·∫øn h√†nh b√†n giao.';
            if (proceedBtn) proceedBtn.style.display = 'inline-block';
        } else if (status === 'rejected') {
            box.className = 'alert alert-danger d-flex align-items-center';
            text.textContent = 'Y√™u c·∫ßu b·ªã t·ª´ ch·ªëi.';
            if (proceedBtn) proceedBtn.style.display = 'none';
        } else {
            box.className = 'alert alert-info d-flex align-items-center';
            text.textContent = 'ƒêang ch·ªù qu·∫£n l√Ω x√°c nh·∫≠n...';
            if (proceedBtn) proceedBtn.style.display = 'none';
        }
    }

    async function proceedAfterApproved() {
        // Ch·ªâ ch·∫°y khi ƒë√£ approved
        window.__skip_handover_prompt = true;
        await handoverShift();
        closeConfirmWaitModal();
    }

    /**
     * Reset form fields in the sidebar
     */
    function resetForm() {
        // Reset all input fields
        document.querySelectorAll('#detailsPanel input, #detailsPanel select, #detailsPanel textarea').forEach(field => {
            if (field.type === 'checkbox') {
                field.checked = false;
            } else {
                field.value = '';
            }
        });
        
        // Reset quantity inputs to 0
        document.querySelectorAll('.quantity-input').forEach(input => {
            input.value = '0';
        });
        
        showNotification('ƒê√£ reset form th√†nh c√¥ng!', 'success');
    }


    
    // H√†m t√≠nh th·ªùi gian ƒëang ch·∫°y (t·ª´ th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu ƒë·∫øn hi·ªán t·∫°i)
    function calculateRunningTime(startTime, endTime) {

        
        try {
            // Parse th·ªùi gian b·∫Øt ƒë·∫ßu
            const start = new Date(startTime);
            // S·ª≠ d·ª•ng th·ªùi gian hi·ªán t·∫°i v√† chuy·ªÉn v·ªÅ m√∫i gi·ªù local
            const end = endTime ? new Date(endTime) : new Date();
            
            // Th√™m 7 gi·ªù v√†o end time ƒë·ªÉ chuy·ªÉn v·ªÅ m√∫i gi·ªù Vi·ªát Nam
            const endLocal = new Date(end.getTime() + (7 * 60 * 60 * 1000));
          
            
            // Ki·ªÉm tra n·∫øu date kh√¥ng h·ª£p l·ªá
            if (isNaN(start.getTime()) || isNaN(endLocal.getTime())) {
                console.error('‚ùå Invalid date in calculateRunningTime:', { startTime, endTime });
                return 'Invalid date';
            }
            
            const diffMs = endLocal.getTime() - start.getTime();
            
            const hours = Math.floor(diffMs / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
            
            const result = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            return result;
        } catch (error) {
            return 'Error';
        }
    }
    
    // H√†m c·∫≠p nh·∫≠t th·ªùi gian ch·∫°y trong giao di·ªán
    function updateRunningTimer() {
        // T√¨m element timer trong sidebar m·ªõi
        const statusTimeElement = document.getElementById('statusTime');
        const runningTimeInfoElement = document.getElementById('runningTimeInfo');
        const endTimeInfoElement = document.getElementById('endTimeInfo');
        // Fallback cho element c≈© n·∫øu c√≤n t·ªìn t·∫°i
        const timerElement = document.getElementById('productionRunningTime');
        
        if (window.currentShiftStartTime) {
            // T√≠nh th·ªùi gian ch·∫°y t·ª´ th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu ƒë·∫øn hi·ªán t·∫°i (ho·∫∑c th·ªùi ƒëi·ªÉm k·∫øt th√∫c n·∫øu c√≥)
            const endTime = getOrderField(currentEditingOrder, 'end_time');
            const time = calculateRunningTime(window.currentShiftStartTime, endTime);
            
  
            
            // C·∫≠p nh·∫≠t timer trong sidebar m·ªõi (production status)
            if (statusTimeElement) {
                statusTimeElement.textContent = `Th·ªùi gian: ${time}`;
            }
            
            // C·∫≠p nh·∫≠t th·ªùi gian ch·∫°y trong tab th√¥ng tin
            if (runningTimeInfoElement) {
                // Lu√¥n c·∫≠p nh·∫≠t, kh√¥ng quan t√¢m c√≥ end_time hay kh√¥ng
                runningTimeInfoElement.textContent = time;
            }
            
            // C·∫≠p nh·∫≠t th·ªùi gian k·∫øt th√∫c n·∫øu ƒë√£ k·∫øt th√∫c
            if (endTimeInfoElement && getOrderField(currentEditingOrder, 'end_time')) {
                endTimeInfoElement.textContent = formatDateTime(getOrderField(currentEditingOrder, 'end_time'));
            }
            
            // C·∫≠p nh·∫≠t timer c≈© n·∫øu c√≤n t·ªìn t·∫°i (fallback)
            if (timerElement) {
                timerElement.textContent = time;
            }
        } else {
            console.warn('‚ö†Ô∏è Kh√¥ng c√≥ th·ªùi gian b·∫Øt ƒë·∫ßu (window.currentShiftStartTime)');
            
            // N·∫øu ch∆∞a b·∫Øt ƒë·∫ßu ho·∫∑c kh√¥ng c√≥ th·ªùi gian
            if (statusTimeElement) {
                statusTimeElement.textContent = 'Th·ªùi gian: 00:00:00';
            }
            if (runningTimeInfoElement) {
                runningTimeInfoElement.textContent = '--';
            }
            if (endTimeInfoElement) {
                endTimeInfoElement.textContent = '--';
            }
        }
    }
    
    // H√†m b·∫Øt ƒë·∫ßu timer
    function startProductionTimer() {
        // X√≥a timer c≈© n·∫øu c√≥
        stopProductionTimer();
        
        // Log order information for debugging
        if (currentEditingOrder) {
            
        }
        
        // B·∫Øt ƒë·∫ßu timer m·ªõi, c·∫≠p nh·∫≠t m·ªói gi√¢y
        updateRunningTimer();
        productionTimerId = setInterval(updateRunningTimer, 1000);

    }
    
    // H√†m d·ª´ng timer
    function stopProductionTimer() {
        if (productionTimerId) {
            clearInterval(productionTimerId);
            productionTimerId = null;
        }
    }

    // Export functions for global access
    window.refreshData = refreshData;
    window.showReportTab = showReportTab;

    

    window.updateHandoverQuantity = updateHandoverQuantity;
    
    // Filter functions
    window.applyFilters = applyFilters;
    window.clearFilters = clearFilters;
    
    // Wizard functions
    window.wizardNextStep = wizardNextStep;
    window.wizardPreviousStep = wizardPreviousStep;

    window.updateWizardHandoverQuantity = updateWizardHandoverQuantity;
    
    // Details panel functions
    window.showOrderDetails = showOrderDetails;
    window.closeDetailsPanel = closeDetailsPanel;

    window.startProduction = startProduction;
    // window.endProduction = endProduction;

    // Tab switching functions
    window.switchTab = switchTab;
    window.resetForm = resetForm;
    // window.pauseProduction = pauseProduction;

    




    /**
     * =================================================================
     * REPORT FUNCTIONS - H√ÄM X·ª¨ L√ù B√ÅO C√ÅO
     * =================================================================
     */

    /**
     * Hi·ªÉn th·ªã tab b√°o c√°o
     */
    function showReportTab() {
        
        // Chuy·ªÉn sang tab b√°o c√°o
        const reportTab = document.getElementById('report-tab');
        
        if (reportTab) {
            reportTab.click();
        } else {
            console.error('Report tab not found!');
        }
        
        // Load d·ªØ li·ªáu b√°o c√°o
        loadReportData();
    }

    /**
     * Load d·ªØ li·ªáu b√°o c√°o - c√°c l·ªánh ƒë√£ b√†n giao
     */
    async function loadReportData() {
      
        
        try {
            showLoading('ƒêang t·∫£i d·ªØ li·ªáu b√°o c√°o...');
            
                    // L·ªçc c√°c l·ªánh ƒë√£ ho√†n th√†nh (s·ªë l∆∞·ª£ng c·∫ßn s·∫£n xu·∫•t = 0) v√† ƒë√£ ƒë∆∞·ª£c b√†n giao t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
        const handedOverOrders = ordersData.filter(order => {
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // T√≠nh t·ªïng s·ªë l∆∞·ª£ng b√†n giao v√† input
            const previousStageHandover = order.previous_stage_handover_quantity || 0;
            const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
            const currentStageInput = getOrderField(order, 'input_quantity') || 0;
            
  
            return inputQuantity <= 0 && previousStageHandover > 0;
        });  
        
            
            // Render b·∫£ng b√°o c√°o
            renderReportTable(handedOverOrders);
            
            // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng
            updateReportCount(handedOverOrders.length);
            
        } catch (error) {
            console.error('Error in loadReportData:', error);
            showNotification('L·ªói khi t·∫£i d·ªØ li·ªáu b√°o c√°o: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    /**
     * Render b·∫£ng b√°o c√°o
     */
    function renderReportTable(orders) {
        const tableBody = document.getElementById('reportTableBody');
        if (!tableBody) {
            console.error('reportTableBody not found!');
            return;
        }
        
        // X√≥a d·ªØ li·ªáu c≈©
        tableBody.innerHTML = '';
        
        // Ki·ªÉm tra c√≥ d·ªØ li·ªáu kh√¥ng
        if (orders.length === 0) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="13" class="text-center text-muted py-4">
                        <i class="bi bi-file-earmark-text fs-1 mb-2 d-block"></i>
                        Ch∆∞a c√≥ l·ªánh n√†o ƒë∆∞·ª£c b√†n giao
                    </td>
                </tr>
            `;
            return;
        }

        // S·∫Øp x·∫øp theo th·ªùi gian b√†n giao (m·ªõi nh·∫•t l√™n ƒë·∫ßu)
        const sortedOrders = [...orders].sort((a, b) => {
            const aTime = getOrderField(a, 'handover_date') ? new Date(getOrderField(a, 'handover_date')).getTime() : 0;
            const bTime = getOrderField(b, 'handover_date') ? new Date(getOrderField(b, 'handover_date')).getTime() : 0;
            return bTime - aTime;
        });

        // Render t·ª´ng d√≤ng
        sortedOrders.forEach((order, index) => {
            const row = createReportTableRow(order, index);
            tableBody.appendChild(row);
        });
    }

    /**
     * T·∫°o d√≤ng b√°o c√°o
     */
    function createReportTableRow(order, index) {
        const row = document.createElement('tr');
        row.className = 'order-row';
        row.setAttribute('data-order-id', order.id);
        
        // T√≠nh to√°n ti·∫øn ƒë·ªô
        const inputQty = getOrderField(order, 'input_quantity') || 0;
        const sheet_count = order.sheet_count || 0;
        const goodQty = getOrderField(order, 'good_quantity') || 0;
        const ngQty = getOrderField(order, 'ng_quantity') || 0;
        const deployedQty = order.deployed_quantity || 0;
        const progressPercent = inputQty > 0 ? Math.round((goodQty / inputQty) * 100) : 0;
        
        // L·∫•y th√¥ng tin b√†n giao
        const handoverDate = getOrderField(order, 'handover_date') ? formatDateTime(getOrderField(order, 'handover_date')) : 'N/A';
        const handoverQuantity = getOrderField(order, 'handover_quantity') || 0;
        
        // X√°c ƒë·ªãnh icon v√† m√†u s·∫Øc cho tr·∫°ng th√°i ƒë√£ b√†n giao
        const statusIcon = 'bi-arrow-right-circle';
        const statusClass = 'text-info';
        const statusText = 'ƒê√£ b√†n giao';
        
        row.innerHTML = `
            <td class="text-center">
                <span class="badge bg-light text-dark">${index + 1}</span>
            </td>
            <td>
                <div class="d-flex align-items-center">
                    <i class="bi ${statusIcon} ${statusClass} me-2"></i>
                    <div>
                        <div class="fw-bold">${order.production_order}</div>
                        <small class="text-muted">${formatDate(order.deployment_date)} - ${getOrderField(order, 'shift')}</small>
                        <small class="text-info d-block">${statusText}</small>
                    </div>
                </div>
            </td>
            <td class="text-center">
                <span class="fw-bold">${order.order_type || ''}</span>
            </td>
            <td>
                <div>
                    <div class="fw-bold">${order.internal_product_code}</div>
                    <small class="text-muted" title="${order.product_name}">${truncateText(order.product_name, 100)}</small>
                </div>
            </td>
            <td class="text-center">
                <span class="badge bg-secondary">${order.paper_type || 'N/A'}</span>
            </td>
            <td class="text-center">
                <span class="fw-bold">${order.paper_weight || 0} gsm</span>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(deployedQty)}</div>
                <small class="text-muted">pcs</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-primary">${formatNumber(sheet_count)}</div>
                <small class="text-muted">t·ªù gi·∫•y</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-success">${formatNumber(order.paper_length || 0)}</div>
                <small class="text-muted">KT</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-danger">${formatNumber(order.paper_width || 0)}</div>
                <small class="text-muted">chi·ªÅu r·ªông</small>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(order.blank_count || 0)}</div>
                <small class="text-muted">ph√¥i</small>
            </td>
            <td class="text-center">
                <div class="progress" style="height: 20px;">
                    <div class="progress-bar bg-success" style="width: ${Math.min(progressPercent, 100)}%">
                        ${progressPercent}%
                    </div>
                </div>
                <small class="text-muted">${statusText}</small>
            </td>
            <td class="text-center">
                <small class="text-muted d-block" title="${order.assigned_machine || 'N/A'}">${truncateText(order.assigned_machine || 'N/A', 15)}</small>
            </td>
        `;
        
        // Th√™m click event ƒë·ªÉ xem chi ti·∫øt
        row.style.cursor = 'pointer';
        row.addEventListener('click', () => {
            showOrderDetails(order.id);
        });
        
        return row;
    }

    /**
     * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng b√°o c√°o
     */
    function updateReportCount(count) {
        const reportCountElement = document.getElementById('report-count');
        if (reportCountElement) {
            reportCountElement.textContent = count;
        } else {
            console.error('report-count element not found!');
        }
    }

    /**
     * =================================================================
     * FILTER FUNCTIONS - H√ÄM L·ªåC D·ªÆ LI·ªÜU
     * =================================================================
     */

    // Bi·∫øn l∆∞u tr·ªØ d·ªØ li·ªáu g·ªëc v√† d·ªØ li·ªáu ƒë√£ l·ªçc
    let originalOrdersData = [];
    let filteredOrdersData = [];

    /**
     * √Åp d·ª•ng c√°c b·ªô l·ªçc
     */
    function applyFilters() {
        const fromDateFilter = document.getElementById('fromDateFilter')?.value || '';
        const toDateFilter = document.getElementById('toDateFilter')?.value || '';
        const searchInput = document.getElementById('searchInput')?.value?.toLowerCase() || '';

        // L·ªçc d·ªØ li·ªáu
        let filteredCount = 0;
        filteredOrdersData = originalOrdersData.filter(order => {
            // L·ªçc theo kho·∫£ng ng√†y s·∫£n xu·∫•t
            if (fromDateFilter && toDateFilter) {
                const orderDate = order.deployment_date || order.created_at;
                if (!orderDate || orderDate < fromDateFilter || orderDate > toDateFilter) {
                    return false;
                }
            } else if (fromDateFilter) {
                const orderDate = order.deployment_date || order.created_at;
                if (!orderDate || orderDate < fromDateFilter) {
                    return false;
                }
            } else if (toDateFilter) {
                const orderDate = order.deployment_date || order.created_at;
                if (!orderDate || orderDate > toDateFilter) {
                    return false;
                }
            }



            // L·ªçc theo t√¨m ki·∫øm
            if (searchInput) {
                const searchFields = [
                    order.order_type,
                    order.production_order,
                    order.internal_product_code,
                    order.paper_type,
                    order.assigned_machine,
                    getOrderField(order, 'worker_name')
                ].map(field => (field || '').toLowerCase());

                const hasMatch = searchFields.some(field => field.includes(searchInput));
                if (!hasMatch) {
                    return false;
                }
            }

            // ‚úÖ KI·ªÇM TRA STAGE TR∆Ø·ªöC ƒê√É HO√ÄN TH√ÄNH HAY CH∆ØA (T·∫†M TH·ªúI DISABLE)
            /*
            if (!isPreviousStageReady(order)) {
                console.log(`Order ${order.id} filtered out by previous stage not ready:`, {
                    previous_stage: order.previous_stage,
                    previous_stage_status: order.previous_stage_status,
                    current_status: getOrderField(order, 'status')
                });
                return false; // ·∫®n l·ªánh n√†y v√¨ stage tr∆∞·ªõc ch∆∞a xong
            }
            */

            filteredCount++;
            return true;
        });



        // C·∫≠p nh·∫≠t d·ªØ li·ªáu hi·ªÉn th·ªã
        ordersData = filteredOrdersData;
        
        // Render l·∫°i b·∫£ng
        renderOrdersTable();
        updateStatistics();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o
        if (filteredOrdersData.length === 0) {
            showNotification('Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ph√π h·ª£p v·ªõi b·ªô l·ªçc', 'warning');
        } else {
            showNotification(`ƒê√£ l·ªçc: ${filteredOrdersData.length} l·ªánh s·∫£n xu·∫•t`, 'info');
        }
    }

    /**
     * X√≥a t·∫•t c·∫£ b·ªô l·ªçc
     */
    function clearFilters() {
        const fromDateFilter = document.getElementById('fromDateFilter');
        const toDateFilter = document.getElementById('toDateFilter');
        const searchInput = document.getElementById('searchInput');
        
        if (fromDateFilter) fromDateFilter.value = '';
        if (toDateFilter) toDateFilter.value = '';
        if (searchInput) searchInput.value = '';

        // X√≥a cache filter ng√†y khi clear
        localStorage.removeItem(DATE_FILTER_CACHE_KEY);

        // Kh√¥i ph·ª•c d·ªØ li·ªáu g·ªëc
        ordersData = [...originalOrdersData];
        
        // Chuy·ªÉn v·ªÅ tab "T·∫•t c·∫£" khi x√≥a filter
        const allTab = document.getElementById('all-tab');
        if (allTab) {
            allTab.click();
        }
        
        // Render l·∫°i b·∫£ng
        renderOrdersTable();
        updateStatistics();
        
        showNotification('ƒê√£ x√≥a t·∫•t c·∫£ b·ªô l·ªçc', 'info');
    }

    /**
     * T·ª± ƒë·ªông l·ªçc khi nh·∫≠p t√¨m ki·∫øm (debounce)
     */
    let searchTimeout;
    function setupSearchDebounce() {
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    applyFilters();
                }, 300); // Delay 300ms
            });
        }
    }

    /**
     * T·ª± ƒë·ªông l·ªçc khi thay ƒë·ªïi b·ªô l·ªçc
     */
    function setupFilterChangeListeners() {
        // Ch·ªâ setup listener cho c√°c element th·ª±c s·ª± t·ªìn t·∫°i
        const fromDateFilter = document.getElementById('fromDateFilter');
        const toDateFilter = document.getElementById('toDateFilter');

        if (fromDateFilter) {
            fromDateFilter.addEventListener('change', applyFilters);
        }
        if (toDateFilter) {
            toDateFilter.addEventListener('change', applyFilters);
        }
    }

    /**
     * C·∫≠p nh·∫≠t danh s√°ch m√°y t·ª´ d·ªØ li·ªáu th·ª±c t·∫ø
     */
    function updateMachineFilterOptions() {
        const machineFilter = document.getElementById('machineFilter');
        if (!machineFilter) {
            return;
        }

        // L·ªçc c√°c m√°y thu·ªôc Stage_${STAGE_CONFIG.KEY} t·ª´ d·ªØ li·ªáu m√°y
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        ).map(machine => machine.machine_name);

        // X√≥a options c≈© (gi·ªØ l·∫°i option "T·∫•t c·∫£")
        machineFilter.innerHTML = '<option value="">T·∫•t c·∫£</option>';

        // Th√™m options m·ªõi
        MStageMachines.sort().forEach(machine => {
            const option = document.createElement('option');
            option.value = machine;
            option.textContent = machine;
            machineFilter.appendChild(option);
        });
    }


    /**
     * T√≠nh s·ªë l∆∞·ª£ng c·∫ßn s·∫£n xu·∫•t c√≤n l·∫°i
     * = S·ªë l∆∞·ª£ng t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc - (T·ªïng s·ªë l∆∞·ª£ng b√†n giao + NG c·ªßa c√°c ca ƒë√£ l√†m)
     */
    async function getRemainingQuantity(order) {
        try {
            // L·∫•y s·ªë l∆∞·ª£ng t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // L·∫•y t·ªïng s·ªë l∆∞·ª£ng b√†n giao c·ªßa c√°c ca ƒë√£ l√†m
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            let totalHandoverQuantity = 0;
            let totalNgQuantity = 0;
            if (shiftsData.shifts && Array.isArray(shiftsData.shifts)) {
                shiftsData.shifts.forEach(shift => {
                    totalHandoverQuantity += (parseInt(shift.handover_quantity) || 0);
                    totalNgQuantity += (parseInt(shift.ng_quantity) || 0);
                });
            }
            
            const remainingQuantity = Math.max(0, inputQuantity - totalHandoverQuantity - totalNgQuantity);
            
            return remainingQuantity;
        } catch (error) {
            console.error('‚ùå L·ªói t√≠nh s·ªë l∆∞·ª£ng c√≤n l·∫°i:', error);
            return getInputQuantityFromPreviousStage(order); // Fallback
        }
    }

    /**
     * Load v√† hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
     */
    async function loadRemainingQuantity() {
        if (!currentEditingOrder) return;
        
        try {
            const remainingQuantity = await getRemainingQuantity(currentEditingOrder);
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
            const remainingQuantityDisplay = document.getElementById('remainingQuantityDisplay');
            if (remainingQuantityDisplay) {
                remainingQuantityDisplay.textContent = `${remainingQuantity} t·ªù gi·∫•y`;
            }
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
            const totalQuantityDisplay = document.getElementById('totalQuantityDisplay');
            if (totalQuantityDisplay) {
                const currentTotal = parseInt(getElementValue('goodQty') || 0) + 
                                   parseInt(getElementValue('ngQty') || 0) + 
                                   parseInt(getElementValue('ngStartEndQty') || 0) + 
                                   parseInt(getElementValue('returnQty') || 0);
                totalQuantityDisplay.textContent = `${currentTotal} / ${remainingQuantity}`;
            }
            
        } catch (error) {
            console.error('‚ùå L·ªói load s·ªë l∆∞·ª£ng c√≤n l·∫°i:', error);
        }
    }

    /**
     * C·∫≠p nh·∫≠t hi·ªÉn th·ªã th·ªëng k√™ real-time
     */
    function updateStatisticsDisplay() {
        const goodQty = parseInt(getElementValue('goodQty')) || 0;
        const ngQty = parseInt(getElementValue('ngQty')) || 0;
        const ngStartEndQty = parseInt(getElementValue('ngStartEndQty')) || 0;
        const returnQty = parseInt(getElementValue('returnQty')) || 0;
        
        const totalProduced = goodQty + ngQty + ngStartEndQty + returnQty;
        const inputQuantity = getInputQuantityFromPreviousStage(currentEditingOrder);
        const efficiency = inputQuantity > 0 ? Math.round((totalProduced / inputQuantity) * 100) : 0;
        const ngRate = totalProduced > 0 ? Math.round(((ngQty + ngStartEndQty) / totalProduced) * 100) : 0;
        
        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã th·ªëng k√™
        const totalProducedElement = document.getElementById('totalProducedValue');
        const efficiencyElement = document.getElementById('efficiencyValue');
        const ngRateElement = document.getElementById('ngRateValue');
        
        if (totalProducedElement) {
            totalProducedElement.textContent = `${totalProduced} s·∫£n ph·∫©m`;
        }
        if (efficiencyElement) {
            efficiencyElement.textContent = `${efficiency}%`;
        }
        if (ngRateElement) {
            ngRateElement.textContent = `${ngRate}%`;
        }
        
        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
        updateTotalQuantityDisplay();
    }

    /**
     * Load v√† hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
     */
    async function loadRemainingQuantity() {
        if (!currentEditingOrder) return;
        
        try {
            const remainingQuantity = await getRemainingQuantity(currentEditingOrder);
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
            const remainingQuantityDisplay = document.getElementById('remainingQuantityDisplay');
            if (remainingQuantityDisplay) {
                remainingQuantityDisplay.textContent = `${remainingQuantity} t·ªù gi·∫•y`;
            }
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
            const totalQuantityDisplay = document.getElementById('totalQuantityDisplay');
            if (totalQuantityDisplay) {
                const currentTotal = parseInt(getElementValue('goodQty') || 0) + 
                                   parseInt(getElementValue('ngQty') || 0) + 
                                   parseInt(getElementValue('ngStartEndQty') || 0) + 
                                   parseInt(getElementValue('returnQty') || 0);
                totalQuantityDisplay.textContent = `${currentTotal} / ${remainingQuantity}`;
            }
            
        } catch (error) {
            console.error('‚ùå L·ªói load s·ªë l∆∞·ª£ng c√≤n l·∫°i:', error);
        }
    }

    /**
     * Ki·ªÉm tra shift hi·ªán t·∫°i v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
     */
    async function checkCurrentShiftStatus() {
        if (!currentEditingOrder) return;
        
        try {
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            // T√¨m shift ƒëang ch·∫°y (status = 'in_progress')
            const currentShift = shiftsData.shifts?.find(shift => shift.status === 'in_progress');
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
            const startBtn = document.getElementById('startBtn');
            const handoverBtn = document.getElementById('handoverShiftBtn');
            const stopAndHandoverBtn = document.getElementById('stopAndHandoverBtn');
            const handoverBtn2 = document.getElementById('handoverBtn');
            const resetBtn = document.getElementById('resetBtn');
            
            if (currentShift) {
                // C√≥ shift ƒëang ch·∫°y
        
                
                // C·∫≠p nh·∫≠t UI d·ª±a tr√™n tr·∫°ng th√°i ca k√≠p
                if (startBtn) {
                    startBtn.style.display = 'none';
                    startBtn.disabled = true;
                }
                
                if (handoverBtn) {
                    handoverBtn.style.display = 'flex';
                    handoverBtn.disabled = false;
                }
                
                if (stopAndHandoverBtn) {
                    stopAndHandoverBtn.style.display = 'flex';
                    stopAndHandoverBtn.disabled = false;
                }
                
                if (resetBtn) {
                    resetBtn.style.display = 'flex';
                    resetBtn.disabled = false;
                }
                
                // L∆∞u ID v√† th·ªùi gian b·∫Øt ƒë·∫ßu c·ªßa shift hi·ªán t·∫°i
                window.currentShiftId = currentShift.id;
                window.currentShiftStartTime = currentShift.start_time;
                
                // C·∫≠p nh·∫≠t hi·ªÉn th·ªã th·ªùi gian b·∫Øt ƒë·∫ßu trong sidebar
                const startTimeInfo = document.getElementById('startTimeInfo');
                if (startTimeInfo) {
                    // Hi·ªÉn th·ªã th·ªùi gian ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng
                    startTimeInfo.textContent = formatDateTime(currentShift.start_time);
    
                }
                
                // B·∫Øt ƒë·∫ßu timer n·∫øu ch∆∞a c√≥
                if (!productionTimerId) {
                    startProductionTimer();
                }
                

            } else {
                // Kh√¥ng c√≥ shift ƒëang ch·∫°y

                
                // Ki·ªÉm tra tr·∫°ng th√°i l·ªánh ƒë·ªÉ quy·∫øt ƒë·ªãnh hi·ªÉn th·ªã n√∫t b·∫Øt ƒë·∫ßu
                const orderStatus = getOrderField(currentEditingOrder, 'status');
                
                if (startBtn) {
                    if (orderStatus === 'completed' || orderStatus === 'handed_over') {
                        // N·∫øu l·ªánh ƒë√£ ho√†n th√†nh ho·∫∑c ƒë√£ b√†n giao, ·∫©n n√∫t b·∫Øt ƒë·∫ßu
                        startBtn.style.display = 'none';
                        startBtn.disabled = true;
        
                    } else {
                        // N·∫øu l·ªánh ch∆∞a ho√†n th√†nh, hi·ªÉn th·ªã n√∫t b·∫Øt ƒë·∫ßu
                        startBtn.style.display = 'flex';
                        startBtn.disabled = false;
        
                    }
                }
                
                if (handoverBtn) {
                    handoverBtn.style.display = 'none';
                    handoverBtn.disabled = true;
                }
                
                if (stopAndHandoverBtn) {
                    stopAndHandoverBtn.style.display = 'none';
                    stopAndHandoverBtn.disabled = true;
                }
                
                if (resetBtn) {
                    resetBtn.style.display = 'none';
                    resetBtn.disabled = true;
                }
                
                // D·ª´ng timer
                stopProductionTimer();
                
    
            }
            
        } catch (error) {
            console.error('‚ùå L·ªói ki·ªÉm tra tr·∫°ng th√°i shift:', error);
        }
    }

    /**
     * Load v√† hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
     */
    async function loadRemainingQuantity() {
        if (!currentEditingOrder) return;
        
        try {
            const remainingQuantity = await getRemainingQuantity(currentEditingOrder);
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
            const remainingQuantityDisplay = document.getElementById('remainingQuantityDisplay');
            if (remainingQuantityDisplay) {
                remainingQuantityDisplay.textContent = `${remainingQuantity} t·ªù gi·∫•y`;
            }
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
            const totalQuantityDisplay = document.getElementById('totalQuantityDisplay');
            if (totalQuantityDisplay) {
                const currentTotal = parseInt(getElementValue('goodQty') || 0) + 
                                   parseInt(getElementValue('ngQty') || 0) + 
                                   parseInt(getElementValue('ngStartEndQty') || 0) + 
                                   parseInt(getElementValue('returnQty') || 0);
                totalQuantityDisplay.textContent = `${currentTotal} / ${remainingQuantity}`;
            }
            
        } catch (error) {
            console.error('‚ùå L·ªói load s·ªë l∆∞·ª£ng c√≤n l·∫°i:', error);
        }
    }
  </script>
  
  <!-- User Info Update Script -->
  <script>
    // Update user info when page loads
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(checkAuthAndUpdateUser, 100);
    });
    

    
    function checkAuthAndUpdateUser() {
      if (typeof auth === 'undefined') {
        setTimeout(checkAuthAndUpdateUser, 100);
        return;
      }
      
      if (!auth.isLoggedIn()) {
        showLoginPopup({
          onLoginSuccess: function(userData) {
            updateUserInfo();
            refreshData();
          },
          onLoginError: function(error) {
            console.error('Login failed:', error);
          }
        });
        return;
      }
      
      updateUserInfo();
    }
    
    function updateUserInfo() {
      const userNameElement = document.getElementById('userName');
      
      if (!userNameElement) {
        setTimeout(updateUserInfo, 100);
        return;
      }
      
      if (typeof auth === 'undefined') {
        setTimeout(updateUserInfo, 100);
        return;
      }
      
      const user = auth.getUser();
      
      if (user) {
        userNameElement.textContent = user.full_name;
      } else {
        userNameElement.textContent = 'Ch∆∞a ƒëƒÉng nh·∫≠p';
      }
    }
    

    
    // Multi-Select Worker Functions
    function initializeWorkerMultiSelect(order) {
        const selectedWorkers = document.getElementById('selectedWorkers');
        const workerSearch = document.getElementById('workerSearch');
        const workerDropdown = document.getElementById('workerDropdown');
        const workerOptions = document.getElementById('workerOptions');
        
        // L·∫•y danh s√°ch user t·ª´ API
        let availableWorkers = [];
        
        async function loadWorkersFromAPI() {
            try {
                const response = await fetch(`${API_BASE_URL}/data/user`);
                
                if (response.ok) {
                    const users = await response.json();
           
                    
                    // Ki·ªÉm tra format c·ªßa response
                    if (Array.isArray(users)) {
                        availableWorkers = users.map(user => {
                            // Format: "M√£ nh√¢n vi√™n - T√™n nh√¢n vi√™n"
                            const name = `${user.ma_nhan_vien} - ${user.ten_nhan_vien}`;
                            return name;
                        }).filter(name => name && name.trim());
                    } else if (users.data && Array.isArray(users.data)) {
                        availableWorkers = users.data.map(user => `${user.ma_nhan_vien} - ${user.ten_nhan_vien}`).filter(name => name);
                    } else {
                        console.error('Unexpected API response format:', users);
                        availableWorkers = [];
                    }
                    
                    // Sau khi load workers, ƒë·ªÅ xu·∫•t user ƒëƒÉng nh·∫≠p hi·ªán t·∫°i
                    suggestCurrentUser();
                    
                    // N·∫øu dropdown ƒëang m·ªü, c·∫≠p nh·∫≠t l·∫°i options
                    if (workerDropdown.style.display === 'block') {
                        renderDropdownOptions(workerSearch.value);
                    }
                } else {
                    console.error('Failed to load workers from API, status:', response.status);
                    availableWorkers = [];
                }
            } catch (error) {
                console.error('Error loading workers:', error);
                availableWorkers = [];
            }
        }
        
        // ƒê·ªÅ xu·∫•t user ƒëƒÉng nh·∫≠p hi·ªán t·∫°i
        function suggestCurrentUser() {
            
            if (typeof auth !== 'undefined') {
                const currentUser = auth.getUser();
                // console.log('üë§ Current user:', currentUser);
                
                if (currentUser && currentUser.full_name) {

                    
                    // T√¨m user trong danh s√°ch available workers
                    const userWorkerName = availableWorkers.find(worker => 
                        worker.includes(currentUser.full_name) || 
                        worker.includes(currentUser.ma_nhan_vien)
                    );
                    
                    
                    if (userWorkerName && selectedWorkerList.length === 0) {
                        selectedWorkerList = [userWorkerName];
                        renderSelectedWorkers();
                        updateWorkerInput();
                
                    } else if (selectedWorkerList.length > 0) {
                    } else {
                    }
                } else {
                }
            } else {
            }
        }
        
        let selectedWorkerList = [];
        
        // Kh√¥ng load d·ªØ li·ªáu t·ª´ database, ch·ªâ ƒë·ªÉ tr·ªëng ƒë·ªÉ nh·∫≠p m·ªõi
        
        // Render selected workers
        function renderSelectedWorkers() {
            selectedWorkers.innerHTML = '';
            selectedWorkerList.forEach(worker => {
                const tag = document.createElement('div');
                tag.className = 'selected-tag';
                tag.innerHTML = `
                    ${worker}
                    <button class="remove-btn" onclick="event.stopPropagation(); event.preventDefault(); removeWorker('${worker}')">√ó</button>
                `;
                selectedWorkers.appendChild(tag);
            });
        }
        
        // Render dropdown options
        function renderDropdownOptions(filter = '') {
            
            
            workerOptions.innerHTML = '';
            const filteredWorkers = availableWorkers.filter(worker => 
                worker.toLowerCase().includes(filter.toLowerCase()) &&
                !selectedWorkerList.includes(worker)
            );
            
            
            filteredWorkers.forEach(worker => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.textContent = worker;
                item.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    addWorker(worker);
                };
                workerOptions.appendChild(item);
            });
            
        }
        
        // Add worker
        window.addWorker = function(worker) {
            if (!selectedWorkerList.includes(worker)) {
                selectedWorkerList.push(worker);
                renderSelectedWorkers();
                renderDropdownOptions(workerSearch.value);
                updateWorkerInput();
            }
            // Kh√¥ng ƒë√≥ng dropdown ngay, ƒë·ªÉ user c√≥ th·ªÉ ch·ªçn th√™m
            workerSearch.focus();
        };
        
        // Remove worker
        window.removeWorker = function(worker) {
            selectedWorkerList = selectedWorkerList.filter(w => w !== worker);
            renderSelectedWorkers();
            renderDropdownOptions(workerSearch.value);
            updateWorkerInput();
            // Focus l·∫°i v√†o search input sau khi x√≥a
            workerSearch.focus();
        };
        
        // Update hidden input for form submission
        function updateWorkerInput() {
            const workerInput = document.getElementById('worker');
            if (workerInput) {
                workerInput.value = selectedWorkerList.join(', ');
            }
        }
        
        // Event listeners
        workerSearch.addEventListener('focus', () => {
            workerDropdown.style.display = 'block';
            renderDropdownOptions();
        });
        
        // NgƒÉn ch·∫∑n event propagation cho to√†n b·ªô multi-select container
        const multiSelectContainer = document.querySelector('.multi-select-container');
        if (multiSelectContainer) {
            multiSelectContainer.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        }
        
        workerSearch.addEventListener('input', (e) => {
            renderDropdownOptions(e.target.value);
        });
        
        // NgƒÉn ch·∫∑n event propagation cho dropdown
        workerDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            // Ch·ªâ ƒë√≥ng dropdown n·∫øu click outside multi-select v√† kh√¥ng ph·∫£i click v√†o dropdown item
            if (!e.target.closest('.multi-select-container') && !e.target.closest('.dropdown-item')) {
                workerDropdown.style.display = 'none';
            }
        });
        
        // Initialize
        loadWorkersFromAPI().then(() => {
            renderSelectedWorkers();
            updateWorkerInput();
        });
    }
    
    // handleLogout ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü tr√™n
  </script>

  <!-- Details Panel - Will be generated dynamically -->
  <div class="details-panel" id="detailsPanel">
    <!-- Content will be generated by showOrderDetails() function -->
  </div>
  
  <!-- Loading Overlay -->
  <div id="loadingOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; justify-content: center; align-items: center;">
    <div class="text-center text-white">
      <div class="spinner-border" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <div class="mt-2">ƒêang t·∫£i d·ªØ li·ªáu t·ª´ API...</div>
    </div>
  </div>

  <!-- Confirm Wait Modal (simple custom modal to avoid extra deps) -->
  <div id="confirmWaitModal" style="display:none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
    <div style="background:#fff; border-radius:12px; width: min(560px, 92vw); padding:18px; box-shadow: 0 20px 40px rgba(0,0,0,.35); transform: translateZ(0);">
      <div class="d-flex align-items-center mb-2">
        <i class="bi bi-shield-check text-primary me-2"></i>
        <h5 class="mb-0">Ch·ªù x√°c nh·∫≠n b√†n giao</h5>
        <button class="btn btn-sm btn-outline-secondary ms-auto" onclick="closeConfirmWaitModal()">ƒê√≥ng</button>
      </div>
      <div id="confirmWaitBody" class="small"></div>
      <div class="mt-3 text-muted" style="font-size: 12px;">
        Vui l√≤ng gi·ªØ nguy√™n m√†n h√¨nh n√†y cho ƒë·∫øn khi ƒë∆∞·ª£c ph√™ duy·ªát ho·∫∑c t·ª´ ch·ªëi.
      </div>
    </div>
  </div>
  
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
