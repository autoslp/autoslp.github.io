<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>C√¥ng ƒëo·∫°n X√©n - Carton Manager</title>
  <!-- Bootstrap Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <!-- Universal Stage CSS -->
  <link rel="stylesheet" href="universal-stage.css">
  <!-- Sidebar Generator -->
  <script src="sidebar-generator.js"></script>
  <!-- Custom Logout Handler -->
  <script>
    // ƒê·ªãnh nghƒ©a handleLogout tr∆∞·ªõc khi auth.js load
    window.handleLogout = function() {
      // X√≥a session
      localStorage.removeItem('user_session');
      
      // ·∫®n th√¥ng tin user
      updateUserInfo();
      
      // Hi·ªÉn th·ªã login popup
      showLoginPopup({
        onLoginSuccess: function(userData) {
          updateUserInfo();
          refreshData();
        }
      });
    };
  </script>
  
  <!-- Auth Manager -->
  <script src="../js/auth.js"></script>
  <!-- Login Popup Component -->
  <script src="../js/login-popup.js"></script>

  <!-- Custom CSS for Shifts Tab -->
  <style>
    /* Shifts Tab Styles */
    .shifts-container {
      padding: 0;
    }
    
    .shifts-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #e9ecef;
    }
    
    .shifts-header h6 {
      margin: 0;
      color: #495057;
      font-weight: 600;
    }
    
    .shifts-loading {
      display: flex;
      align-items: center;
      color: #6c757d;
      font-size: 0.875rem;
    }
    
    .shifts-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .shifts-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: #f8fafc;
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid #e2e8f0;
    }

    .stat-number {
      font-size: 24px;
      font-weight: 700;
      color: #2563eb;
      margin-bottom: 4px;
    }

    .stat-label {
      font-size: 12px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .shift-item {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .shift-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      border-color: #2563eb;
    }

    .shift-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: #2563eb;
    }
    
    .shift-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    
    .shift-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: #1f2937;
    }

    .shift-title i {
      color: #2563eb;
      font-size: 16px;
    }
    
    .shift-status {
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .shift-status.completed {
      background: #dcfce7;
      color: #16a34a;
    }
    
    .shift-status.in_progress {
      background: #fef3c7;
      color: #ca8a04;
    }
    
    .shift-status.waiting {
      background: #e0e7ff;
      color: #2563eb;
    }
    
    .shift-status.paused {
      background: #fecaca;
      color: #dc2626;
    }
    
    .shift-status.handed_over {
      background: #cffafe;
      color: #0891b2;
    }
    
    .shift-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .shift-detail {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .shift-detail-label {
      font-size: 12px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }
    
    .shift-detail-value {
      font-size: 14px;
      font-weight: 600;
      color: #1f2937;
    }
    
    .shift-times {
      display: flex;
      gap: 24px;
      padding-top: 16px;
      border-top: 1px solid #e2e8f0;
      font-size: 13px;
      color: #6b7280;
    }

    .shift-times span {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .shift-times i {
      font-size: 14px;
    }

    .shift-progress {
      margin-top: 12px;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
    }

    .progress-bar {
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #16a34a, #2563eb);
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 12px;
      color: #6b7280;
      text-align: center;
    }

    .shift-actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e2e8f0;
    }

    .btn-action {
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .btn-view {
      background: #2563eb;
      color: white;
    }

    .btn-view:hover {
      background: #1d4ed8;
      color: white;
    }

    .btn-edit {
      background: #ca8a04;
      color: white;
    }

    .btn-edit:hover {
      background: #a16207;
      color: white;
    }

    .empty-state {
      text-align: center;
      padding: 48px 24px;
      color: #6b7280;
    }

    .empty-state i {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .empty-state h5 {
      margin-bottom: 8px;
      color: #1f2937;
    }

    .empty-state p {
      margin: 0;
      font-size: 14px;
    }

    @media (max-width: 768px) {
      .shifts-stats {
        grid-template-columns: 1fr;
      }
      
      .shift-details {
        grid-template-columns: 1fr;
      }
      
      .shift-times {
        flex-direction: column;
        gap: 8px;
      }
    }
    
    .shift-summary {
      background: #e9ecef;
      border-radius: 6px;
      padding: 1rem;
      margin-top: 1rem;
    }
    
    .shift-summary h6 {
      margin-bottom: 0.75rem;
      color: #495057;
      font-weight: 600;
    }
    
    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.75rem;
    }
    
    .summary-stat {
      text-align: center;
      padding: 0.5rem;
      background: white;
      border-radius: 4px;
    }
    
    .summary-stat-value {
      font-size: 1.25rem;
      font-weight: 600;
      color: #495057;
    }
    
    .summary-stat-label {
      font-size: 0.75rem;
      color: #6c757d;
      margin-top: 0.25rem;
    }
    
    .no-shifts {
      text-align: center;
      padding: 2rem;
      color: #6c757d;
    }
    
    .no-shifts i {
      font-size: 2rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }
    
    .shifts-container {
      min-height: 200px;
      border: 1px solid #ddd;
      padding: 15px;
      background: #fff;
    }
    
    /* Button styles for shift handover */
    .btn-info-custom {
      background: linear-gradient(135deg, #17a2b8, #138496);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 120px;
      justify-content: center;
    }
    
    .btn-info-custom:hover {
      background: linear-gradient(135deg, #138496, #117a8b);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(23, 162, 184, 0.3);
    }
    
    .btn-info-custom:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(23, 162, 184, 0.3);
    }
    
    /* Quantity Table Styles */
    .quantity-table {
      background: white;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0,0,0,0.08);
      margin-bottom: 20px;
    }
    
    .table-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .table-header h6 {
      margin: 0;
      font-weight: 600;
      font-size: 1rem;
    }
    
    .table-actions {
      display: flex;
      gap: 10px;
    }
    
    .btn-add-row {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 0.875rem;
    }
    
    .btn-add-row:hover {
      background: rgba(255,255,255,0.3);
      transform: translateY(-1px);
    }
    
    .table-container {
      overflow-x: auto;
    }
    
    .quantity-table table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .quantity-table th {
      background: #f8f9fa;
      padding: 12px 8px;
      text-align: center;
      font-weight: 600;
      color: #495057;
      border-bottom: 2px solid #dee2e6;
      font-size: 0.875rem;
    }
    
    .quantity-table td {
      padding: 10px 8px;
      text-align: center;
      border-bottom: 1px solid #dee2e6;
      vertical-align: middle;
      font-size: 0.875rem;
    }
    
    .quantity-table tr:hover {
      background: #f8f9fa;
    }
    
    /* .quantity-input {
      width: 80px;
      padding: 6px 8px;
      border: 2px solid #e9ecef;
      border-radius: 6px;
      text-align: center;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 0.875rem;
    } */
    
    /* .quantity-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    } */
    
    .quantity-input.ok {
      border-color: #28a745;
      color: #28a745;
    }
    
    .quantity-input.ng {
      border-color: #dc3545;
      color: #dc3545;
    }
    
    .btn-remove-row {
      background: #dc3545;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.75rem;
    }
    
    .btn-remove-row:hover {
      background: #c82333;
      transform: scale(1.05);
    }
     
         /* ========================================
     * CSS RI√äNG CHO PH·∫¶N CH·ªåN K·ªÜ
     * ======================================== */
     
     /* Saved Ke Section Styles */
     .saved-ke-section {
       background: #f8f9fa;
       border-radius: 12px;
       padding: 20px;
       margin-top: 25px;
     }
     
     .saved-ke-header {
       text-align: center;
       margin-bottom: 20px;
     }
     
     .saved-ke-actions {
       display: flex;
       gap: 10px;
       justify-content: center;
       margin-top: 15px;
     }
     
     .saved-ke-content {
       background: white;
       border-radius: 8px;
       padding: 15px;
       border: 1px solid #dee2e6;
     }
     
     .saved-ke-item {
       display: flex;
       justify-content: space-between;
       align-items: center;
       padding: 12px;
       border-bottom: 1px solid #e9ecef;
       background: #f8f9fa;
       border-radius: 6px;
       margin-bottom: 8px;
     }
     
     .saved-ke-item:last-child {
       border-bottom: none;
       margin-bottom: 0;
     }
     
     .saved-ke-info {
       flex: 1;
     }
     
     .saved-ke-name {
       font-weight: 600;
       color: #495057;
       margin-bottom: 4px;
     }
     
     .saved-ke-details {
       font-size: 0.9rem;
       color: #6c757d;
     }
     
     .saved-ke-quantity {
       font-weight: 700;
       color: #28a745;
       font-size: 1.1rem;
       margin-left: 15px;
     }
     
     /* K·ªá Toggle Styles */
     .ke-toggle-list {
       margin-bottom: 20px;
     }
     
     .ke-toggle-grid {
       display: grid;
       grid-template-columns: 1fr 1fr;
       gap: 12px;
       margin-bottom: 20px;
     }
     
     .ke-toggle-item {
       background: white;
       border-radius: 12px;
       border: 2px solid #e9ecef;
       overflow: hidden;
       transition: all 0.3s ease;
       min-height: 80px;
       cursor: pointer;
     }
     
     .ke-toggle-item:hover {
       transform: translateY(-2px);
       box-shadow: 0 5px 15px rgba(0,0,0,0.1);
     }
     
     .ke-toggle-item.selected {
       border-color: #667eea;
       box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
       background: linear-gradient(135deg, #f8f9ff 0%, #f0f2ff 100%);
     }
     
     /* .ke-toggle-item.completed {
       border-color: #28a745;
       background: linear-gradient(135deg, #f8fff8 0%, #f0fff0 100%);
       opacity: 0.8;
     }
     
     .ke-toggle-item.completed:hover {
       opacity: 1;
     }
     
     .ke-status {
       font-size: 0.8rem;
       color: #6c757d;
       margin-top: 4px;
       font-style: italic;
     }
     
     .no-ke-data {
       text-align: center;
       padding: 20px;
       color: #6c757d;
       font-style: italic;
       background: #f8f9fa;
       border-radius: 8px;
       border: 1px dashed #dee2e6;
     } */
     
     .ke-toggle-header {
       background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
       padding: 15px;
       display: flex;
       align-items: center;
       transition: all 0.3s ease;
       height: 100%;
     }
     
     .ke-toggle-item.selected .ke-toggle-header {
       background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
       color: white;
     }
     
     .ke-info {
       display: flex;
       flex-direction: column;
       gap: 3px;
       width: 100%;
     }
     
     .ke-title-row {
       display: flex;
       align-items: center;
       gap: 8px;
     }
     
     .ke-icon {
       width: 24px;
       height: 24px;
       fill: #667eea;
       flex-shrink: 0;
     }
     
     .ke-toggle-item.selected .ke-icon {
       fill: white;
     }
     
     .ke-toggle-title {
       font-size: 1rem;
       font-weight: 600;
       margin: 0;
     }
     
     .ke-quantity {
       font-size: 0.8rem;
       color: #6c757d;
       font-weight: 500;
     }
     
     .ke-toggle-item.selected .ke-quantity {
       color: rgba(255, 255, 255, 0.8);
     }

     
     /* Progress Section Styles */
     .progress-section {
       background: #f8f9fa;
       border-radius: 12px;
       padding: 20px;
       margin-bottom: 20px;
     }
     
     .progress-title {
       color: #667eea;
       font-weight: 600;
       margin-bottom: 15px;
       text-align: center;
       font-size: 1.1rem;
     }
     
     .progress-bar {
       height: 8px;
       background: #e9ecef;
       border-radius: 4px;
       overflow: hidden;
       margin-bottom: 15px;
     }
     
     .progress-fill {
       height: 100%;
       background: linear-gradient(90deg, #667eea, #764ba2);
       border-radius: 4px;
       transition: width 0.3s ease;
     }
     
     .progress-stats {
       display: grid;
       grid-template-columns: 1fr 1fr;
       gap: 15px;
     }
     
     .stat-item {
       background: white;
       border-radius: 8px;
       padding: 15px;
       text-align: center;
       border: 1px solid #e9ecef;
     }
     
     .stat-value {
       font-size: 1.5rem;
       font-weight: 700;
       color: #667eea;
       margin-bottom: 5px;
     }
     
     .ke-stat-label {
       color: #6c757d;
       font-size: 0.8rem;
       font-weight: 500;
     }
     
     /* Summary Section Styles */
     .summary-section {
       background: #f8f9fa;
       border-radius: 12px;
       padding: 20px;
       margin-bottom: 20px;
     }
     
     .summary-title {
       color: #667eea;
       font-weight: 600;
       margin-bottom: 15px;
       text-align: center;
       font-size: 1.1rem;
     }
     
     .summary-grid {
       display: grid;
       grid-template-columns: 1fr 1fr;
       gap: 15px;
       margin-bottom: 20px;
     }
     
     .summary-card {
       background: white;
       border-radius: 8px;
       padding: 15px;
       text-align: center;
       border: 1px solid #e9ecef;
     }
     
     .summary-value {
       font-size: 1.4rem;
       font-weight: 700;
       color: #667eea;
       margin-bottom: 5px;
     }
     
     .summary-label {
       color: #6c757d;
       font-size: 0.8rem;
       font-weight: 500;
     }
     
     /* Bulk Controls Styles */
     .bulk-controls {
       display: flex;
       flex-direction: column;
       gap: 10px;
       margin-bottom: 20px;
     }
     
     .form-check-ke {
       margin: 0;
     }
     
     .form-check-label-ke {
       font-weight: 500;
       color: #495057;
     }
  </style>

</head>
<body data-stage="xen">
  <!-- Sidebar will be generated by JavaScript -->

  <!-- Main Content -->
  <div class="main-content sidebar-collapsed" id="mainContent">
    <div class="content-area">
    <div class="container-fluid p-4">
      
      <!-- Stage Header -->
      <div class="stage-header">
        <div class="d-flex justify-content-between align-items-center">
          <div>
            <h1>
              <i class="bi bi-bullseye me-2"></i>
              C√¥ng ƒëo·∫°n X√©n
            </h1>

            <p class="mb-0">X√©n gi·∫•y - Qu·∫£n l√Ω chi ti·∫øt s·∫£n xu·∫•t</p>
          </div>
          
          <div class="user-controls">
            <div class="user-info d-flex align-items-center me-3">
              <i class="fas fa-user-circle me-2"></i>
              <span id="userName" class="fw-bold me-2">Loading...</span>
              <!-- <span class="badge bg-primary" id="userRole">...</span> -->
            </div>
            <button class="btn btn-outline-primary btn-sm" onclick="handleLogout()">
              <i class="fas fa-sign-out-alt me-1"></i>ƒêƒÉng xu·∫•t
            </button>
          </div>
        </div>
      </div>
      
      <!-- Statistics -->
      <div class="row mb-4" id="stageStats">
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalOrders">0</div>
            <div class="stat-label">T·ªïng l·ªánh</div>
          </div>
        </div>
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalPlan">0</div>
            <div class="stat-label">SL K·∫ø ho·∫°ch</div>
          </div>
        </div>
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalGood">0</div>
            <div class="stat-label">SL ƒê·∫°t</div>
          </div>
        </div>
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalNg">0</div>
            <div class="stat-label">SL NG</div>
          </div>
        </div>
      </div>
      
      <!-- Main Card -->
      <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
                          <h5 class="mb-0">Danh s√°ch l·ªánh s·∫£n xu·∫•t </h5>
          <div class="d-flex align-items-center">

            <!-- Main Actions -->
            <button class="btn btn-primary me-2" onclick="refreshData()">
              <i class="bi bi-arrow-clockwise me-1"></i>L√†m m·ªõi
            </button>
            <button class="btn btn-outline-primary me-2" onclick="loadDataWithDateFilter()">
              <i class="bi bi-calendar-range me-1"></i>T·∫£i theo ng√†y
            </button>
          </div>
        </div>
        
        <div class="card-body">
          <!-- Filters -->
          <div class="card mb-3">
            <div class="card-header bg-light">
              <div class="d-flex justify-content-between align-items-center">
                <h6 class="mb-0">
                  <i class="bi bi-funnel me-2"></i>B·ªô l·ªçc d·ªØ li·ªáu
                </h6>
                <button class="btn btn-outline-secondary btn-sm" onclick="clearFilters()" title="X√≥a t·∫•t c·∫£ b·ªô l·ªçc">
                  <i class="bi bi-x-circle me-1"></i>X√≥a b·ªô l·ªçc
                </button>
              </div>
            </div>
            <div class="card-body">
              <div class="row g-3">
                <div class="col-md-3">
                  <label class="form-label fw-bold">
                    <i class="bi bi-calendar me-1"></i>T·ª´ ng√†y:
                  </label>
                  <input type="date" class="form-control" id="fromDateFilter" placeholder="Ch·ªçn ng√†y b·∫Øt ƒë·∫ßu">
                </div>
                <div class="col-md-3">
                  <label class="form-label fw-bold">
                    <i class="bi bi-calendar me-1"></i>ƒê·∫øn ng√†y:
                  </label>
                  <input type="date" class="form-control" id="toDateFilter" placeholder="Ch·ªçn ng√†y k·∫øt th√∫c">
                </div>
                <!-- <div class="col-md-2">
                  <label class="form-label fw-bold">
                    <i class="bi bi-clock me-1"></i>Ca:
                  </label>
                  <select class="form-select" id="shiftFilter">
                    <option value="">T·∫•t c·∫£</option>
                    <option value="Ca 1">Ca 1</option>
                    <option value="Ca 2">Ca 2</option>
                    <option value="Ca 3">Ca 3</option>
                    <option value="K√≠p 1">K√≠p 1</option>
                    <option value="K√≠p 2">K√≠p 2</option>
                  </select>
                </div> -->
                <!-- <div class="col-md-2">
                  <label class="form-label fw-bold">
                    <i class="bi bi-gear me-1"></i>M√°y:
                  </label>
                  <select class="form-select" id="machineFilter">
                    <option value="">T·∫•t c·∫£</option>
                    <option value="X·∫£ 1">X·∫£ 1</option>
                    <option value="X·∫£ 2">X·∫£ 2</option>
                    <option value="X·∫£ 3">X·∫£ 3</option>
                  </select>
                </div> -->
                <div class="col-md-5">
                  <label class="form-label fw-bold">
                    <i class="bi bi-search me-1"></i>T√¨m ki·∫øm:
                  </label>
                  <div class="input-group">
                    <input type="text" class="form-control" id="searchInput" placeholder="T√¨m theo m√£ l·ªánh, s·∫£n ph·∫©m, m√°y, th·ª£...">
                    <button class="btn btn-primary" type="button" onclick="applyFilters()">
                      <i class="bi bi-search"></i>
                    </button>
                  </div>
                  <!-- <small class="text-muted">T·ª± ƒë·ªông t√¨m ki·∫øm khi nh·∫≠p (300ms delay)</small> -->
                </div>
              </div>
            </div>
          </div>
          
          <!-- Tabs Navigation -->
          <ul class="nav nav-tabs mb-3" id="machineTabs" role="tablist">
            <!-- Dynamic tabs will be generated here -->
          </ul>
          
          <!-- Tab Content -->
          <div class="tab-content" id="machineTabContent">
            <!-- Dynamic tab content will be generated here -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // === C·∫§U H√åNH C√îNG ƒêO·∫†N HI·ªÜN T·∫†I ===
    const $stage_now = 'xen'; // Thay ƒë·ªïi gi√° tr·ªã n√†y ƒë·ªÉ chuy·ªÉn sang c√¥ng ƒëo·∫°n kh√°c: xa, xen, in_offset, boi, be, dan, kho
    
    // === C·∫§U H√åNH STAGE T·ª∞ ƒê·ªòNG ===
    const STAGE_CONFIGS = {
        xa: { KEY: 'xa', NAME: 'X·∫¢', DISPLAY: 'X·∫¢ GI·∫§Y CU·ªòN' },
        xen: { KEY: 'xen', NAME: 'X√âN', DISPLAY: 'X√âN GI·∫§Y' },
        in_offset: { KEY: 'in_offset', NAME: 'IN OFFSET', DISPLAY: 'IN OFFSET' },
        boi: { KEY: 'boi', NAME: 'B·ªíI', DISPLAY: 'B·ªíI GI·∫§Y' },
        be: { KEY: 'be', NAME: 'B·∫æ', DISPLAY: 'B·∫æ GI·∫§Y' },
        dan: { KEY: 'dan', NAME: 'D√ÅN', DISPLAY: 'D√ÅN GI·∫§Y' },
        kho: { KEY: 'kho', NAME: 'KHO', DISPLAY: 'KHO TH√ÄNH PH·∫®M' }
    };
    
    const STAGE_CONFIG = STAGE_CONFIGS[$stage_now];
    
    // === HELPER FUNCTIONS FOR DYNAMIC FIELD NAMES ===
    function getFieldName(field) {
        return `${STAGE_CONFIG.KEY}_${field}`;
    }
    
    function getOrderField(order, field) {
        const fieldName = getFieldName(field);
        return order[fieldName] || order[field] || 0;
    }
    
    function setOrderField(order, field, value) {
        const fieldName = getFieldName(field);
        order[fieldName] = value;
    }
    
    /**
     * =================================================================
     * ${STAGE_CONFIG.NAME} STAGE MANAGEMENT - QU·∫¢N L√ù C√îNG ƒêO·∫†N ${STAGE_CONFIG.NAME}
     * =================================================================
     * Ch·ª©c nƒÉng ch√≠nh:
     * 1. Hi·ªÉn th·ªã danh s√°ch l·ªánh s·∫£n xu·∫•t ·ªü c√¥ng ƒëo·∫°n ${STAGE_CONFIG.NAME}
     * 2. Ho√†n th√†nh c√¥ng ƒëo·∫°n ${STAGE_CONFIG.NAME} (c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng OK, NG)
     * 3. B√†n giao sang c√¥ng ƒëo·∫°n ti·∫øp theo theo workflow_definition
     */

    // === C·∫§U H√åNH API & WEBHOOK ===
    const API_BASE_URL = 'https://api.autoslp.com/api';
    const WEBHOOK_BASE_URL = 'https://api.autoslp.com:5678/webhook';

    // === BI·∫æN GLOBAL ===
    let ordersData = [];        // D·ªØ li·ªáu l·ªánh s·∫£n xu·∫•t
    let currentEditingOrder = null;  // ƒê∆°n h√†ng ƒëang ch·ªânh s·ª≠a
    let machineStatusData = []; // D·ªØ li·ªáu tr·∫°ng th√°i m√°y

    /**
     * =================================================================
     * MACHINE STATUS FUNCTIONS - H√ÄM QU·∫¢N L√ù TR·∫†NG TH√ÅI M√ÅY
     * =================================================================
     */

    /**
     * T·∫£i d·ªØ li·ªáu tr·∫°ng th√°i m√°y t·ª´ API
     */
    async function loadMachineStatus() {
        try {
            console.log('üîç Loading machine status from API...');
            const response = await fetch(`${API_BASE_URL}/data/production_machines`);
            if (response.ok) {
                machineStatusData = await response.json();
                console.log('‚úÖ Machine status loaded:', machineStatusData);
            } else {
                console.error('‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu m√°y:', response.status);
                machineStatusData = [];
            }
        } catch (error) {
            console.error('‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu m√°y:', error);
            machineStatusData = [];
        }
    }

    /**
     * Ki·ªÉm tra xem m√°y c√≥ ƒëang s·∫£n xu·∫•t l·ªánh n√†o kh√¥ng
     * @param {string} machineName - T√™n m√°y
     * @returns {object|null} - Th√¥ng tin l·ªánh ƒëang s·∫£n xu·∫•t ho·∫∑c null
     */
    function getMachineCurrentOrder(machineName) {
        if (!machineStatusData || machineStatusData.length === 0) {
            return null;
        }
        
        const machine = machineStatusData.find(m => m.machine_name === machineName);
        return machine && machine.current_order_id ? machine : null;
    }

    /**
     * Ki·ªÉm tra xem m√°y c·ª• th·ªÉ c√≥ ƒëang ch·∫°y l·ªánh kh√¥ng
     * @param {string} machineName - T√™n m√°y c·∫ßn ki·ªÉm tra
     * @returns {object} - { isRunning: boolean, runningOrder: object|null }
     */
    function checkMachineStatus(machineName) {
        const machine = machineStatusData.find(m => m.machine_name === machineName);
        
        if (!machine) {
            return { isRunning: false, runningOrder: null };
        }
        
        const isRunning = !!(machine.current_order_id && machine.current_order_id !== null);
        
        return {
            isRunning: isRunning,
            runningOrder: isRunning ? machine : null
        };
    }

    /**
     * Ki·ªÉm tra xem l·ªánh c√≥ thu·ªôc m√°y n√†o kh√¥ng
     * @param {object} order - L·ªánh s·∫£n xu·∫•t
     * @returns {string|null} - T√™n m√°y ho·∫∑c null
     */
    function getOrderMachine(order) {
        const assignedMachine = order.assigned_machine || '';
        
        // L·ªçc c√°c m√°y thu·ªôc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // T√¨m m√°y ${STAGE_CONFIG.NAME} trong danh s√°ch m√°y ƒë∆∞·ª£c g√°n
        for (const MStageMachine of MStageMachines) {
            if (assignedMachine.includes(MStageMachine.machine_name)) {
                return MStageMachine.machine_name;
            }
        }
        
        return null;
    }



    /**
     * Ki·ªÉm tra xem l·ªánh c√≥ ƒëang ch·∫°y kh√¥ng
     * @param {object} order - L·ªánh s·∫£n xu·∫•t
     * @returns {object} - { isRunning: boolean, reason: string }
     */
    function isOrderRunning(order) {
        // Ki·ªÉm tra xem c√≥ m√°y n√†o ƒëang s·∫£n xu·∫•t l·ªánh n√†y kh√¥ng
        const machineWithThisOrder = machineStatusData.find(machine => 
            machine.current_order_id == order.id
        );

        // N·∫øu l·ªánh n√†y ƒëang ƒë∆∞·ª£c s·∫£n xu·∫•t b·ªüi m·ªôt m√°y n√†o ƒë√≥
        if (machineWithThisOrder) {
            return { isRunning: true, reason: `L·ªánh hi·ªán t·∫°i c·ªßa m√°y ${machineWithThisOrder.machine_name}` };
        }

        // N·∫øu kh√¥ng c√≥ m√°y n√†o ƒëang s·∫£n xu·∫•t l·ªánh n√†y
        return { isRunning: false, reason: 'L·ªánh kh√¥ng ƒëang ƒë∆∞·ª£c s·∫£n xu·∫•t' };
    }

    /**
     * =================================================================
     * ENHANCED API FUNCTIONS - API C·∫¢I TI·∫æN
     * =================================================================
     */

    /**
     * Fetch v·ªõi timeout v√† retry
     */
    async function fetchWithTimeout(url, options = {}, timeout = 10000) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);

        try {
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            return response;
        } catch (error) {
            clearTimeout(timeoutId);
            throw error;
        }
    }

    /**
     * Fetch v·ªõi retry logic
     */
    async function fetchWithRetry(url, options = {}, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const timeout = attempt === 1 ? 10000 : 3000;
                const response = await fetchWithTimeout(url, options, timeout);
                
                if (response.ok) {
                    return response;
                }
                
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
            } catch (error) {
                lastError = error;
                
                if (attempt < maxRetries) {
                    const delay = Math.min(1000 * attempt, 2000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        throw lastError;
    }


    /**
     * Cache key cho filter ng√†y
     */
    const DATE_FILTER_CACHE_KEY = `date_filter_${STAGE_CONFIG.KEY}`;
    
    /**
     * L∆∞u gi√° tr·ªã filter ng√†y v√†o cache
     */
    function saveDateFilterToCache() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (fromDateInput && toDateInput) {
            const cacheData = {
                fromDate: fromDateInput.value,
                toDate: toDateInput.value,
                timestamp: Date.now()
            };
            localStorage.setItem(DATE_FILTER_CACHE_KEY, JSON.stringify(cacheData));
        }
    }
    
    /**
     * Kh√¥i ph·ª•c gi√° tr·ªã filter ng√†y t·ª´ cache
     */
    function loadDateFilterFromCache() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (!fromDateInput || !toDateInput) return false;
        
        try {
            const cachedData = localStorage.getItem(DATE_FILTER_CACHE_KEY);
            if (cachedData) {
                const data = JSON.parse(cachedData);
                
                // Ki·ªÉm tra cache c√≥ h·ª£p l·ªá kh√¥ng (kh√¥ng qu√° 7 ng√†y)
                const cacheAge = Date.now() - data.timestamp;
                const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 ng√†y
                
                if (cacheAge < maxAge && data.fromDate && data.toDate) {
                    fromDateInput.value = data.fromDate;
                    toDateInput.value = data.toDate;
                    return true;
                }
            }
        } catch (error) {
            console.error('L·ªói khi load cache filter ng√†y:', error);
        }
        
        return false;
    }
    
    /**
     * Set gi√° tr·ªã m·∫∑c ƒë·ªãnh cho filter ng√†y
     */
    function setDefaultDateFilter() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (fromDateInput && toDateInput) {
            // Th·ª≠ load t·ª´ cache tr∆∞·ªõc
            const cacheLoaded = loadDateFilterFromCache();
            
            // N·∫øu kh√¥ng c√≥ cache, set gi√° tr·ªã m·∫∑c ƒë·ªãnh
            if (!cacheLoaded) {
                const today = new Date();
                const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
                
                fromDateInput.value = oneWeekAgo.toISOString().split('T')[0];
                toDateInput.value = today.toISOString().split('T')[0];
            }
        }
    }
    
    /**
     * Reset filter ng√†y v·ªÅ gi√° tr·ªã m·∫∑c ƒë·ªãnh v√† x√≥a cache
     */
    function resetDateFilter() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (fromDateInput && toDateInput) {
            // X√≥a cache
            localStorage.removeItem(DATE_FILTER_CACHE_KEY);
            
            // Set gi√° tr·ªã m·∫∑c ƒë·ªãnh
            const today = new Date();
            const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
            
            fromDateInput.value = oneWeekAgo.toISOString().split('T')[0];
            toDateInput.value = today.toISOString().split('T')[0];
            
            // Reload d·ªØ li·ªáu
            refreshData();
            
            showNotification('ƒê√£ reset filter ng√†y v·ªÅ m·∫∑c ƒë·ªãnh', 'info');
        }
    }

    /**
     * T·∫£i d·ªØ li·ªáu v·ªõi filter ng√†y c·ª• th·ªÉ
     */
    async function loadDataWithDateFilter() {
        const fromDateFilter = document.getElementById('fromDateFilter')?.value;
        const toDateFilter = document.getElementById('toDateFilter')?.value;
        
        if (!fromDateFilter || !toDateFilter) {
            showNotification('Vui l√≤ng ch·ªçn c·∫£ ng√†y b·∫Øt ƒë·∫ßu v√† ng√†y k·∫øt th√∫c', 'warning');
            return;
        }
        
        if (fromDateFilter > toDateFilter) {
            showNotification('Ng√†y b·∫Øt ƒë·∫ßu kh√¥ng th·ªÉ l·ªõn h∆°n ng√†y k·∫øt th√∫c', 'warning');
            return;
        }
        
        showLoading('ƒêang t·∫£i d·ªØ li·ªáu theo kho·∫£ng ng√†y...');
        await loadOrdersData();
        hideLoading();
        showNotification(`ƒê√£ t·∫£i d·ªØ li·ªáu t·ª´ ${fromDateFilter} ƒë·∫øn ${toDateFilter}`, 'success');
    }

    /**
     * T·∫£i d·ªØ li·ªáu l·ªánh s·∫£n xu·∫•t t·ª´ API
     */
    async function loadOrdersData() {
        const timingKey = 'loadOrdersData';
        try {
            // Load d·ªØ li·ªáu m√°y tr∆∞·ªõc
            await loadMachineStatus();
            // Load d·ªØ li·ªáu theo ng√†y t·ª´ filter ho·∫∑c m·∫∑c ƒë·ªãnh 30 ng√†y tr∆∞·ªõc
            const fromDateFilter = document.getElementById('fromDateFilter')?.value;
            const toDateFilter = document.getElementById('toDateFilter')?.value;
            
            // Th√™m event listener cho filter ng√†y
            const fromDateInput = document.getElementById('fromDateFilter');
            const toDateInput = document.getElementById('toDateFilter');
            if (fromDateInput && toDateInput) {
                // Set gi√° tr·ªã m·∫∑c ƒë·ªãnh: t·ª´ 1 tu·∫ßn tr∆∞·ªõc ƒë·∫øn h√¥m nay
                if (!fromDateInput.value && !toDateInput.value) {
                    const today = new Date();
                    const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
                    fromDateInput.value = oneWeekAgo.toISOString().split('T')[0];
                    toDateInput.value = today.toISOString().split('T')[0];
                }
                
                fromDateInput.addEventListener('change', () => {
                    // L∆∞u cache khi thay ƒë·ªïi ng√†y
                    saveDateFilterToCache();
                    
                    if (fromDateInput.value && toDateInput.value) {
                        refreshData(); // Reload d·ªØ li·ªáu khi c√≥ ƒë·ªß c·∫£ 2 ng√†y
                    }
                });
                toDateInput.addEventListener('change', () => {
                    // L∆∞u cache khi thay ƒë·ªïi ng√†y
                    saveDateFilterToCache();
                    
                    if (fromDateInput.value && toDateInput.value) {
                        refreshData(); // Reload d·ªØ li·ªáu khi c√≥ ƒë·ªß c·∫£ 2 ng√†y
                    }
                });
            }
            
            let fromDate, toDate;
            if (fromDateFilter && toDateFilter) {
                // S·ª≠ d·ª•ng ng√†y t·ª´ filter
                fromDate = fromDateFilter;
                toDate = toDateFilter;
            } else {
                // M·∫∑c ƒë·ªãnh 1 tu·∫ßn tr∆∞·ªõc ƒë·∫øn hi·ªán t·∫°i
                const today = new Date();
                const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
                fromDate = oneWeekAgo.toISOString().split('T')[0];
                toDate = today.toISOString().split('T')[0];
            }
            
            // S·ª≠ d·ª•ng date range thay v√¨ limit ƒë·ªÉ tr√°nh qu√° t·∫£i
            const url = `${API_BASE_URL}/data/production_orders?stage=${STAGE_CONFIG.KEY}&from_date=${fromDate}&to_date=${toDate}`;
            
            // G·ªçi API ƒë·ªÉ l·∫•y t·∫•t c·∫£ d·ªØ li·ªáu
            const response = await fetchWithRetry(url, {}, 3);
            const apiData = await response.json();
            
            // Ki·ªÉm tra d·ªØ li·ªáu raw t·ª´ API
            if (apiData.length > 0) {
                // Log c√°c m·∫´u ƒë·ªÉ ki·ªÉm tra start_time
                apiData.slice(0, 3).forEach((record, idx) => {
                    // Sample data logging removed
                });
                
                // ƒê·∫øm s·ªë b·∫£n ghi c√≥ start_time
                const recordsWithStartTime = apiData.filter(r => getOrderField(r, 'start_time')).length;
            }
            
            const allData = Array.isArray(apiData) ? apiData : [];
            ordersData = transformApiData(allData);
            
            // Ki·ªÉm tra d·ªØ li·ªáu sau khi transform v√† l·ªçc
            if (ordersData.length > 0) {
                // Log c√°c m·∫´u ƒë·ªÉ ki·ªÉm tra start_time
                ordersData.slice(0, 3).forEach((record, idx) => {
                    // Sample transformed data logging removed
                });
                
                // ƒê·∫øm s·ªë b·∫£n ghi c√≥ start_time
                const recordsWithStartTime = ordersData.filter(r => getOrderField(r, 'start_time')).length;
            }
            
            // L∆∞u d·ªØ li·ªáu g·ªëc cho filtering
            originalOrdersData = [...ordersData];
            filteredOrdersData = [...ordersData];
            
            // Log sample data ƒë·ªÉ debug
            if (ordersData.length > 0) {
                // Sample orders data logging removed
            }
        } catch (error) {
            ordersData = [];
            showNotification('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu: ' + error.message, 'error');
        }
    }

    /**
     * Transform API data
     */
    function transformApiData(apiData) {
        if (!Array.isArray(apiData)) {
            return [];
        }

        const transformedData = [];
        
        for (let i = 0; i < apiData.length; i++) {
            transformedData[i] = transformOrder(apiData[i]);
        }
        
        return transformedData;
    }

    /**
     * Transform m·ªôt order
     */
    function transformOrder(order) {
        let workflowDef = order.workflow_definition;
        
        // Log d·ªØ li·ªáu th√¥ t·ª´ API ƒë·ªÉ debug
        
        if (getOrderField(order, 'start_time')) {
            // API Data logging removed
        }
        
        const nextStage = getNextStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY);
        
        // T·∫°o ƒë·ªëi t∆∞·ª£ng k·∫øt qu·∫£
        const transformedOrder = {
            id: order.id || order.order_id || order.production_order_id,
            production_order: order.order_code || order.production_order,
            order_type: order.order_type || '', // Th√™m tr∆∞·ªùng lo·∫°i LSX
            product_name: order.product_name,
            internal_product_code: order.internal_product_code,
            customer_name: order.customer_name,
            total_quantity: order.quantity || order.total_quantity,
            deployed_quantity: order.deployed_quantity || 0, // Th√™m deployed_quantity
            sheet_count: order.sheet_count || 0, // Th√™m sheet_count
            [getFieldName('input_quantity')]: order.quantity || order.total_quantity || 0,
            [getFieldName('output_quantity')]: getOrderField(order, 'output_quantity'),
            [getFieldName('good_quantity')]: getOrderField(order, 'good_quantity'),
            [getFieldName('ng_quantity')]: getOrderField(order, 'ng_quantity'),
            [getFieldName('handover_quantity')]: getOrderField(order, 'handover_quantity'),
            [getFieldName('status')]: getOrderField(order, 'status') || 'waiting',
            [getFieldName('machine_name')]: getOrderField(order, 'machine_name'),
            [getFieldName('worker_name')]: getOrderField(order, 'worker_name'),
            [getFieldName('note')]: getOrderField(order, 'note') || order.notes || '',
            [getFieldName('start_time')]: getOrderField(order, 'start_time'),
            [getFieldName('end_time')]: getOrderField(order, 'end_time'),
            paper_type: order.paper_type || '',
            paper_weight: order.paper_weight || 0,
            paper_length: order.paper_length  || 0,
            paper_width: order.paper_width  || 0,
            blank_count: order.blank_count|| 0, // S·ªë ph√¥i
            [getFieldName('shift')]: getOrderField(order, 'shift'),
            delivery_date: order.delivery_date,
            deployment_date: order.deployment_date || order.created_at,
            assigned_machine: order.assigned_machine || '', // Th√™m tr∆∞·ªùng assigned_machine
            workflow_definition: workflowDef,
            next_stage: nextStage,
            previous_stage: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY),
            
            // D·ªØ li·ªáu t·ª´ stage tr∆∞·ªõc
            previous_stage_good_quantity: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_good_quantity`] || 0) : 0,
            previous_stage_ng_quantity: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_ng_quantity`] || 0) : 0,
            previous_stage_handover_quantity: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_handover_quantity`] || 0) : 0,
            previous_stage_status: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_status`] || 'waiting') : null,
            previous_stage_worker_name: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_worker_name`] || '') : '',
            previous_stage_machine_name: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_machine_name`] || '') : '',
            previous_stage_start_time: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_start_time`] || null) : null,
            previous_stage_end_time: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_end_time`] || null) : null,
            
            // D·ªØ li·ªáu t·ª´ stage ti·∫øp theo
            next_stage_good_quantity: nextStage ? (order[`${nextStage}_good_quantity`] || 0) : 0,
            next_stage_ng_quantity: nextStage ? (order[`${nextStage}_ng_quantity`] || 0) : 0,
            next_stage_handover_quantity: nextStage ? (order[`${nextStage}_handover_quantity`] || 0) : 0,
            next_stage_status: nextStage ? (order[`${nextStage}_status`] || 'waiting') : null,
            next_stage_worker_name: nextStage ? (order[`${nextStage}_worker_name`] || '') : '',
            next_stage_machine_name: nextStage ? (order[`${nextStage}_machine_name`] || '') : '',
            next_stage_start_time: nextStage ? (order[`${nextStage}_start_time`] || null) : null,
            next_stage_end_time: nextStage ? (order[`${nextStage}_end_time`] || null) : null,
            
            created_at: order.created_at,
            updated_at: order.updated_at
        };
        
        // Log d·ªØ li·ªáu sau khi transform ƒë·ªÉ debug
        if (transformedOrder[getFieldName('start_time')]) {
            // Transformed data logging removed
        }
        
        return transformedOrder;
    }

    /**
     * =================================================================
     * WORKFLOW FUNCTIONS - H√ÄM X·ª¨ L√ù WORKFLOW
     * =================================================================
     */

    /**
     * L·∫•y stage ti·∫øp theo t·ª´ workflow definition
     * @param {string} workflowDef - Workflow definition (VD: "xa,xen,in" ho·∫∑c "xa,in_offset")
     * @param {string} currentStage - Stage hi·ªán t·∫°i
     * @returns {string|null} Stage ti·∫øp theo ho·∫∑c null n·∫øu l√† stage cu·ªëi
     */
    function getNextStageFromWorkflow(workflowDef, currentStage) {
        if (!workflowDef) {
            return null;
        }
        
        const stages = workflowDef.split(',').map(s => s.trim());
        const currentIndex = stages.indexOf(currentStage);
        
        if (currentIndex === -1 || currentIndex >= stages.length - 1) {
            return null; // Kh√¥ng t√¨m th·∫•y ho·∫∑c ƒë√£ l√† stage cu·ªëi
        }
        
        const nextStage = stages[currentIndex + 1];
        return nextStage;
    }

    /**
     * L·∫•y stage tr∆∞·ªõc ƒë√≥ t·ª´ workflow
     * @param {string} workflowDef - ƒê·ªãnh nghƒ©a workflow
     * @param {string} currentStage - Stage hi·ªán t·∫°i
     * @returns {string|null} Stage tr∆∞·ªõc ƒë√≥ ho·∫∑c null n·∫øu l√† stage ƒë·∫ßu
     */
    function getPreviousStageFromWorkflow(workflowDef, currentStage) {
        if (!workflowDef) {
            return null;
        }
        
        const stages = workflowDef.split(',').map(s => s.trim());
        const currentIndex = stages.indexOf(currentStage);
        
        if (currentIndex === -1 || currentIndex <= 0) {
            return null; // Kh√¥ng t√¨m th·∫•y ho·∫∑c ƒë√£ l√† stage ƒë·∫ßu
        }
        
        const previousStage = stages[currentIndex - 1];
        return previousStage;
    }

    /**
     * L·∫•y t√™n hi·ªÉn th·ªã c·ªßa stage
     * @param {string} stageKey - Key c·ªßa stage
     * @returns {string} T√™n hi·ªÉn th·ªã
     */
    function getStageDisplayName(stageKey) {
        const stageNames = {
            'xa': 'X·∫£',
            'xen': 'X√©n', 
            'in_offset': 'In Offset',
            'boi': 'B·ªìi',
            'be': 'B·∫ø',
            'dan': 'D√°n',
            'kho': 'Kho'
        };
        
        return stageNames[stageKey] || stageKey.toUpperCase();
    }

    /**
     * L·∫•y m√†u s·∫Øc theo stage
     * @param {string} stageKey - Key c·ªßa stage
     * @returns {string} CSS class m√†u s·∫Øc
     */
    function getStageColor(stageKey) {
        const stageColors = {
            'xa': 'primary',
            'xen': 'success',
            'in_offset': 'purple',
            'boi': 'warning',
            'be': 'danger',
            'dan': 'dark',
            'kho': 'secondary'
        };
        
        return stageColors[stageKey] || 'secondary';
    }

        

    /**
     * =================================================================
     * KH·ªûI T·∫†O TRANG - PAGE INITIALIZATION
     * =================================================================
     */
    
    // Kh·ªüi t·∫°o khi trang ƒë∆∞·ª£c load
    document.addEventListener('DOMContentLoaded', function() {
        initializePage();
    });

    /**
     * Kh·ªüi t·∫°o trang - load d·ªØ li·ªáu v√† setup UI
     */
    async function initializePage() {

        
        try {
            showLoading('ƒêang t·∫£i d·ªØ li·ªáu...');
            
            // Set gi√° tr·ªã m·∫∑c ƒë·ªãnh cho filter ng√†y
            setDefaultDateFilter();
            
            // T·∫£i d·ªØ li·ªáu t·ª´ API
            await loadOrdersData();
            await loadMachineStatus();
            
            // Kh·ªüi t·∫°o tabs tr∆∞·ªõc khi render
            await initializeTabs();
            
            // C·∫≠p nh·∫≠t filter options sau khi c√≥ d·ªØ li·ªáu m√°y
            updateMachineFilterOptions();
            
            // Render giao di·ªán
            renderOrdersTable();
            updateStatistics();
            
            // Kh·ªüi t·∫°o filters
            setupFilterChangeListeners();
            setupSearchDebounce();
            
            // Log t·ªïng th·ªùi gian
            // logTotalLoadTime();
            
            // showNotification('ƒê√£ t·∫£i d·ªØ li·ªáu th√†nh c√¥ng', 'success');
            
        } catch (error) {
            showNotification('L·ªói t·∫£i d·ªØ li·ªáu: ' + error.message, 'error');
            
   
            
            renderOrdersTable();
            updateStatistics();
        } finally {
            hideLoading();
        }
    }

    

    /**
     * Render b·∫£ng danh s√°ch l·ªánh s·∫£n xu·∫•t v·ªõi tab structure
     */
    function renderOrdersTable() {
        // Ki·ªÉm tra c√≥ d·ªØ li·ªáu kh√¥ng
        if (ordersData.length === 0) {
            // Hi·ªÉn th·ªã th√¥ng b√°o tr·ªëng cho t·∫•t c·∫£ c√°c tab
            const emptyMessage = `
                <tr>
                    <td colspan="13" class="text-center text-muted py-4">
                        <i class="bi bi-inbox fs-1 mb-2 d-block"></i>
                        Kh√¥ng c√≥ l·ªánh s·∫£n xu·∫•t n√†o cho c√¥ng ƒëo·∫°n ${STAGE_CONFIG.NAME}
                    </td>
                </tr>
            `;
            
            // L·∫•y t·∫•t c·∫£ c√°c tab body ƒë√£ ƒë∆∞·ª£c t·∫°o ƒë·ªông
            const tabBodies = document.querySelectorAll('[id$="TableBody"]');
            tabBodies.forEach(tbody => {
                tbody.innerHTML = emptyMessage;
            });
            
            // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho c√°c tab
            updateTabCountsDynamic();
            return;
        }
        
        // L·ªçc c√°c m√°y thu·ªôc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Ph√¢n lo·∫°i d·ªØ li·ªáu theo m√°y (hi·ªÉn th·ªã t·∫•t c·∫£ l·ªánh ch∆∞a b√†n giao, k·ªÉ c·∫£ ch∆∞a s·∫µn s√†ng)
        const machineOrders = {};
        MStageMachines.forEach(machine => {
            const machineName = machine.machine_name;
            machineOrders[machineName] = ordersData.filter(order => {
                const assignedMachine = order.assigned_machine || '';
                const inputQuantity = getInputQuantityFromPreviousStage(order);
                
                // T√≠nh t·ªïng s·ªë l∆∞·ª£ng b√†n giao v√† input
                const previousStageHandover = order.previous_stage_handover_quantity || 0;
                const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
                const currentStageInput = getOrderField(order, 'input_quantity') || 0;
                
 
                
                return assignedMachine.includes(machineName);
            });
        });
        
        // Render t·ª´ng tab m√°y
        MStageMachines.forEach(machine => {
            const machineName = machine.machine_name;
            const machineId = `machine-${machineName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            const tableBodyId = `${machineId}TableBody`;
            renderTabTable(tableBodyId, machineOrders[machineName] || []);
        });
        
        // Render tab "T·∫•t c·∫£" (hi·ªÉn th·ªã t·∫•t c·∫£ l·ªánh, k·ªÉ c·∫£ ƒë√£ ho√†n th√†nh)
        const activeOrders = ordersData.filter(order => {
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // T√≠nh t·ªïng s·ªë l∆∞·ª£ng b√†n giao v√† input
            const previousStageHandover = order.previous_stage_handover_quantity || 0;
            const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
            const currentStageInput = getOrderField(order, 'input_quantity') || 0;
            

            
            return true; // Hi·ªÉn th·ªã t·∫•t c·∫£ l·ªánh
        });
        renderTabTable('allTableBody', activeOrders);
        
        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho c√°c tab
        updateTabCountsDynamic(machineOrders);
        
        // Load d·ªØ li·ªáu b√°o c√°o
        loadReportData();
    }
    

    
    /**
     * Render b·∫£ng cho m·ªôt tab c·ª• th·ªÉ
     */
    function renderTabTable(tableBodyId, orders) {
        const tableBody = document.getElementById(tableBodyId);
        if (!tableBody) {
            console.error(`Table body not found: ${tableBodyId}`);
            return;
        }
        
        // X√≥a d·ªØ li·ªáu c≈©
        tableBody.innerHTML = '';
        
        // Ki·ªÉm tra c√≥ d·ªØ li·ªáu kh√¥ng
        if (orders.length === 0) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="13" class="text-center text-muted py-4">
                        <i class="bi bi-inbox fs-1 mb-2 d-block"></i>
                        Kh√¥ng c√≥ l·ªánh s·∫£n xu·∫•t n√†o
                    </td>
                </tr>
            `;
            return;
        }

        // S·∫Øp x·∫øp orders: l·ªánh s·∫µn s√†ng l√™n ƒë·∫ßu, sau ƒë√≥ l·ªánh b·ªã disable, cu·ªëi c√πng theo th·ªùi gian b·∫Øt ƒë·∫ßu
        const sortedOrders = [...orders].sort((a, b) => {
            // Ki·ªÉm tra l·ªánh n√†o ƒëang ch·∫°y
            const aIsRunning = isOrderRunning(a).isRunning;
            const bIsRunning = isOrderRunning(b).isRunning;
            
            // Ki·ªÉm tra l·ªánh n√†o s·∫µn s√†ng (kh√¥ng b·ªã disable)
            const aIsReady = isPreviousStageReady(a) && getOrderMachine(a);
            const bIsReady = isPreviousStageReady(b) && getOrderMachine(b);
            
            // ∆Øu ti√™n 1: L·ªánh ƒëang ch·∫°y
            if (aIsRunning && !bIsRunning) return -1;
            if (!aIsRunning && bIsRunning) return 1;
            
            // ∆Øu ti√™n 2: L·ªánh s·∫µn s√†ng (kh√¥ng b·ªã disable) l√™n ƒë·∫ßu
            if (aIsReady && !bIsReady) return -1;
            if (!aIsReady && bIsReady) return 1;
            
            // ∆Øu ti√™n 3: N·∫øu c·∫£ hai ƒë·ªÅu s·∫µn s√†ng ho·∫∑c ƒë·ªÅu kh√¥ng s·∫µn s√†ng, s·∫Øp x·∫øp theo th·ªùi gian b·∫Øt ƒë·∫ßu
            const aStartTime = getOrderField(a, 'start_time') ? new Date(getOrderField(a, 'start_time')).getTime() : 0;
            const bStartTime = getOrderField(b, 'start_time') ? new Date(getOrderField(b, 'start_time')).getTime() : 0;
            
            // L·ªánh b·∫Øt ƒë·∫ßu s·ªõm h∆°n l√™n ƒë·∫ßu (th·ªùi gian l·ªõn h∆°n = m·ªõi h∆°n)
            return bStartTime - aStartTime;
        });

        
        const fragment = document.createDocumentFragment();
        
        sortedOrders.forEach((order, index) => {
            try {
                const row = createOrderTableRow(order, index);
                fragment.appendChild(row);
            } catch (error) {
                console.error(`Error creating row for order ${order.id}:`, error);
                // Create a simple error row
                const errorRow = document.createElement('tr');
                errorRow.innerHTML = `
                    <td colspan="13" class="text-center text-danger">
                        L·ªói hi·ªÉn th·ªã l·ªánh ${order.id || 'N/A'}
                    </td>
                `;
                fragment.appendChild(errorRow);
            }
        });
        
        tableBody.appendChild(fragment);
    }
    
    /**
     * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng hi·ªÉn th·ªã tr√™n c√°c tab ƒë·ªông
     */
    function updateTabCountsDynamic(machineOrders = {}) {
        // L·ªçc c√°c m√°y thu·ªôc Stage hi·ªán t·∫°i
        const stageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho t·ª´ng m√°y
        stageMachines.forEach(machine => {
            const machineName = machine.machine_name;
            const machineId = `machine-${machineName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            const countElement = document.getElementById(`${machineId}-count`);
            if (countElement) {
                const orderCount = machineOrders[machineName] ? machineOrders[machineName].length : 0;
                countElement.textContent = orderCount;
            }
        });
        
        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho tab "T·∫•t c·∫£" (ch·ªâ l·ªánh ch∆∞a b√†n giao)
        const allCountElement = document.getElementById('all-count');
        if (allCountElement) {
            const activeOrders = ordersData.filter(order => {
                const inputQuantity = getInputQuantityFromPreviousStage(order);
                return inputQuantity > 0;
            });
            allCountElement.textContent = activeOrders.length;
        }
        
        // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng cho tab "B√°o c√°o"
        const handedOverOrders = ordersData.filter(order => {
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // T√≠nh t·ªïng s·ªë l∆∞·ª£ng b√†n giao v√† input
            const previousStageHandover = order.previous_stage_handover_quantity || 0;
            const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
            const currentStageInput = getOrderField(order, 'input_quantity') || 0;

            
            return inputQuantity <= 0 && previousStageHandover > 0;
        });
        updateReportCount(handedOverOrders.length);
    }


    /**
     * Kh·ªüi t·∫°o tab functionality
     */
    async function initializeTabs() {
        // T·∫£i d·ªØ li·ªáu m√°y t·ª´ API
        await loadMachineStatus();
        
        // T·∫°o c√°c tab ƒë·ªông d·ª±a tr√™n d·ªØ li·ªáu m√°y
        await createDynamicTabs();
        
        // Th√™m event listeners cho c√°c tab
        const tabs = document.querySelectorAll('#machineTabs .nav-link');
        tabs.forEach(tab => {
            tab.addEventListener('click', function(e) {
                // C·∫≠p nh·∫≠t active state
                tabs.forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // Hi·ªÉn th·ªã tab content t∆∞∆°ng ·ª©ng
                const targetId = this.getAttribute('data-bs-target');
                const targetContent = document.querySelector(targetId);
                
                if (targetContent) {
                    document.querySelectorAll('.tab-pane').forEach(pane => {
                        pane.classList.remove('show', 'active');
                    });
                    targetContent.classList.add('show', 'active');
                }
                
                // N·∫øu click v√†o tab b√°o c√°o, load d·ªØ li·ªáu b√°o c√°o
                if (targetId === '#report-content') {
                    loadReportData();
                }
                
                // C·∫≠p nh·∫≠t URL hash ƒë·ªÉ bookmark
                window.location.hash = targetId.replace('#', '');
            });
        });
        
        // Kh√¥i ph·ª•c tab t·ª´ URL hash n·∫øu c√≥
        const hash = window.location.hash;
        if (hash) {
            const targetTab = document.querySelector(`[data-bs-target="${hash}"]`);
            if (targetTab) {
                // X√≥a active class t·ª´ t·∫•t c·∫£ tabs v√† content
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                    link.setAttribute('aria-selected', 'false');
                });
                document.querySelectorAll('.tab-pane').forEach(pane => {
                    pane.classList.remove('show', 'active');
                });
                
                // K√≠ch ho·∫°t tab ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
                targetTab.classList.add('active');
                targetTab.setAttribute('aria-selected', 'true');
                
                const targetContent = document.querySelector(hash);
                if (targetContent) {
                    targetContent.classList.add('show', 'active');
                }
            }
        }
    }
    
    /**
     * T·∫°o c√°c tab ƒë·ªông d·ª±a tr√™n d·ªØ li·ªáu m√°y t·ª´ production_machines
     */
    async function createDynamicTabs() {
        const machineTabsContainer = document.getElementById('machineTabs');
        const tabContentContainer = document.getElementById('machineTabContent');
        
        console.log('üîç Creating dynamic tabs for stage:', STAGE_CONFIG.KEY);
        console.log('üîç Available machines:', machineStatusData);
        
        // L∆∞u tab "B√°o c√°o" n·∫øu c√≥
        const reportTab = machineTabsContainer.querySelector('#report-tab');
        const reportContent = tabContentContainer.querySelector('#report-content');
        
        // X√≥a n·ªôi dung c≈© (nh∆∞ng gi·ªØ l·∫°i tab "B√°o c√°o")
        machineTabsContainer.innerHTML = '';
        tabContentContainer.innerHTML = '';
        
        // L·ªçc c√°c m√°y thu·ªôc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        console.log('üîç Filtered machines for stage:', MStageMachines);
        
        // T·∫°o tab cho t·ª´ng m√°y ${STAGE_CONFIG.NAME}
        MStageMachines.forEach((machine, index) => {
            const machineName = machine.machine_name;
            // T·∫°o ID an to√†n cho CSS selector (kh√¥ng b·∫Øt ƒë·∫ßu b·∫±ng s·ªë)
            const machineId = `machine-${machineName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            const tabId = `${machineId}-tab`;
            const contentId = `${machineId}-content`;
            
            // T·∫°o tab navigation
            const tabItem = document.createElement('li');
            tabItem.className = 'nav-item';
            tabItem.setAttribute('role', 'presentation');
            
            const isFirstTab = index === 0;
            tabItem.innerHTML = `
                <button class="nav-link ${isFirstTab ? 'active' : ''}" id="${tabId}" 
                        data-bs-toggle="tab" data-bs-target="#${contentId}" 
                        type="button" role="tab" aria-controls="${contentId}" 
                        aria-selected="${isFirstTab}">
                    <i class="bi bi-gear me-1"></i>${machineName}
                    <!-- <span class="badge bg-primary ms-1" id="${machineId}-count">0</span> -->
                </button>
            `;
            
            machineTabsContainer.appendChild(tabItem);
            
            // T·∫°o tab content
            const tabPane = document.createElement('div');
            tabPane.className = `tab-pane fade ${isFirstTab ? 'show active' : ''}`;
            tabPane.id = contentId;
            tabPane.setAttribute('role', 'tabpanel');
            tabPane.setAttribute('aria-labelledby', tabId);
            
            tabPane.innerHTML = `
                <div class="table-container">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th style="width: 40px!important; min-width: 40px!important;" class="text-center">#</th>
                                <th style="width: 150px!important; min-width: 120px!important;" class="text-center">L·ªánh SX</th>
                                <th style="width: 70px!important; min-width: 50px!important;" class="text-center">Lo·∫°i LSX</th>
                                <th style="width: 260px!important; min-width: 150px!important;" class="text-center">S·∫£n ph·∫©m</th>
                                <th style="width: 130px!important; min-width: 130px!important;" class="text-center">Lo·∫°i gi·∫•y</th>
                                <th style="width: 90px!important; min-width: 90px!important;" class="text-center">ƒê·ªãnh l∆∞·ª£ng</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">K·∫ø ho·∫°ch</th>
                                <th style="width: 150px!important; min-width: 150px!important;" class="text-center">Tri·ªÉn khai</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT x·∫£</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT x·∫£</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">S·ªë ph√¥i</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Ti·∫øn ƒë·ªô</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">M√°y/Th·ª£</th>
                            </tr>
                        </thead>
                        <tbody id="${machineId}TableBody">
                        </tbody>
                    </table>
                </div>
            `;
            
            tabContentContainer.appendChild(tabPane);
        });
        
        // Th√™m tab "T·∫•t c·∫£" ·ªü cu·ªëi
        const allTabItem = document.createElement('li');
        allTabItem.className = 'nav-item';
        allTabItem.setAttribute('role', 'presentation');
        
        // N·∫øu kh√¥ng c√≥ m√°y n√†o, "T·∫•t c·∫£" tab s·∫Ω l√† active m·∫∑c ƒë·ªãnh
        const isAllTabActive = MStageMachines.length === 0;
        
        allTabItem.innerHTML = `
            <button class="nav-link ${isAllTabActive ? 'active' : ''}" id="all-tab" 
                    data-bs-toggle="tab" data-bs-target="#all-content" 
                    type="button" role="tab" aria-controls="all-content" 
                    aria-selected="${isAllTabActive}">
                <i class="bi bi-list-ul me-1"></i>T·∫•t c·∫£
                <span class="badge bg-secondary ms-1" id="all-count">0</span>
            </button>
        `;
        
        machineTabsContainer.appendChild(allTabItem);
        
        // Th√™m content cho tab "T·∫•t c·∫£"
        const allTabPane = document.createElement('div');
        allTabPane.className = `tab-pane fade ${isAllTabActive ? 'show active' : ''}`;
        allTabPane.id = 'all-content';
        allTabPane.setAttribute('role', 'tabpanel');
        allTabPane.setAttribute('aria-labelledby', 'all-tab');
        
        allTabPane.innerHTML = `
            <div class="table-container">
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            <th style="width: 40px!important; min-width: 40px!important;" class="text-center">#</th>
                            <th style="width: 150px!important; min-width: 120px!important;" class="text-center">L·ªánh SX</th>
                            <th style="width: 70px!important; min-width: 50px!important;" class="text-center">Lo·∫°i LSX</th>
                            <th style="width: 260px!important; min-width: 150px!important;" class="text-center">S·∫£n ph·∫©m</th>
                            <th style="width: 130px!important; min-width: 130px!important;" class="text-center">Lo·∫°i gi·∫•y</th>
                            <th style="width: 90px!important; min-width: 90px!important;" class="text-center">ƒê·ªãnh l∆∞·ª£ng</th>
                            <th style="width: 100px!important; min-width: 100px!important;" class="text-center">K·∫ø ho·∫°ch</th>
                            <th style="width: 150px!important; min-width: 150px!important;" class="text-center">Tri·ªÉn khai</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT ${STAGE_CONFIG.KEY}</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT ${STAGE_CONFIG.KEY}</th>
                            <th style="width: 100px!important; min-width: 100px!important;" class="text-center">S·ªë ph√¥i</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Ti·∫øn ƒë·ªô</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">M√°y/Th·ª£</th>
                        </tr>
                    </thead>
                    <tbody id="allTableBody">
                    </tbody>
                </table>
            </div>
        `;
        
        tabContentContainer.appendChild(allTabPane);
        
        // Th√™m l·∫°i tab "B√°o c√°o" n·∫øu c√≥
        if (reportTab) {
            machineTabsContainer.appendChild(reportTab);
        } else {
            // T·∫°o tab "B√°o c√°o" n·∫øu ch∆∞a c√≥
            const reportTabItem = document.createElement('li');
            reportTabItem.className = 'nav-item';
            reportTabItem.setAttribute('role', 'presentation');
            
            reportTabItem.innerHTML = `
                <button class="nav-link" id="report-tab" 
                        data-bs-toggle="tab" data-bs-target="#report-content" 
                        type="button" role="tab" aria-controls="report-content" 
                        aria-selected="false">
                    <i class="bi bi-file-earmark-text me-1"></i>B√°o c√°o
                    <span class="badge bg-info ms-1" id="report-count">0</span>
                </button>
            `;
            
            machineTabsContainer.appendChild(reportTabItem);
        }
        
        if (reportContent) {
            tabContentContainer.appendChild(reportContent);
        } else {
            // T·∫°o content cho tab "B√°o c√°o" n·∫øu ch∆∞a c√≥
            const reportTabPane = document.createElement('div');
            reportTabPane.className = 'tab-pane fade';
            reportTabPane.id = 'report-content';
            reportTabPane.setAttribute('role', 'tabpanel');
            reportTabPane.setAttribute('aria-labelledby', 'report-tab');
            
            reportTabPane.innerHTML = `
                <div class="table-container">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th style="width: 40px!important; min-width: 40px!important;" class="text-center">#</th>
                                <th style="width: 150px!important; min-width: 120px!important;" class="text-center">L·ªánh SX</th>
                                <th style="width: 70px!important; min-width: 50px!important;" class="text-center">Lo·∫°i LSX</th>
                                <th style="width: 260px!important; min-width: 150px!important;" class="text-center">S·∫£n ph·∫©m</th>
                                <th style="width: 130px!important; min-width: 130px!important;" class="text-center">Lo·∫°i gi·∫•y</th>
                                <th style="width: 90px!important; min-width: 90px!important;" class="text-center">ƒê·ªãnh l∆∞·ª£ng</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">K·∫ø ho·∫°ch</th>
                                <th style="width: 150px!important; min-width: 150px!important;" class="text-center">Tri·ªÉn khai</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT x·∫£</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT x·∫£</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">S·ªë ph√¥i</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Ti·∫øn ƒë·ªô</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">M√°y/Th·ª£</th>
                            </tr>
                        </thead>
                        <tbody id="reportTableBody">
                        </tbody>
                    </table>
                </div>
            `;
            
            tabContentContainer.appendChild(reportTabPane);
        }
        
        // Load d·ªØ li·ªáu b√°o c√°o ngay khi t·∫°o tab
        loadReportData();
    }

    /**
     * L·ªçc d·ªØ li·ªáu theo tab hi·ªán t·∫°i
     */
    function filterDataByCurrentTab() {
        const activeTab = document.querySelector('#machineTabs .nav-link.active');
        if (!activeTab) return ordersData;
        
        const tabId = activeTab.id;
        
        // N·∫øu l√† tab "T·∫•t c·∫£"
        if (tabId === 'all-tab') {
            return ordersData;
        }
        
        // L·∫•y t√™n m√°y t·ª´ tab ID
        const machineName = tabId.replace('-tab', '').replace(/-/g, ' ');
        
        // L·ªçc theo m√°y ƒë∆∞·ª£c g√°n
        return ordersData.filter(order => {
            const assignedMachine = order.assigned_machine || '';
            return assignedMachine.includes(machineName);
        });
    }
    
    /**
     * C·∫≠p nh·∫≠t hi·ªÉn th·ªã tab d·ª±a tr√™n filter m√°y
     */
    function updateTabBasedOnMachineFilter() {
        const machineFilter = document.getElementById('machineFilter');
        if (!machineFilter) {
            return;
        }
        if (!machineFilter.value) return;
        
        const machineValue = machineFilter.value;
        let targetTabId = 'all-tab';
        
        // L·ªçc c√°c m√°y thu·ªôc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Ki·ªÉm tra m√°y ƒë∆∞·ª£c ch·ªçn v√† chuy·ªÉn ƒë·∫øn tab t∆∞∆°ng ·ª©ng
        for (const machine of MStageMachines) {
            if (machineValue.includes(machine.machine_name)) {
                const machineId = `machine-${machine.machine_name.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                targetTabId = `${machineId}-tab`;
                break;
            }
        }
        
        const targetTab = document.getElementById(targetTabId);
        if (targetTab) {
            targetTab.click();
        }
    }
    
    /**
     * L·∫•y danh s√°ch t·∫•t c·∫£ m√°y c·ªßa stage hi·ªán t·∫°i c√≥ s·∫µn
     * @returns {Array} - M·∫£ng c√°c m√°y c·ªßa stage hi·ªán t·∫°i
     */
    function getAvailableStageMachines() {
        if (!machineStatusData || machineStatusData.length === 0) {
            return [];
        }
        
        return machineStatusData.filter(machine => 
            machine.stage_machine && 
            machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`) &&
            machine.machine_name
        ).map(machine => machine.machine_name);
    }

    /**
     * L·∫•y s·ªë l∆∞·ª£ng t·ª´ stage tr∆∞·ªõc ƒë√≥ cho b·∫•t k·ª≥ stage n√†o
     * @param {object} order - L·ªánh s·∫£n xu·∫•t
     * @param {string} currentStage - Stage hi·ªán t·∫°i (m·∫∑c ƒë·ªãnh: STAGE_CONFIG.KEY)
     * @returns {number} - S·ªë l∆∞·ª£ng t·ª´ stage tr∆∞·ªõc
     */
    function getInputQuantityFromPreviousStage(order, currentStage = STAGE_CONFIG.KEY) {
        if (!order || !order.workflow_definition) {
            return 0;
        }

        // S·ª≠ d·ª•ng function getPreviousStageFromWorkflow ƒë·ªÉ l·∫•y stage tr∆∞·ªõc
        const previousStage = getPreviousStageFromWorkflow(order.workflow_definition, currentStage);
        
        if (!previousStage) {
            // Stage hi·ªán t·∫°i l√† stage ƒë·∫ßu ti√™n ho·∫∑c kh√¥ng t√¨m th·∫•y
            // ∆Øu ti√™n sheet_count, fallback v·ªÅ quantity
            return order.sheet_count || order.quantity || 0;
        }

        // S·ª≠ d·ª•ng d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c transform s·∫µn t·ª´ previous_stage_handover_quantity
        if (order.previous_stage_handover_quantity && order.previous_stage_handover_quantity > 0) {
            return order.previous_stage_handover_quantity;
        }
        
        if (order.previous_stage_good_quantity && order.previous_stage_good_quantity > 0) {
            return order.previous_stage_good_quantity;
        }

        // Fallback v·ªÅ c√°ch c≈© n·∫øu d·ªØ li·ªáu transform ch∆∞a c√≥
        const handoverField = `${previousStage}_handover_quantity`;
        const goodField = `${previousStage}_good_quantity`;
        
        // L·∫•y s·ªë l∆∞·ª£ng t·ª´ stage tr∆∞·ªõc
        const handoverQty = order[handoverField] || 0;
        const goodQty = order[goodField] || 0;
        
        // ∆Øu ti√™n handover_quantity, fallback v·ªÅ good_quantity
        return handoverQty > 0 ? handoverQty : goodQty;
    }

    /**
     * L·∫•y t√™n m√°y t·ª´ tr∆∞·ªùng assigned_machine cho c√¥ng ƒëo·∫°n hi·ªán t·∫°i
     */
    function getStageMachineFromAssigned(assignedMachine) {
        if (!assignedMachine) return '';
        
        const machines = assignedMachine.split(',').map(m => m.trim());
        
        // L·ªçc c√°c m√°y thu·ªôc Stage hi·ªán t·∫°i
        const stageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // T√¨m m√°y c·ªßa stage hi·ªán t·∫°i trong danh s√°ch m√°y ƒë∆∞·ª£c g√°n
        for (const stageMachine of stageMachines) {
            if (machines.some(machine => machine.includes(stageMachine.machine_name))) {
                return stageMachine.machine_name;
            }
        }
        
        return '';
    }
    
    /**
     * Ki·ªÉm tra xem assigned_machine c√≥ ch·ª©a m√°y c·ªßa stage hi·ªán t·∫°i kh√¥ng
     */
    function hasStageMachine(assignedMachine) {
        if (!assignedMachine) return false;
        
        const machines = assignedMachine.split(',').map(m => m.trim());
        
        // L·ªçc c√°c m√°y thu·ªôc Stage hi·ªán t·∫°i
        const stageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Ki·ªÉm tra xem c√≥ m√°y c·ªßa stage hi·ªán t·∫°i n√†o trong danh s√°ch m√°y ƒë∆∞·ª£c g√°n
        return stageMachines.some(stageMachine => 
            machines.some(machine => machine.includes(stageMachine.machine_name))
        );
    }
    
    /**
     * Ki·ªÉm tra xem stage tr∆∞·ªõc ƒë√£ ho√†n th√†nh v√† s·∫µn s√†ng cho stage hi·ªán t·∫°i ch∆∞a
     * @param {object} order - L·ªánh s·∫£n xu·∫•t
     * @returns {boolean} - true n·∫øu stage tr∆∞·ªõc ƒë√£ ho√†n th√†nh ho·∫∑c kh√¥ng c√≥ stage tr∆∞·ªõc
     */
    function isPreviousStageReady(order) {
        if (!order.previous_stage) {
            return true; // Kh√¥ng c√≥ stage tr∆∞·ªõc = s·∫µn s√†ng
        }
        
        const previousStageStatus = order.previous_stage_status;
        const currentStageStatus = getOrderField(order, 'status');
        
        // N·∫øu stage tr∆∞·ªõc ch∆∞a ho√†n th√†nh v√† stage hi·ªán t·∫°i ch∆∞a b·∫Øt ƒë·∫ßu
        if (previousStageStatus && 
            previousStageStatus !== 'completed' && 
            previousStageStatus !== 'handed_over' && 
            currentStageStatus === 'waiting') {
            return false; // Stage tr∆∞·ªõc ch∆∞a s·∫µn s√†ng
        }
        
        return true; // Stage tr∆∞·ªõc ƒë√£ s·∫µn s√†ng
    }

    /**
     * T·∫°o m·ªôt d√≤ng trong b·∫£ng cho m·ªôt l·ªánh s·∫£n xu·∫•t
     */
    function createOrderTableRow(order, index) {
        const row = document.createElement('tr');
        row.className = 'order-row';
        row.setAttribute('data-order-id', order.id);
        
        // T√≠nh to√°n tr·∫°ng th√°i v√† ti·∫øn ƒë·ªô
        const status = getOrderField(order, 'status') || 'waiting';
        
        // L·∫•y m√°y ƒë∆∞·ª£c g√°n cho l·ªánh n√†y
        const orderMachine = getOrderMachine(order);
        
        let isDisabled = false;
        let displayReason = '';
        
        // Ki·ªÉm tra stage tr∆∞·ªõc ƒë√£ s·∫µn s√†ng ch∆∞a
        const isPreviousReady = isPreviousStageReady(order);
        
        if (!orderMachine) {
            // L·ªánh kh√¥ng ƒë∆∞·ª£c g√°n cho m√°y n√†o ‚Üí b·ªã m·ªù
            isDisabled = true;
            displayReason = `L·ªánh kh√¥ng ƒë∆∞·ª£c g√°n cho m√°y ${STAGE_CONFIG.NAME}`;
        } else {
            // Ki·ªÉm tra s·ªë l∆∞·ª£ng c·∫ßn s·∫£n xu·∫•t
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            if (inputQuantity <= 0) {
                // Kh√¥ng c√≥ s·ªë l∆∞·ª£ng t·ª´ stage tr∆∞·ªõc ‚Üí b·ªã m·ªù
                isDisabled = true;
                const previousStage = order.previous_stage;
                const previousStageName = previousStage ? getStageDisplayName(previousStage) : 'C√¥ng ƒëo·∫°n tr∆∞·ªõc';
                displayReason = `Ch·ªù ${previousStageName} cung c·∫•p s·ªë l∆∞·ª£ng`;
            } else {
                // Ki·ªÉm tra tr·∫°ng th√°i m√°y ƒë∆∞·ª£c g√°n
                const machineStatus = checkMachineStatus(orderMachine);
                
                if (!machineStatus.isRunning) {
                    // M√°y ƒëang tr·ªëng ‚Üí c√≥ th·ªÉ b·∫Øt ƒë·∫ßu
                    isDisabled = false;
                    displayReason = `M√°y ${orderMachine} ƒëang tr·ªëng`;
                } else {
                    // M√°y ƒëang ch·∫°y
                    if (machineStatus.runningOrder && machineStatus.runningOrder.current_order_id == order.id) {
                        // M√°y ƒëang ch·∫°y ch√≠nh l·ªánh n√†y ‚Üí hi·ªÉn th·ªã b√¨nh th∆∞·ªùng
                        isDisabled = false;
                        displayReason = `L·ªánh hi·ªán t·∫°i c·ªßa m√°y ${orderMachine}`;
                    } else {
                        // M√°y ƒëang ch·∫°y l·ªánh kh√°c ‚Üí b·ªã m·ªù
                        isDisabled = true;
                        displayReason = `M√°y ${orderMachine} ƒëang s·∫£n xu·∫•t l·ªánh ${machineStatus.runningOrder ? machineStatus.runningOrder.current_order_code : 'N/A'}`;
                    }
                }
            }
        }
        
        // Th√™m class t∆∞∆°ng ·ª©ng v·ªõi tr·∫°ng th√°i
        if (isDisabled) {
            row.classList.add('disabled-order');
        } else {
            // Ki·ªÉm tra xem l·ªánh c√≥ ƒëang ch·∫°y kh√¥ng
            const orderRunningCheck = isOrderRunning(order);
            if (orderRunningCheck.isRunning) {
                // L·ªánh ƒëang ch·∫°y
                row.classList.add('running-order');
            }
        }
        const inputQty = getOrderField(order, 'input_quantity') || 0;
        const sheet_count = order.sheet_count || 0; // S·ª≠a: l·∫•y s·ªë t·ªù gi·∫•y
        const goodQty = getOrderField(order, 'good_quantity') || 0;
        const ngQty = getOrderField(order, 'ng_quantity') || 0;
        const deployedQty = order.deployed_quantity || 0;
        const progressPercent = inputQty > 0 ? Math.round((goodQty / inputQty) * 100) : 0;
        
        // X√°c ƒë·ªãnh icon v√† m√†u s·∫Øc theo tr·∫°ng th√°i
        let statusIcon = 'bi-clock';
        let statusClass = 'text-warning';
        let statusText = 'Ch·ªù x·ª≠ l√Ω';
        
        switch (status) {
            case 'in_progress':
                statusIcon = 'bi-play-circle';
                statusClass = 'text-primary';
                statusText = 'ƒêang x·ª≠ l√Ω';
                break;
            case 'completed':
                statusIcon = 'bi-check-circle';
                statusClass = 'text-success';
                statusText = 'Ho√†n th√†nh';
                break;
            case 'paused':
                statusIcon = 'bi-pause-circle';
                statusClass = 'text-warning';
                statusText = 'T·∫°m d·ª´ng';
                break;
            case 'handed_over':
                statusIcon = 'bi-arrow-right-circle';
                statusClass = 'text-info';
                statusText = 'ƒê√£ b√†n giao';
                break;
        }
        
        // T·∫°o HTML cho d√≤ng
        row.innerHTML = `
            <td class="text-center">
                <span class="badge bg-light text-dark">${index + 1}</span>
            </td>

            <td>
                <div class="d-flex align-items-center">
                    <i class="bi ${statusIcon} ${statusClass} me-2"></i>
                    <div>
                        <div class="fw-bold ${isDisabled ? 'text-muted' : ''}">${order.production_order}</div>
                        <small class="text-muted">${formatDate(order.deployment_date)} - ${getOrderField(order, 'shift')}</small>
                        <small class="${isDisabled ? 'text-danger' : 'text-success'} d-block">${displayReason}</small>
                    </div>
                </div>
            </td>
            
            <td class="text-center">
                <span class="fw-bold">${order.order_type || ''}</span>
            </td>
            <td>
                <div>
                    <div class="fw-bold">${order.internal_product_code}</div>
                    <small class="text-muted" title="${order.product_name}">${truncateText(order.product_name, 100)}</small>
                </div>
            </td>
            <td class="text-center">
                <span class="badge bg-secondary">${order.paper_type || 'N/A'}</span>
            </td>
            <td class="text-center">
                <span class="fw-bold">${order.paper_weight || 0} gsm</span>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(deployedQty)}</div>
                <small class="text-muted">pcs</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-primary">${formatNumber(sheet_count)}</div>
                <small class="text-muted">t·ªù gi·∫•y</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-success">${formatNumber(order.paper_length || 0)}</div>
                <small class="text-muted">chi·ªÅu d√†i</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-danger">${formatNumber(order.paper_width || 0)}</div>
                <small class="text-muted">chi·ªÅu r·ªông</small>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(order.blank_count || 0)}</div>
                <small class="text-muted">ph√¥i</small>
            </td>
            <td class="text-center">
                <div class="progress" style="height: 20px;">
                    <div class="progress-bar ${progressPercent >= 100 ? 'bg-success' : 'bg-primary'}" 
                         style="width: ${Math.min(progressPercent, 100)}%">
                        ${progressPercent}%
                    </div>
                </div>
                <small class="text-muted">${statusText}</small>
            </td>
            <td class="text-center">
                <small class="text-muted d-block" title="${order.assigned_machine || 'Ch∆∞a g√°n'}">${truncateText(order.assigned_machine || 'Ch∆∞a g√°n', 15)}</small>
            </td>

        `;
        
        // Add data attribute for order ID
        row.setAttribute('data-order-id', order.id);
        
        // Cho ph√©p click n·∫øu l·ªánh kh√¥ng b·ªã disable
        if (!isDisabled) {
            row.style.cursor = 'pointer';
            row.onclick = (e) => {
                // NgƒÉn ch·∫∑n event bubbling ƒë·ªÉ tr√°nh ƒë√≥ng panel
                e.stopPropagation();
                showOrderDetails(order.id);
            };
        } else {
            row.style.cursor = 'not-allowed';
            row.onclick = (e) => {
                e.stopPropagation();
                showNotification(displayReason, 'warning');
            };
        }
        
        return row;
    }


    
    

 
    


    /**
     * C·∫≠p nh·∫≠t th·ªëng k√™ t·ªïng quan
     */
    function updateStatistics() {
        const totalOrders = ordersData.length;
        const totalPlan = ordersData.reduce((sum, order) => sum + (getOrderField(order, 'input_quantity') || 0), 0);
        const totalGood = ordersData.reduce((sum, order) => sum + (getOrderField(order, 'good_quantity') || 0), 0);
        const totalNg = ordersData.reduce((sum, order) => sum + (getOrderField(order, 'ng_quantity') || 0), 0);
        
        // C·∫≠p nh·∫≠t c√°c th·∫ª th·ªëng k√™
        updateElementText('totalOrders', totalOrders);
        updateElementText('totalPlan', formatNumber(totalPlan));
        updateElementText('totalGood', formatNumber(totalGood));
        updateElementText('totalNg', formatNumber(totalNg));
    }

    /**
     * =================================================================
     * X·ª¨ L√ù S·ª∞ KI·ªÜN - EVENT HANDLERS
     * =================================================================
     */


    /**
     * Setup event listeners cho wizard form
     */
    function setupWizardEventListeners() {
        // Event listeners cho c√°c input trong wizard
        const wizardGoodQty = document.getElementById('wizardGoodQty');
        const wizardNgQty = document.getElementById('wizardNgQty');
        const wizardHandoverQty = document.getElementById('wizardHandoverQty');
        
        if (wizardGoodQty) {
            wizardGoodQty.addEventListener('input', function() {
                updateWizardHandoverQuantity();
                if (wizardCurrentStep === 3) updateWizardConfirmation();
            });
        }
        
        if (wizardNgQty) {
            wizardNgQty.addEventListener('input', function() {
                updateWizardHandoverQuantity();
                if (wizardCurrentStep === 3) updateWizardConfirmation();
            });
        }
        
        if (wizardHandoverQty) {
            wizardHandoverQty.addEventListener('input', function() {
                if (wizardCurrentStep === 3) updateWizardConfirmation();
            });
        }
    }

    /**
     * L√†m m·ªõi d·ªØ li·ªáu
     */
    async function refreshData() {
        try {
            showLoading('ƒêang l√†m m·ªõi d·ªØ li·ªáu...');
            await loadOrdersData();
            renderOrdersTable();
            updateStatistics();
            // showNotification('ƒê√£ l√†m m·ªõi d·ªØ li·ªáu th√†nh c√¥ng', 'info');
        } catch (error) {

            showNotification('L·ªói l√†m m·ªõi d·ªØ li·ªáu: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }





    /**
     * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng b√†n giao khi thay ƒë·ªïi s·ªë l∆∞·ª£ng OK
     */
    function updateHandoverQuantity() {
        const goodQty = getElementValue('completeGoodQty') || 0;
        setElementValue('handoverQty', goodQty);
    }
    
    /**
     * Alias cho updateHandoverQuantity (ƒë∆∞·ª£c g·ªçi t·ª´ HTML)
     */
    function updateHandoverQty() {
        updateHandoverQuantity();
    }





    /**
     * =================================================================
     * WIZARD FUNCTIONS - C√ÅC H√ÄM X·ª¨ L√ù WIZARD FORM
     * =================================================================
     */

    let wizardCurrentStep = 1;
    const wizardTotalSteps = 3;

    /**
     * Reset wizard v·ªÅ b∆∞·ªõc 1
     */
    function resetWizard() {
        wizardCurrentStep = 1;
        updateWizardStepDisplay();
    }

    /**
     * C·∫≠p nh·∫≠t hi·ªÉn th·ªã b∆∞·ªõc wizard
     */
    function updateWizardStepDisplay() {
        // Update step indicators
        document.querySelectorAll('.step').forEach((step, index) => {
            const stepNum = index + 1;
            step.classList.remove('active', 'completed');
            
            if (stepNum < wizardCurrentStep) {
                step.classList.add('completed');
            } else if (stepNum === wizardCurrentStep) {
                step.classList.add('active');
            }
        });
        
        // Update step content
        document.querySelectorAll('.step-content').forEach((content, index) => {
            content.classList.remove('active');
            if (index + 1 === wizardCurrentStep) {
                content.classList.add('active');
            }
        });
        
        // Update buttons
        const prevBtn = document.getElementById('wizardPrevBtn');
        const nextBtn = document.getElementById('wizardNextBtn');
        const finishBtn = document.getElementById('wizardFinishBtn');
        
        prevBtn.style.display = wizardCurrentStep > 1 ? 'inline-block' : 'none';
        nextBtn.style.display = wizardCurrentStep < wizardTotalSteps ? 'inline-block' : 'none';
        finishBtn.style.display = wizardCurrentStep === wizardTotalSteps ? 'inline-block' : 'none';
        
        // Update step indicator
        document.getElementById('wizardCurrentStep').textContent = wizardCurrentStep;
        
        // Update handover quantity in step 1
        if (wizardCurrentStep === 1) {
            updateWizardHandoverQuantity();
        }
        
        // Update confirmation data in step 3
        if (wizardCurrentStep === 3) {
            updateWizardConfirmation();
        }
    }

    /**
     * Chuy·ªÉn ƒë·∫øn b∆∞·ªõc ti·∫øp theo
     */
    function wizardNextStep() {
        if (wizardCurrentStep < wizardTotalSteps) {
            // Validate current step
            if (!validateWizardCurrentStep()) {
                return;
            }
            
            wizardCurrentStep++;
            updateWizardStepDisplay();
        }
    }

    /**
     * Quay l·∫°i b∆∞·ªõc tr∆∞·ªõc
     */
    function wizardPreviousStep() {
        if (wizardCurrentStep > 1) {
            wizardCurrentStep--;
            updateWizardStepDisplay();
        }
    }

    /**
     * Validate b∆∞·ªõc hi·ªán t·∫°i
     */
    function validateWizardCurrentStep() {
        switch (wizardCurrentStep) {
            case 1:
                const goodQty = parseInt(getElementValue('wizardGoodQty')) || 0;
                const ngQty = parseInt(getElementValue('wizardNgQty')) || 0;
                if (goodQty + ngQty === 0) {
                    showNotification('T·ªïng s·ªë l∆∞·ª£ng ph·∫£i l·ªõn h∆°n 0', 'error');
                    return false;
                }
                break;
            case 2:
                const handoverQty = parseInt(getElementValue('wizardHandoverQty')) || 0;
                if (handoverQty <= 0) {
                    showNotification('S·ªë l∆∞·ª£ng b√†n giao ph·∫£i l·ªõn h∆°n 0', 'error');
                    return false;
                }
                break;
        }
        return true;
    }



    /**
     * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng b√†n giao trong wizard
     */
    function updateWizardHandoverQuantity() {
        const goodQty = parseInt(getElementValue('wizardGoodQty')) || 0;
        setElementValue('wizardHandoverQty', goodQty);
    }

    /**
     * C·∫≠p nh·∫≠t d·ªØ li·ªáu x√°c nh·∫≠n trong wizard
     */
    function updateWizardConfirmation() {
        const goodQty = parseInt(getElementValue('wizardGoodQty')) || 0;
        const ngQty = parseInt(getElementValue('wizardNgQty')) || 0;
        const handoverQty = parseInt(getElementValue('wizardHandoverQty')) || 0;
        const total = goodQty + ngQty;
        const progress = total > 0 ? Math.round((goodQty / total) * 100) : 0;
        const machine = getElementValue('wizardMachine');
        const worker = getElementValue('wizardWorker');
        const shift = getElementValue('wizardShift');
        const handoverPerson = getElementValue('wizardHandoverPerson');
        const receiverPerson = getElementValue('wizardReceiverPerson');
        const handoverNotes = getElementValue('wizardHandoverNotes');
        
        // Update confirmation data
        updateElementText('confirmOrderCode', getElementValue('wizardOrderCode'));
        updateElementText('confirmProductCode', getElementValue('wizardProductCode'));
        updateElementText('confirmProductName', getElementValue('wizardProductName'));
        updateElementText('confirmPaperType', getElementValue('wizardPaperType'));
        updateElementText('confirmPaperWeight', getElementValue('wizardPaperWeight'));
        updateElementText('confirmQuantity', getElementValue('wizardQuantity'));
        updateElementText('confirmGoodQty', goodQty.toLocaleString());
        updateElementText('confirmNgQty', ngQty.toLocaleString());
        updateElementText('confirmProgress', progress + '%');
        updateElementText('confirmMachine', machine);
        updateElementText('confirmWorker', worker || 'Ch∆∞a nh·∫≠p');
        updateElementText('confirmShift', shift || 'Ca 1');
        updateElementText('confirmHandoverQty', handoverQty.toLocaleString());
        updateElementText('confirmHandoverPerson', handoverPerson || 'Ch∆∞a nh·∫≠p');
        updateElementText('confirmReceiverPerson', receiverPerson || 'Ch∆∞a nh·∫≠p');
        updateElementText('confirmHandoverNotes', handoverNotes || 'Kh√¥ng c√≥');
    }



    /**
     * =================================================================
     * UTILITY FUNCTIONS - C√ÅC H√ÄM TI·ªÜN √çCH
     * =================================================================
     */

    // Hi·ªÉn th·ªã loading
    function showLoading(message = 'ƒêang t·∫£i...') {
        const loading = document.getElementById('loadingOverlay');
        if (loading) {
            loading.style.display = 'flex';
            const loadingText = loading.querySelector('.loading-text');
            if (loadingText) loadingText.textContent = message;
        }
    }

    // ·∫®n loading  
    function hideLoading() {
        const loading = document.getElementById('loadingOverlay');
        if (loading) loading.style.display = 'none';
    }

    // Hi·ªÉn th·ªã th√¥ng b√°o
    function showNotification(message, type = 'success') {
        // T·∫°o toast notification ƒë∆°n gi·∫£n
        const toast = document.createElement('div');
        toast.className = `alert alert-${type === 'error' ? 'danger' : type === 'warning' ? 'warning' : 'success'} position-fixed`;
        toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px; animation: fadeIn 0.3s ease;';
        toast.innerHTML = `
            <div class="d-flex align-items-center">
                <i class="bi bi-${type === 'error' ? 'exclamation-triangle' : type === 'warning' ? 'exclamation-triangle' : 'check-circle'} me-2"></i>
                <span>${message}</span>
                <button type="button" class="btn-close ms-auto" onclick="this.parentElement.parentElement.remove()"></button>
            </div>
        `;
        document.body.appendChild(toast);
        
        // T·ª± ƒë·ªông x√≥a sau 5 gi√¢y
        setTimeout(() => {
            if (toast.parentElement) {
                toast.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }
        }, 5000);
    }

    // Format s·ªë theo ƒë·ªãnh d·∫°ng Vi·ªát Nam
    function formatNumber(num) {
        if (!num && num !== 0) return '';
        return new Intl.NumberFormat('vi-VN').format(num);
    }

    // Format ng√†y
    function formatDate(date, format = 'dd/mm/yyyy') {
        if (!date) return '';
        const d = new Date(date);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        
        return format
            .replace('dd', day)
            .replace('mm', month)
            .replace('yyyy', year);
    }

    // C·∫≠p nh·∫≠t text c·ªßa element
    function updateElementText(elementId, text) {
        const element = document.getElementById(elementId);
        if (element) element.textContent = text;
    }

    // Set gi√° tr·ªã cho element
    function setElementValue(elementId, value) {
        const element = document.getElementById(elementId);
        if (element) {
            if (element.type === 'checkbox') {
                element.checked = value;
            } else {
                element.value = value;
            }
        }
    }

    // L·∫•y gi√° tr·ªã t·ª´ element
    function getElementValue(elementId) {
        const element = document.getElementById(elementId);
        if (!element) return '';
        
        if (element.type === 'checkbox') {
            return element.checked;
        } else {
            return element.value;
        }
    }

    // C·∫Øt ng·∫Øn text
    function truncateText(text, maxLength) {
        if (!text) return '';
        return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
    }

    // Chuy·ªÉn ƒë·ªïi status th√†nh text
    function getStatusText(status) {
        const statusMap = {
            'waiting': 'Ch·ªù x·ª≠ l√Ω',
            'in_progress': 'ƒêang x·ª≠ l√Ω', 
            'completed': 'Ho√†n th√†nh',
            'paused': 'T·∫°m d·ª´ng',
            'handed_over': 'ƒê√£ b√†n giao'
        };
        return statusMap[status] || 'Kh√¥ng x√°c ƒë·ªãnh';
    }

    /**
     * =================================================================
     * SIDEBAR TOGGLE - ƒêI·ªÄU KHI·ªÇN SIDEBAR
     * =================================================================
     * ƒê√£ ƒë∆∞·ª£c chuy·ªÉn sang sidebar-generator.js
     */

    /**
     * =================================================================
     * DETAILS PANEL - PANEL CHI TI·∫æT
     * =================================================================
     */

    function showOrderDetails(orderId) {
        // T√¨m order trong c·∫£ ordersData v√† originalOrdersData
        let order = ordersData.find(o => o.id == orderId); // S·ª≠ d·ª•ng == ƒë·ªÉ so s√°nh loose
        
        if (!order) {
            order = originalOrdersData.find(o => o.id == orderId);
        }
        
        if (!order) {

            
            // Th·ª≠ t√¨m b·∫±ng production_order n·∫øu orderId c√≥ th·ªÉ l√† production_order
            const orderByProductionOrder = ordersData.find(o => o.production_order == orderId);
            if (orderByProductionOrder) {
                order = orderByProductionOrder;
            } else {
                const orderByProductionOrderOriginal = originalOrdersData.find(o => o.production_order == orderId);
                if (orderByProductionOrderOriginal) {
                    order = orderByProductionOrderOriginal;
                } else {
                    return;
                }
            }
        }

        // Update current editing order
        currentEditingOrder = order;
        
        // Ki·ªÉm tra shift hi·ªán t·∫°i ƒë·ªÉ l·∫•y start_time t·ª´ b·∫£ng production_orders_shift
        checkCurrentShiftStatus();
        
        // Chi ti·∫øt log ƒë·ªÉ debug th√¥ng tin th·ªùi gian

        // C·∫≠p nh·∫≠t m√£ l·ªánh trong ti√™u ƒë·ªÅ
        const orderCodeBadge = document.getElementById('detailOrderCode');
        if (orderCodeBadge) {
            orderCodeBadge.textContent = order.production_order || `#${order.id}`;
        }

        // Add logging to debug start time

        // Remove previous selection
        const previousSelected = document.querySelector('.table tbody tr.selected');
        if (previousSelected) {
            previousSelected.classList.remove('selected');
        }

        // Add selection to current row
        const currentRow = document.querySelector(`[data-order-id="${orderId}"]`);
        if (currentRow) {
            currentRow.classList.add('selected');
        }

        // Show details panel
        const detailsPanel = document.getElementById('detailsPanel');
        const contentArea = document.querySelector('.content-area');
        
        detailsPanel.classList.add('show');
        contentArea.classList.add('details-open');

        // Generate dynamic HTML content for the sidebar
        detailsPanel.innerHTML = generateSidebarHTML(order);
        
        // Initialize multi-select for workers
        initializeWorkerMultiSelect(order);
        
        // Initialize quantity OK table
        initializeQuantityOKTable();
        
        // Load d·ªØ li·ªáu k·ªá t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
        loadKeDataWhenOrderSelected(order);

        // Active tab "S·ªë l∆∞·ª£ng" n·∫øu ƒë√£ c√≥ th·ªùi gian b·∫Øt ƒë·∫ßu
        if (getOrderField(order, 'start_time')) {
            setTimeout(() => {
                const quantityTab = document.querySelector('.details-panel .tab-btn[onclick*="quantity"]');
                if (quantityTab) {
                    // Remove active class from all tabs
                    document.querySelectorAll('.details-panel .tab-btn').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.details-panel .tab-panel').forEach(panel => panel.classList.remove('active'));
                    
                    // Add active class to quantity tab
                    quantityTab.classList.add('active');
                    const quantityPanel = document.getElementById('quantity-panel');
                    if (quantityPanel) {
                        quantityPanel.classList.add('active');
                    }
                }
            }, 100);
        }

        // B·∫Øt ƒë·∫ßu timer n·∫øu ƒë√£ c√≥ th·ªùi gian b·∫Øt ƒë·∫ßu v√† ch∆∞a k·∫øt th√∫c
        if (window.currentShiftStartTime && !getOrderField(order, 'end_time')) {
            setTimeout(() => {
                startProductionTimer();
            }, 100);
        } else if (window.currentShiftStartTime && getOrderField(order, 'end_time')) {
            // N·∫øu ƒë√£ k·∫øt th√∫c, hi·ªÉn th·ªã th·ªùi gian c·ªë ƒë·ªãnh
            setTimeout(() => {
                const statusTimeElement = document.getElementById('statusTime');
                const runningTimeInfoElement = document.getElementById('runningTimeInfo');
                
                if (statusTimeElement) {
                    const fixedTime = calculateWorkTime(window.currentShiftStartTime, getOrderField(order, 'end_time'));
                    statusTimeElement.textContent = `Th·ªùi gian: ${fixedTime}`;
                }
                
                // Th·ªùi gian ch·∫°y trong tab th√¥ng tin ƒë√£ ƒë∆∞·ª£c hi·ªÉn th·ªã ƒë√∫ng t·ª´ HTML generation
                // Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t v√¨ ƒë√£ c√≥ gi√° tr·ªã c·ªë ƒë·ªãnh t·ª´ calculateWorkTime
            }, 100);
        }

        // Th√™m event listener ƒë·ªÉ t·ª± ƒë·ªông c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng chuy·ªÉn giao
        setTimeout(() => {
            const goodQtyInput = document.getElementById('goodQty');
            const handoverQtyInput = document.getElementById('handoverQty');
            
            if (goodQtyInput && handoverQtyInput) {
                goodQtyInput.addEventListener('input', function() {
                    const goodQty = parseInt(this.value) || 0;
                    handoverQtyInput.value = goodQty;
                    handleUpdateTotalQuantityDisplay(); // S·ª≠ d·ª•ng wrapper function
                    updateHandoverButtonValidationSync(); // C·∫≠p nh·∫≠t validation n√∫t b√†n giao
                });
            }
            
            // Th√™m event listeners cho validation real-time
            const quantityInputs = ['ngQty', 'ngStartEndQty', 'returnQty'];
            quantityInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        handleUpdateTotalQuantityDisplay(); // S·ª≠ d·ª•ng wrapper function
                        updateHandoverButtonValidationSync();
                    });
                    input.addEventListener('blur', function() {
                        handleUpdateTotalQuantityDisplay(); // S·ª≠ d·ª•ng wrapper function
                        updateHandoverButtonValidationSync();
                    });
                    input.addEventListener('input', updateStatisticsDisplay);
                    input.addEventListener('blur', updateStatisticsDisplay);
                }
            });
            
            // Kh·ªüi t·∫°o hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng v√† th·ªëng k√™
            handleUpdateTotalQuantityDisplay(); // S·ª≠ d·ª•ng wrapper function
            updateStatisticsDisplay();
            updateSelectedRackQuantityDisplaySync();
            updateHandoverButtonValidationSync();
        }, 100);
        
        // T·ª± ƒë·ªông ƒë·ªÅ xu·∫•t ca l√†m vi·ªác hi·ªán t·∫°i
        const shiftSelect = document.getElementById('shift');
        if (shiftSelect) {
            const currentShift = getCurrentShift();
            shiftSelect.value = currentShift;
        }
        
        // Reset form ƒë·ªÉ nh·∫≠p d·ªØ li·ªáu m·ªõi (kh√¥ng load t·ª´ database)
        // resetProductionForm();
        
        // Load s·ªë l∆∞·ª£ng c√≤n l·∫°i
        loadRemainingQuantity();
        
        // Ki·ªÉm tra tr·∫°ng th√°i shift hi·ªán t·∫°i
        checkCurrentShiftStatus();
        
        // Initialize display values
        initializeOrderDisplay();
    }

    /**
     * T√≠nh s·ªë l∆∞·ª£ng c·∫ßn s·∫£n xu·∫•t c√≤n l·∫°i
     * = S·ªë l∆∞·ª£ng t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc - (T·ªïng s·ªë l∆∞·ª£ng b√†n giao + NG c·ªßa c√°c ca ƒë√£ l√†m)
     */
    async function getRemainingQuantity(order) {
        try {
            // L·∫•y s·ªë l∆∞·ª£ng t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // L·∫•y t·ªïng s·ªë l∆∞·ª£ng b√†n giao v√† NG c·ªßa c√°c ca ƒë√£ l√†m
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            let totalHandoverQuantity = 0;
            let totalNgQuantity = 0;
            if (shiftsData.shifts && Array.isArray(shiftsData.shifts)) {
                shiftsData.shifts.forEach(shift => {
                    totalHandoverQuantity += (parseInt(shift.handover_quantity) || 0);
                    totalNgQuantity += (parseInt(shift.ng_quantity) || 0);
                });
            }
            
            // S·ªë l∆∞·ª£ng c√≤n l·∫°i = Input t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc - (B√†n giao + NG c·ªßa c√°c ca tr∆∞·ªõc)
            const remainingQuantity = Math.max(0, inputQuantity - totalHandoverQuantity - totalNgQuantity);
            console.log('üìä S·ªë l∆∞·ª£ng c√≤n l·∫°i:', {
                inputQuantity,
                totalHandoverQuantity,
                totalNgQuantity,
                remainingQuantity
            });
            
            return remainingQuantity;
        } catch (error) {
            console.error('‚ùå L·ªói t√≠nh s·ªë l∆∞·ª£ng c√≤n l·∫°i:', error);
            return getInputQuantityFromPreviousStage(order); // Fallback
        }
    }

    /**
     * Generate dynamic sidebar HTML for the order
     */
    function generateSidebarHTML(order) {
        const nextStage = order.next_stage;
        const nextStageName = nextStage ? getStageDisplayName(nextStage) : 'HO√ÄN TH√ÄNH';
        
        // Get status info
        let statusBadgeStyle = '';
        let statusText = '';
        
        if (getOrderField(order, 'status') === 'in_progress') {
            statusBadgeStyle = 'background: linear-gradient(135deg, var(--primary-green), #20c997);';
            statusText = 'ƒêang s·∫£n xu·∫•t';
        } else if (getOrderField(order, 'status') === 'completed') {
            statusBadgeStyle = 'background: linear-gradient(135deg, var(--primary-blue), #0dcaf0);';
            statusText = 'Ho√†n th√†nh';
        } else if (getOrderField(order, 'status') === 'handed_over') {
            statusBadgeStyle = 'background: linear-gradient(135deg, var(--primary-orange), #fd7e14);';
            statusText = 'ƒê√£ b√†n giao';
        } else {
            statusBadgeStyle = 'background: linear-gradient(135deg, #6c757d, #adb5bd);';
            statusText = 'Ch∆∞a b·∫Øt ƒë·∫ßu';
        }

        // Calculate statistics - kh√¥ng s·ª≠ d·ª•ng d·ªØ li·ªáu t·ª´ database
        const totalProduced = 0; // S·∫Ω ƒë∆∞·ª£c t√≠nh t·ª´ form nh·∫≠p li·ªáu
        const inputQuantity = getInputQuantityFromPreviousStage(order);
        const efficiency = 0; // S·∫Ω ƒë∆∞·ª£c t√≠nh t·ª´ form nh·∫≠p li·ªáu
        const ngRate = 0; // S·∫Ω ƒë∆∞·ª£c t√≠nh t·ª´ form nh·∫≠p li·ªáu

        return `
            <div class="sidebar-header">
                <h5><i class="bi bi-clipboard-data me-2"></i>B√°o c√°o l·ªánh: <strong>${order.production_order || `#${order.id}`}</strong></h5>
                <button type="button" class="detail-close" onclick="closeDetailsPanel()">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>

            <div class="sidebar-content">
                <!-- Tab Navigation -->
                <div class="tab-navigation">
                    <button class="tab-btn active" onclick="switchTab('info')">
                        <div class="tab-icon"><i class="bi bi-person-fill"></i></div>
                        <div>Th√¥ng tin</div>
                    </button>
                    <button class="tab-btn" onclick="switchTab('quantity')">
                        <div class="tab-icon"><i class="bi bi-calculator-fill"></i></div>
                        <div>S·ªë l∆∞·ª£ng</div>
                    </button>
      
                    <button class="tab-btn" onclick="switchTab('shifts')">
                        <div class="tab-icon"><i class="bi bi-clock-history"></i></div>
                        <div>Th√¥ng tin ca</div>
                    </button>
                    
                    <button class="tab-btn" onclick="switchTab('notes')">
                        <div class="tab-icon"><i class="bi bi-chat-text-fill"></i></div>
                        <div>Ghi ch√∫</div>
                    </button>
                </div>

                <!-- Tab Content -->
                <div class="tab-content">
                    <!-- Info Tab -->
                    <div id="info-panel" class="tab-panel active">
                        <div class="form-group">
                            <div class="multi-select-container">
                                <div class="multi-select-input" id="workerMultiSelect">
                                    <div class="selected-items" id="selectedWorkers"></div>
                                    <input type="text" class="multi-select-search" id="workerSearch" placeholder="T√¨m ki·∫øm th·ª£...">
                                </div>
                                <div class="multi-select-dropdown" id="workerDropdown" style="display: none;">
                                    <div class="dropdown-items" id="workerOptions">
                                        <!-- Options will be populated by JavaScript -->
                                    </div>
                                </div>
                            </div>
                            <label class="form-label">
                                <i class="bi bi-person-badge"></i>
                                T√™n th·ª£ ph·ª• tr√°ch
                            </label>
                            <input type="hidden" id="worker" value="${getOrderField(order, 'worker_name') || ''}">
                        </div>

                        <div class="form-group">
                            <select class="form-control-custom" id="shift">
                                <option value="">Ch·ªçn ca l√†m vi·ªác</option>
                                <option value="Ca 1" ${getOrderField(order, 'shift') === 'Ca 1' ? 'selected' : ''}>Ca 1 (6:00 - 14:00)</option>
                                <option value="Ca 2" ${getOrderField(order, 'shift') === 'Ca 2' ? 'selected' : ''}>Ca 2 (14:00 - 22:00)</option>
                                <option value="Ca 3" ${getOrderField(order, 'shift') === 'Ca 3' ? 'selected' : ''}>Ca 3 (22:00 - 6:00)</option>
                                <option value="K√≠p 1" ${getOrderField(order, 'shift') === 'K√≠p 1' ? 'selected' : ''}>K√≠p 1 (6:00 - 18:00)</option>
                                <option value="K√≠p 2" ${getOrderField(order, 'shift') === 'K√≠p 2' ? 'selected' : ''}>K√≠p 2 (18:00 - 6:00)</option>
                            </select>
                            <label class="form-label">
                                <i class="bi bi-clock"></i>
                                Ca l√†m vi·ªác
                            </label>
                        </div>

                        <div style="display: none;" class="form-group">
                            <select class="form-control-custom" id="machine">
                                <option value="">Ch·ªçn m√°y s·∫£n xu·∫•t</option>
                                ${getAvailableStageMachines().map(machineName => {
                                    const isSelected = getStageMachineFromAssigned(order.assigned_machine) === machineName;
                                    return `<option value="${machineName}" ${isSelected ? 'selected' : ''}>${machineName}</option>`;
                                }).join('')}
                            </select>
                            <label class="form-label">
                                <i class="bi bi-gear-fill"></i>
                                M√°y s·∫£n xu·∫•t
                            </label>
                        </div>

                        <div class="info-row">
                            <span class="info-label">Th·ªùi gian b·∫Øt ƒë·∫ßu</span>
                            <span class="info-value" id="startTimeInfo">${window.currentShiftStartTime ? formatDateTime(window.currentShiftStartTime) : '--'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Th·ªùi gian k·∫øt th√∫c</span>
                            <span class="info-value" id="endTimeInfo">${getOrderField(order, 'end_time') ? formatDateTime(getOrderField(order, 'end_time')) : '--'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Th·ªùi gian ch·∫°y</span>
                            <span class="info-value" id="runningTimeInfo">${window.currentShiftStartTime ?
                                (getOrderField(order, 'end_time') ? calculateWorkTime(window.currentShiftStartTime, getOrderField(order, 'end_time')) : 'ƒêang t√≠nh...') : '--'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Tr·∫°ng th√°i m√°y</span>
                            <span class="info-value">${getOrderField(order, 'status') === 'in_progress' ? 'Ho·∫°t ƒë·ªông t·ªët' : 'Ch·ªù'}</span>
                        </div>
                        
                        <!-- Ph·∫ßn ch·ªçn k·ªá - √Åp d·ª•ng t·ª´ demo-ke-sidebar.html -->
                        <div class="ke-selection-section" style="margin-top: 25px; padding-top: 25px; border-top: 2px solid #e9ecef;">
             
                            <!-- Bulk Controls -->
                            <div class="bulk-controls">
                                <div class="form-check-ke">
                                    <input class="form-check-input" type="checkbox" id="selectAllKe" onchange="toggleSelectAllKe(this)">
                                    <label class="form-check-label-ke" for="selectAllKe">Ch·ªçn t·∫•t c·∫£ k·ªá</label>
                                </div>
                            </div>
                            
                            <!-- K·ªá Toggle Grid -->
                            <div class="ke-toggle-grid" id="keToggleGrid">
                                <!-- K·ªá toggle items will be generated here -->
                            </div>
                            
                            <!-- Summary Section -->
                            <div class="summary-section" id="summarySection" style="display: none;">
                                <h6 class="summary-title">T√≥m t·∫Øt th√¥ng tin</h6>
                                
                                <div class="summary-grid">
                                    <div class="summary-card">
                                        <div class="summary-value" id="totalKe">0</div>
                                        <div class="summary-label">T·ªïng s·ªë k·ªá</div>
                                    </div>
                                    <div class="summary-card">
                                        <div class="summary-value" id="selectedKe">0</div>
                                        <div class="summary-label">K·ªá ƒë√£ ch·ªçn</div>
                                    </div>
                                    <div class="summary-card">
                                        <div class="summary-value" id="totalQuantity">0</div>
                                        <div class="summary-label">T·ªïng s·ªë l∆∞·ª£ng</div>
                                    </div>
                                    <div class="summary-card">
                                        <div class="summary-value" id="completionRate">0%</div>
                                        <div class="summary-label">Ho√†n th√†nh</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Quantity Tab -->
                    <div id="quantity-panel" class="tab-panel">
                        <!-- Quantity OK Table -->
                        <div class="quantity-table mb-3">
                            <div class="table-header">
                                <h6><i class="bi bi-list-check me-2"></i>B·∫£ng nh·∫≠p theo k·ªá</h6>
                                <div class="table-actions">
                                    <button class="btn-add-row" onclick="addQuantityOKRow()">
                                        <i class="bi bi-plus-circle"></i>
                                        Th√™m k·ªá
                                    </button>
                                </div>
                            </div>
                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th style="width: 50px;">#</th>
                                            <th style="width: 150px;">K·ªá</th>
                                            <th style="width: 120px;">S·ªë l∆∞·ª£ng</th>
                                            <th style="width: 100px;">Thao t√°c</th>
                                        </tr>
                                    </thead>
                                    <tbody id="quantityOKTableBody">
                                        <!-- Rows will be generated here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- Summary OK Quantity -->
                        <div class="quantity-grid mb-3">
                            <div class="quantity-card success">
                                <div class="quantity-label">T·ªïng s·ªë l∆∞·ª£ng OK</div>
                                <input type="number" class="quantity-input" id="goodQty" value="0" readonly>
                            </div>
                            <div class="quantity-card danger">
                                <div class="quantity-label">S·ªë l∆∞·ª£ng NG</div>
                                <input type="number" class="quantity-input" id="ngQty" value="0">
                            </div>
                        </div>

                        <div class="quantity-grid mb-3">
                            <div class="quantity-card ">
                                <div class="quantity-label">NG ƒë·∫ßu/cu·ªëi</div>
                                <input type="number" class="quantity-input" id="ngStartEndQty" value="0">
                            </div>
                            <div class="quantity-card ">
                                <div class="quantity-label">S·ªë l∆∞·ª£ng tr·∫£</div>
                                <input type="number" class="quantity-input" id="returnQty" value="0">
                            </div>
                        </div>

<!--
                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-arrow-right-circle"></i>
                                S·ªë l∆∞·ª£ng chuy·ªÉn giao
                            </label>
                            <input type="number" class="form-control-custom" id="handoverQty" value="0" style="font-size: 1.1rem; font-weight: 600; color: var(--primary-blue);">
                            </div>
                        -->
                       
                        <div class="info-row" style="background: linear-gradient(135deg, #e3f2fd, #e3f2fd); border-radius: 8px; padding: 12px; margin: 10px 0; ">
                            <span class="info-label" style="font-weight: 600; color: #1976d2;">üì¶ T·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn</span>
                            <span class="info-value" id="selectedRackQuantityDisplay" style="font-weight: 700; font-size: 1.1rem; color: #1565c0;">ƒêang t√≠nh...</span>
                        </div>

                        <div class="info-row" style="background: linear-gradient(135deg, #e3f2fd, #e3f2fd); border-radius: 8px; padding: 12px; margin: 10px 0; ">
                            <span class="info-label" style="font-weight: 600; color: #1976d2;">üì• S·ªë l∆∞·ª£ng c·∫ßn s·∫£n xu·∫•t</span>
                            <span class="info-value" id="remainingQuantityDisplay" style="font-weight: 700; font-size: 1.1rem; color: #1565c0;">ƒêang t√≠nh...</span>
                        </div>


                        <div class="info-row" style="background: linear-gradient(135deg, #fff3cd, #fff3cd); border-radius: 8px; padding: 12px; margin: 10px 0; ">
                            <span class="info-label" style="font-weight: 600; color: #856404;">üìä T·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p</span>
                            <span class="info-value" id="totalQuantityDisplay" style="font-weight: 700; font-size: 1.1rem; color: #856404;">0 / 0</span>
                        </div>
                        <!--
                        <div class="info-row">
                            <span class="info-label">T·ªïng s·∫£n xu·∫•t</span>
                            <span class="info-value" id="totalProducedValue">0 s·∫£n ph·∫©m</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Hi·ªáu su·∫•t</span>
                            <span class="info-value" id="efficiencyValue">0%</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">T·ª∑ l·ªá NG</span>
                            <span class="info-value" id="ngRateValue">0%</span>
                        </div>
                        -->
                    </div>

                 

                    

                    <!-- Shifts Tab -->
                    <div id="shifts-panel" class="tab-panel">
                
                            <div class="shifts-header">
                                <h6><i class="bi bi-clock-history me-2"></i>L·ªãch s·ª≠ ca l√†m vi·ªác</h6>
                                <div class="shifts-loading" id="shiftsLoading" style="display: none;">
                                    <div class="spinner-border spinner-border-sm" role="status">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                    <span class="ms-2">ƒêang t·∫£i...</span>
                                </div>
                            </div>
                            
                            <div class="shifts-list" id="shiftsList">
                                <!-- Shifts will be loaded here -->
                            </div>
                        </div>
                  
                </div>

                <!-- Notes Tab -->
                    <div id="notes-panel" class="tab-panel">
                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-journal-text"></i>
                                Ghi ch√∫ s·∫£n xu·∫•t
                            </label>
                            <div class="note-area">
                                <textarea class="note-textarea" id="note" placeholder="Nh·∫≠p ghi ch√∫ v·ªÅ qu√° tr√¨nh s·∫£n xu·∫•t...">${getOrderField(order, 'note') || ''}</textarea>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-lightbulb"></i>
                                ƒê·ªÅ xu·∫•t c·∫£i ti·∫øn
                            </label>
                            <div class="note-area">
                                <textarea class="note-textarea" id="improvement" placeholder="Nh·∫≠p ƒë·ªÅ xu·∫•t c·∫£i ti·∫øn...">${order.improvement_suggestions || ''}</textarea>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-tag"></i>
                                Tags
                            </label>
                            <input type="text" class="form-control-custom" id="tags" value="${order.tags || ''}" placeholder="Nh·∫≠p c√°c tag, c√°ch nhau b·ªüi d·∫•u ph·∫©y">
                        </div>
                    </div>

                <!-- Production Controls -->
                <div class="production-controls">
                    <!-- Production Status -->
                    <div class="production-status ${getOrderField(order, 'status') === 'in_progress' ? 'running' : 'stopped'}" id="productionStatus">
                        <div class="status-text">
                            <i class="bi bi-${getOrderField(order, 'status') === 'in_progress' ? 'play-circle-fill text-success' : 'stop-circle-fill text-danger'}"></i>
                            <span id="productionStatusText">${statusText}</span>
                        </div>
                        <div class="status-time" id="statusTime">Th·ªùi gian: </div>
                    </div>

                    <!-- Control Buttons -->
                    <div class="control-row">
                        <button class="btn-custom btn-success-custom" id="startBtn" onclick="startProduction()">
                            <i class="bi bi-play-fill"></i>
                            B·∫Øt ƒë·∫ßu
                        </button>
         
                        <button class="btn-custom btn-info-custom" id="handoverShiftBtn" onclick="handoverShift()" ${getOrderField(order, 'status') === 'not_started' || getOrderField(order, 'status') === 'handed_over' ? 'disabled' : ''} style="${getOrderField(order, 'start_time') && !getOrderField(order, 'end_time') ? 'display: flex;' : 'display: none;'}">
                            <i class="bi bi-clock-history"></i>
                            B√†n giao ca
                        </button>

                          <button class="btn-custom btn-secondary-custom" id="resetBtn" onclick="resetProduction()" style="${getOrderField(order, 'start_time') && getOrderField(order, 'status') === 'in_progress' ? 'display: flex;    max-width: 100px;' : 'display: none;'}">
                            <i class="bi bi-arrow-clockwise"></i>
                            H·ªßy l√†m
                        </button>
                    </div>

          
                </div>
            </div>
        `;
    }

    // Helper functions for form manipulation
    function setElementValue(id, value) {
        const element = document.getElementById(id);
        if (element) {
            element.value = value;
        }
    }

    function getElementValue(id) {
        const element = document.getElementById(id);
        if (!element) return '';
        
        // X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho select elements
        if (element.tagName === 'SELECT') {
            const selectedOption = element.options[element.selectedIndex];
            return selectedOption ? selectedOption.value : '';
        }
        
        // X·ª≠ l√Ω cho input, textarea v√† c√°c element kh√°c
        return element.value || '';
    }

    /**
     * =================================================================
     * QUANTITY OK TABLE FUNCTIONS - H√ÄM X·ª¨ L√ù B·∫¢NG NH·∫¨P S·ªê L∆Ø·ª¢NG OK THEO K·ªÜ
     * =================================================================
     */
    
    // Global variables for quantity OK table
    let quantityOKRowCounter = 0;
    let keRowBaseIndex = 0; // s·ªë k·ªá ƒë√£ c√≥ t·ª´ d·ªØ li·ªáu ƒë√£ l∆∞u
    
    /**
     * Initialize quantity OK table when order details are shown
     */
    async function initializeQuantityOKTable() {
        quantityOKRowCounter = 0;
        
        const tableBody = document.getElementById('quantityOKTableBody');
        if (tableBody) {
            tableBody.innerHTML = '';
            await computeKeRowBaseIndex();
            // Th√™m 3 d√≤ng m·∫∑c ƒë·ªãnh b·∫Øt ƒë·∫ßu t·ª´ k·ªá ti·∫øp theo
            // for (let i = 0; i < 3; i++) {
            //     addQuantityOKRow();
            // }
        }
        
        updateTotalOKQuantity();
    }

    async function computeKeRowBaseIndex() {
        keRowBaseIndex = 0;
        try {
            if (!currentEditingOrder) return;
            const resp = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/handover_json/${STAGE_CONFIG.KEY}`);
            if (!resp.ok) return;
            const data = await resp.json();
            let raw = data && data.data ? data.data : null;
            if (!raw) return;
            if (typeof raw === 'string') {
                try { raw = JSON.parse(raw); } catch (_) { return; }
            }
            const recordsKey = `${STAGE_CONFIG.KEY}_ke_records`;
            const idKey = `${STAGE_CONFIG.KEY}_ke_id`;
            const records = raw[recordsKey] || [];
            if (!Array.isArray(records) || records.length === 0) return;
            let maxIdx = 0;
            records.forEach(rec => {
                const val = rec[idKey] || '';
                const m = typeof val === 'string' ? val.match(/(\d+)/) : null;
                const num = m ? parseInt(m[1]) : 0;
                if (!isNaN(num)) maxIdx = Math.max(maxIdx, num);
            });
            keRowBaseIndex = maxIdx;
        } catch (e) {
            keRowBaseIndex = 0;
        }
    }
    
    /**
     * Add new row to quantity OK table
     */
    function addQuantityOKRow() {
        quantityOKRowCounter++;
        const tableBody = document.getElementById('quantityOKTableBody');
        
        if (!tableBody) return;
        
        // Calculate the actual row number (1-based index)
        const actualRowNumber = tableBody.children.length + 1;
        
        const row = document.createElement('tr');
        row.id = `quantity-ok-row-${quantityOKRowCounter}`;
        
        const keNumber = keRowBaseIndex + actualRowNumber;
        const keValue = `K·ªá ${keNumber}`;
        const keId = `ke_${keNumber}`;
        
        row.innerHTML = `
            <td>${keNumber}</td>
            <td>${keValue}</td>
            <td style="display: none;">${keId}</td>
            <td>
                <input type="number" 
                       class="quantity-input ok" 
                       id="qty-ok-${quantityOKRowCounter}" 
                       placeholder="0" 
                       min="0" 
                       onchange="handleUpdateTotalOKQuantity()"
                       oninput="handleUpdateTotalOKQuantity()">
            </td>
            <td>
                <button class="btn-remove-row" onclick="handleRemoveQuantityOKRow(${quantityOKRowCounter})">
                    <i class="bi bi-trash"></i>
                </button>
            </td>
        `;
        
        tableBody.appendChild(row);
    }
    
    /**
     * Remove row from quantity OK table
     */
    async function removeQuantityOKRow(rowId) {
        const row = document.getElementById(`quantity-ok-row-${rowId}`);
        if (row) {
            row.remove();
            
            // Update row numbers and ke names after removal
            updateRowNumbers();
            
            await updateTotalOKQuantity();
        }
    }
    
    /**
     * Update row numbers and ke names after row removal
     */
    function updateRowNumbers() {
        const tableBody = document.getElementById('quantityOKTableBody');
        if (!tableBody) return;
        
        const rows = tableBody.querySelectorAll('tr');
        rows.forEach((row, index) => {
            const rowNumber = index + 1;
            const keNumber = keRowBaseIndex + rowNumber;
            const keName = `K·ªá ${keNumber}`;
            
            // Update the first cell (row number)
            const firstCell = row.cells[0];
            if (firstCell) {
                firstCell.textContent = keNumber;
            }
            
            // Update the second cell (ke name)
            const secondCell = row.cells[1];
            if (secondCell) {
                secondCell.textContent = keName;
            }
        });
    }
    
    /**
     * Update total OK quantity from table
     */
    async function updateTotalOKQuantity() {
        let totalOK = 0;
        
        const rows = document.querySelectorAll('#quantityOKTableBody tr');
        rows.forEach(row => {
            const rowId = row.id.replace('quantity-ok-row-', '');
            const okValue = parseInt(document.getElementById(`qty-ok-${rowId}`)?.value) || 0;
            totalOK += okValue;
        });
        
        // Update the total OK input
        const goodQtyInput = document.getElementById('goodQty');
        if (goodQtyInput) {
            goodQtyInput.value = totalOK;
        }
        
        // Update handover quantity (default to OK quantity)
        const handoverQtyInput = document.getElementById('handoverQty');
        if (handoverQtyInput) {
            handoverQtyInput.value = totalOK;
        }
        
        // Update total quantity display with await
        await updateTotalQuantityDisplay();
    }
    
    /**
     * Collect quantity OK table data
     */
    function collectQuantityOKTableData() {
        const data = [];
        const rows = document.querySelectorAll('#quantityOKTableBody tr');
        
        rows.forEach((row, index) => {
            const rowId = row.id.replace('quantity-ok-row-', '');
            const okValue = parseInt(document.getElementById(`qty-ok-${rowId}`)?.value) || 0;
            const keValue = row.cells[1].textContent;
            const keId = row.cells[2].textContent; // L·∫•y ke_id t·ª´ cell ·∫©n
            
            if (okValue > 0) {
                data.push({
                    row_id: keId.replace('ke_', ''), // L·∫•y s·ªë t·ª´ ke_id
                    ke: keValue,
                    ok_quantity: okValue
                });
            }
        });
        
        return data;
    }

    /**
     * X√°c ƒë·ªãnh ca l√†m vi·ªác theo th·ªùi gian hi·ªán t·∫°i
     */
    function getCurrentShift() {
        const now = new Date();
        const currentHour = now.getHours();
        
        // K√≠p 1: t·ª´ 6:00 - 18:00 (6:00 ƒë·∫øn 17:59)
        if (currentHour >= 6 && currentHour < 18) {
            return 'K√≠p 1';
        }
        // K√≠p 2: t·ª´ 18:00 - 6:00 (18:00 ƒë·∫øn 5:59)
        else {
            return 'K√≠p 2';
        }
    }

    /**
     * Initialize display values when order is selected
     */
    async function initializeOrderDisplay() {
        if (!currentEditingOrder) return;
        
        try {
            // Update displays that depend on async data
            await updateSelectedRackQuantityDisplay();
            await updateHandoverButtonValidation();
            
            // Update sync displays with await
            await updateTotalQuantityDisplay();
            updateStatisticsDisplay();
            
            console.log('‚úÖ Order display initialized successfully');
        } catch (error) {
            console.error('‚ùå Error initializing order display:', error);
        }
    }

    // Export the initialization function
    window.initializeOrderDisplay = initializeOrderDisplay;

    /**
     * Wrapper functions for async event handlers to be called from inline events
     */
    window.handleUpdateTotalOKQuantity = function() {
        updateTotalOKQuantity().catch(error => {
            console.error('‚ùå Error in updateTotalOKQuantity:', error);
        });
    };

    window.handleRemoveQuantityOKRow = function(rowId) {
        removeQuantityOKRow(rowId).catch(error => {
            console.error('‚ùå Error in removeQuantityOKRow:', error);
        });
    };

    window.handleUpdateTotalQuantityDisplay = function() {
        updateTotalQuantityDisplay().catch(error => {
            console.error('‚ùå Error in updateTotalQuantityDisplay:', error);
        });
    };

    /**
     * Attach event listeners to quantity input fields to auto-update total display
     */
    function attachQuantityEventListeners() {
        const quantityInputIds = ['ngQty', 'ngStartEndQty', 'returnQty'];
        
        quantityInputIds.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                // Remove existing listeners to prevent duplicates
                input.removeEventListener('input', handleUpdateTotalQuantityDisplay);
                input.removeEventListener('change', handleUpdateTotalQuantityDisplay);
                
                // Add new listeners
                input.addEventListener('input', handleUpdateTotalQuantityDisplay);
                input.addEventListener('change', handleUpdateTotalQuantityDisplay);
                
                console.log(`‚úÖ Event listeners attached to ${inputId}`);
            }
        });
    }
    
    // Export the function to be called after order details are shown
    window.attachQuantityEventListeners = attachQuantityEventListeners;

    /**
     * Validate t·ªïng s·ªë l∆∞·ª£ng kh√¥ng v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng ƒë·∫ßu v√†o
     */
    async function validateTotalQuantity(order, goodQty, ngQty, ngStartEndQty = 0, returnQty = 0) {
        // T√≠nh t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
        const totalEntered = goodQty + ngQty + ngStartEndQty + returnQty;
        
        // L·∫•y s·ªë l∆∞·ª£ng t·ª´ k·ªá ƒë√£ ch·ªçn
        const selectedRackTotalQuantity = await getTotalQuantityInSelectedRacks();
        
        // N·∫øu kh√¥ng c√≥ k·ªá n√†o ƒë∆∞·ª£c ch·ªçn, s·ª≠ d·ª•ng s·ªë l∆∞·ª£ng ƒë·∫ßu v√†o t·ª´ stage tr∆∞·ªõc
        let inputQuantity = selectedRackTotalQuantity;
        if (inputQuantity === 0) {
            inputQuantity = getInputQuantityFromPreviousStage(order);
        }
        
        // Ki·ªÉm tra t·ªïng s·ªë l∆∞·ª£ng kh√¥ng v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng ƒë·∫ßu v√†o
        if (totalEntered > inputQuantity) {
            const quantitySource = selectedRackTotalQuantity > 0 ? 'k·ªá ƒë√£ ch·ªçn' : 'ƒë·∫ßu v√†o';
            showNotification(`‚ö†Ô∏è T·ªïng s·ªë l∆∞·ª£ng (${totalEntered}) v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng ${quantitySource} (${inputQuantity})!\n\nChi ti·∫øt:\n‚Ä¢ OK: ${goodQty}\n‚Ä¢ NG: ${ngQty}\n‚Ä¢ NG ƒë·∫ßu/cu·ªëi: ${ngStartEndQty}\n‚Ä¢ Tr·∫£: ${returnQty}\n‚Ä¢ T·ªïng: ${totalEntered}\n‚Ä¢ ${quantitySource}: ${inputQuantity}`, 'error');
            return false;
        }
        
        return true;
    }

    /**
     * C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng v√† validation real-time
     */
    async function updateTotalQuantityDisplay() {
        if (!currentEditingOrder) return;
        
        // Get total OK from table
        const okTableData = collectQuantityOKTableData();
        const goodQty = okTableData.reduce((sum, row) => sum + row.ok_quantity, 0);
        const ngQty = parseInt(getElementValue('ngQty')) || 0;
        const ngStartEndQty = parseInt(getElementValue('ngStartEndQty')) || 0;
        const returnQty = parseInt(getElementValue('returnQty')) || 0;
        
        const totalEntered = goodQty + ngQty + ngStartEndQty + returnQty;
        
        // L·∫•y t·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn t·ª´ getTotalQuantityInSelectedRacks
        const selectedRackQuantity = await getTotalQuantityInSelectedRacks();
        
        console.log(`üìä [updateTotalQuantityDisplay] T·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p: ${totalEntered}, T·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn: ${selectedRackQuantity}`);
        
        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng
        const totalDisplay = document.getElementById('totalQuantityDisplay');
        if (totalDisplay) {
            totalDisplay.textContent = `${totalEntered} / ${selectedRackQuantity}`;
            
            // Thay ƒë·ªïi m√†u s·∫Øc d·ª±a tr√™n validation
            if (totalEntered > selectedRackQuantity) {
                totalDisplay.style.color = '#dc3545'; // ƒê·ªè - V∆∞·ª£t qu√°
                totalDisplay.style.fontWeight = 'bold';
                totalDisplay.title = 'T·ªïng s·ªë l∆∞·ª£ng nh·∫≠p v∆∞·ª£t qu√° t·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn!';
            } else if (totalEntered === selectedRackQuantity && selectedRackQuantity > 0) {
                totalDisplay.style.color = '#28a745'; // Xanh l√° - Ho√†n h·∫£o
                totalDisplay.style.fontWeight = 'bold';
                totalDisplay.title = 'S·ªë l∆∞·ª£ng nh·∫≠p kh·ªõp v·ªõi t·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn';
            } else if (selectedRackQuantity === 0) {
                totalDisplay.style.color = '#ffc107'; // V√†ng - Ch∆∞a c√≥ k·ªá
                totalDisplay.style.fontWeight = 'normal';
                totalDisplay.title = 'Ch∆∞a c√≥ k·ªá n√†o s·∫µn s√†ng ƒë·ªÉ x·ª≠ l√Ω';
            } else {
                totalDisplay.style.color = '#6c757d'; // X√°m - B√¨nh th∆∞·ªùng
                totalDisplay.style.fontWeight = 'normal';
                totalDisplay.title = `C√≤n l·∫°i ${selectedRackQuantity - totalEntered} s·∫£n ph·∫©m ch∆∞a nh·∫≠p`;
            }
        }
        
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i c√°c input field
        const inputs = ['goodQty', 'ngQty', 'ngStartEndQty', 'returnQty'];
        inputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                if (totalEntered > selectedRackQuantity && selectedRackQuantity > 0) {
                    input.style.color = '#dc3545'; // ƒê·ªè khi v∆∞·ª£t qu√°
                    input.title = 'S·ªë l∆∞·ª£ng v∆∞·ª£t qu√° t·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn';
                } else {
                    input.style.color = '';
                    input.title = '';
                }
            }
        });
    }

    /**
     * L·∫•y ID c·ªßa k·ªá ƒë∆∞·ª£c ch·ªçn ƒë·∫ßu ti√™n
     * @returns {string|null} - ID c·ªßa k·ªá ƒë∆∞·ª£c ch·ªçn ho·∫∑c null n·∫øu kh√¥ng c√≥
     */
    function getSelectedKeId() {
        // T√¨m k·ªá ƒë∆∞·ª£c ch·ªçn ƒë·∫ßu ti√™n trong UI
        const selectedKeItems = document.querySelectorAll('.ke-toggle-item.selected');
        
        console.log(`üîç [getSelectedKeId] T√¨m th·∫•y ${selectedKeItems.length} k·ªá ƒë∆∞·ª£c ch·ªçn`);
        selectedKeItems.forEach((item, index) => {
            console.log(`üîç [getSelectedKeId] K·ªá ${index + 1}: ${item.id} (class: ${item.className})`);
        });
        
        if (selectedKeItems.length > 0) {
            // L·∫•y ID t·ª´ element ƒë·∫ßu ti√™n (format: ke-${number})
            const firstSelectedItem = selectedKeItems[0];
            const keId = firstSelectedItem.id; // C√≥ d·∫°ng "ke-1", "ke-2", v.v.
            console.log(`üéØ [getSelectedKeId] T√¨m th·∫•y k·ªá ƒë∆∞·ª£c ch·ªçn: ${keId}`);
            return keId;
        }
        
        console.log('‚ÑπÔ∏è [getSelectedKeId] Kh√¥ng c√≥ k·ªá n√†o ƒë∆∞·ª£c ch·ªçn');
        return null;
    }

    /**
     * L·∫•y d·ªØ li·ªáu t·ª´ form trong sidebar
     * @returns {object} - D·ªØ li·ªáu form ƒë√£ ƒë∆∞·ª£c validate
     */
    function getFormData() {
        // Collect data from OK table
        const okTableData = collectQuantityOKTableData();
        const totalOK = okTableData.reduce((sum, row) => sum + row.ok_quantity, 0);
        
        const formData = {
            worker: getElementValue('worker') || '',
            shift: getElementValue('shift') || '',
            machine: getElementValue('machine') || '',
            goodQty: totalOK,
            ngQty: parseInt(getElementValue('ngQty')) || 0,
            ngStartEndQty: parseInt(getElementValue('ngStartEndQty')) || 0,
            returnQty: parseInt(getElementValue('returnQty')) || 0,
            handoverQty: parseInt(getElementValue('handoverQty')) || totalOK,
            qualityRating: getElementValue('qualityRating') || '',
            qualityCheck: getElementValue('qualityCheck') || '',
            note: getElementValue('note') || '',
            improvement: getElementValue('improvement') || '',
            tags: getElementValue('tags') || '',
            okTableData: okTableData,
            selectedKeId: getSelectedKeId() // Th√™m k·ªá ƒë∆∞·ª£c ch·ªçn
        };

        return formData;
    }

    function closeDetailsPanel() {
        const detailsPanel = document.getElementById('detailsPanel');
        const contentArea = document.querySelector('.content-area');
        
        detailsPanel.classList.remove('show');
        contentArea.classList.remove('details-open');
        
        // D·ª´ng timer khi ƒë√≥ng panel
        stopProductionTimer();
        
        // Remove selection from table row
        const selectedRow = document.querySelector('.table tbody tr.selected');
        if (selectedRow) {
            selectedRow.classList.remove('selected');
        }
    }




    function getStatusBadgeClass(status) {
        const statusMap = {
            'waiting': 'bg-warning',
            'in_progress': 'bg-primary',
            'completed': 'bg-success',
            'paused': 'bg-secondary',
            'handed_over': 'bg-info'
        };
        return statusMap[status] || 'bg-secondary';
    }

    function formatDate(dateString) {
        if (!dateString) return 'N/A';
        try {
            const date = new Date(dateString);
            return date.toLocaleDateString('vi-VN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        } catch (e) {
            return 'N/A';
        }
    }

    /**
     * Get total quantity in selected racks from input_quantity_json for racks with status 'in_progress' only
     */
    async function getTotalQuantityInSelectedRacks() {
        if (!currentEditingOrder) {
            return 0;
        }
        
        try {
            // L·∫•y d·ªØ li·ªáu input JSON ƒë·ªÉ t√≠nh t·ªïng s·ªë l∆∞·ª£ng c·ªßa c√°c k·ªá c√≥ tr·∫°ng th√°i 'in_progress'
            const response = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/input_json/${STAGE_CONFIG.KEY}`);
            if (!response.ok) {
                console.log('‚ÑπÔ∏è Kh√¥ng c√≥ d·ªØ li·ªáu input JSON ƒë·ªÉ t√≠nh t·ªïng s·ªë l∆∞·ª£ng');
                return 0;
            }
            
            const data = await response.json();
            let raw = data && data.data ? data.data : null;
            if (!raw) return 0;
            
            if (typeof raw === 'string') {
                try { 
                    raw = JSON.parse(raw); 
                } catch (e) { 
                    console.warn('‚ö†Ô∏è L·ªói parse JSON trong getTotalQuantityInSelectedRacks:', e);
                    return 0; 
                }
            }
            
            // T√¨m t·∫•t c·∫£ c√°c key ch·ª©a "_ke_records"
            const keRecordsKeys = Object.keys(raw).filter(key => key.endsWith('_ke_records'));
            
            if (keRecordsKeys.length === 0) {
                console.log('‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu k·ªá trong input JSON');
                return 0;
            }
            
            // T√≠nh t·ªïng s·ªë l∆∞·ª£ng c·ªßa c√°c k·ªá c√≥ tr·∫°ng th√°i ph√π h·ª£p cho stage hi·ªán t·∫°i
            const currentStageStatusKey = `${STAGE_CONFIG.KEY}_status`;
            const currentStageQuantityKey = `${STAGE_CONFIG.KEY}_quantity`;
            
            let totalQuantity = 0;
            let foundRacksCount = 0;
            
            keRecordsKeys.forEach(keRecordsKey => {
                const records = raw[keRecordsKey];
                if (Array.isArray(records)) {
                    records.forEach(record => {
                        const status = record[currentStageStatusKey];
                        // Ch·ªâ ch·∫•p nh·∫≠n 'in_progress' - kh√¥ng t√≠nh 'waiting'
                        if (status === 'in_progress') {
                            // L·∫•y s·ªë l∆∞·ª£ng: ∆∞u ti√™n current stage, n·∫øu kh√¥ng c√≥ th√¨ d√πng previous stage
                            let quantity = parseInt(record[currentStageQuantityKey]) || 0;
                            
                            // N·∫øu current stage kh√¥ng c√≥ quantity, th√¨ d√πng quantity t·ª´ stage tr∆∞·ªõc
                            if (quantity === 0) {
                                // T√¨m quantity t·ª´ c√°c stage tr∆∞·ªõc (xa_quantity, cat_quantity, v.v.)
                                const previousStageKeys = Object.keys(record).filter(key => key.endsWith('_quantity'));
                                
                                for (const key of previousStageKeys) {
                                    const prevQuantity = parseInt(record[key]) || 0;
                                    if (prevQuantity > 0) {
                                        quantity = prevQuantity;
                                        console.log(`ÔøΩ [getTotalQuantityInSelectedRacks] S·ª≠ d·ª•ng s·ªë l∆∞·ª£ng t·ª´ ${key}: ${quantity}`);
                                        break;
                                    }
                                }
                            }
                            
                            totalQuantity += quantity;
                            foundRacksCount++;
                            
                            // L·∫•y ke_id t·ª´ current stage ho·∫∑c previous stage
                            const keId = record[`${STAGE_CONFIG.KEY}_ke_id`] || record.xa_ke_id || record.ke_id || 'N/A';
                            console.log(`üìä [getTotalQuantityInSelectedRacks] K·ªá ${keId} (${status}) c√≥ s·ªë l∆∞·ª£ng: ${quantity}`);
                        }
                    });
                }
            });
            
            console.log(`üìä [getTotalQuantityInSelectedRacks] T√¨m th·∫•y ${foundRacksCount} k·ªá ƒëang x·ª≠ l√Ω (in_progress), t·ªïng s·ªë l∆∞·ª£ng: ${totalQuantity}`);
            return totalQuantity;
            
        } catch (error) {
            console.error('‚ùå L·ªói khi t√≠nh t·ªïng s·ªë l∆∞·ª£ng trong c√°c k·ªá ƒë√£ ch·ªçn:', error);
            return 0;
        }
    }

    /**
     * Update the display of total quantity in selected racks
     */
    async function updateSelectedRackQuantityDisplay() {
        const selectedRackDisplay = document.getElementById('selectedRackQuantityDisplay');
        if (!selectedRackDisplay) return;
        
        const totalQuantity = await getTotalQuantityInSelectedRacks();
        
        if (totalQuantity > 0) {
            selectedRackDisplay.textContent = totalQuantity.toLocaleString();
            selectedRackDisplay.style.color = '#1565c0';
            
            console.log(`üì¶ [updateSelectedRackQuantityDisplay] T·ªïng s·ªë l∆∞·ª£ng trong c√°c k·ªá c√≥ s·∫µn: ${totalQuantity}`);
        } else {
            selectedRackDisplay.textContent = 'Kh√¥ng c√≥ k·ªá s·∫µn s√†ng';
            selectedRackDisplay.style.color = '#9e9e9e';
        }
    }
    
    /**
     * Update handover button validation based on selected rack quantities
     * Button is always enabled, but validation is handled in handover process
     */
    async function updateHandoverButtonValidation() {
        const handoverBtn = document.getElementById('handoverShiftBtn');
        if (!handoverBtn) return;
        
        // Get current form data
        const goodQty = parseInt(getElementValue('goodQty')) || 0;
        const ngQty = parseInt(getElementValue('ngQty')) || 0;
        const ngStartEndQty = parseInt(getElementValue('ngStartEndQty')) || 0;
        const returnQty = parseInt(getElementValue('returnQty')) || 0;
        
        const totalEnteredQuantity = goodQty + ngQty + ngStartEndQty + returnQty;
        
        // Get total quantity in selected racks
        const selectedRackTotalQuantity = await getTotalQuantityInSelectedRacks();
        
        // Check validation status
        const isQuantityMatch = totalEnteredQuantity === selectedRackTotalQuantity;
        const hasSelectedRacks = selectedRackTotalQuantity > 0;
        
        // Always enable button - validation is handled during handover process
        handoverBtn.disabled = false;
        handoverBtn.title = '';
        
        // Log validation status for debugging
        if (hasSelectedRacks && selectedRackTotalQuantity > 0) {
            if (isQuantityMatch) {
                console.log(`‚úÖ [updateHandoverButtonValidation] Validation OK - S·ªë l∆∞·ª£ng kh·ªõp: ${totalEnteredQuantity} = ${selectedRackTotalQuantity}`);
            } else {
                console.log(`‚ö†Ô∏è [updateHandoverButtonValidation] Validation Warning - S·ªë l∆∞·ª£ng kh√¥ng kh·ªõp: ${totalEnteredQuantity} ‚â† ${selectedRackTotalQuantity} (s·∫Ω hi·ªÉn th·ªã c·∫£nh b√°o khi b√†n giao)`);
            }
        } else {
            console.log(`‚ö†Ô∏è [updateHandoverButtonValidation] Warning - Ch∆∞a c√≥ k·ªá n√†o s·∫µn s√†ng ho·∫∑c ch∆∞a b·∫Øt ƒë·∫ßu s·∫£n xu·∫•t (s·∫Ω hi·ªÉn th·ªã c·∫£nh b√°o khi b√†n giao)`);
        }
    }

    /**
     * T·ª± ƒë·ªông ch·ªçn c√°c k·ªá c√≥ tr·∫°ng th√°i 'in_progress' cho stage hi·ªán t·∫°i
     */
    async function autoSelectInProgressRacks() {
        if (!currentEditingOrder) return;
        
        try {
            // L·∫•y d·ªØ li·ªáu input JSON ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i c·ªßa c√°c k·ªá
            const response = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/input_json/${STAGE_CONFIG.KEY}`);
            if (!response.ok) {
                console.log('‚ÑπÔ∏è Kh√¥ng c√≥ d·ªØ li·ªáu input JSON ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i k·ªá');
                return;
            }
            
            const data = await response.json();
            let raw = data && data.data ? data.data : null;
            if (!raw) return;
            
            if (typeof raw === 'string') {
                try { 
                    raw = JSON.parse(raw); 
                } catch (e) { 
                    console.warn('‚ö†Ô∏è L·ªói parse JSON:', e);
                    return; 
                }
            }
            
            // T√¨m t·∫•t c·∫£ c√°c key ch·ª©a "_ke_records" (v√≠ d·ª•: xa_ke_records)
            const keRecordsKeys = Object.keys(raw).filter(key => key.endsWith('_ke_records'));
            
            if (keRecordsKeys.length === 0) {
                console.log('‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu k·ªá trong input JSON');
                return;
            }
            
            // T√¨m k·ªá c√≥ tr·∫°ng th√°i 'in_progress' cho stage hi·ªán t·∫°i
            const currentStageStatusKey = `${STAGE_CONFIG.KEY}_status`;
            let availableRacks = [];
            
            keRecordsKeys.forEach(keRecordsKey => {
                const records = raw[keRecordsKey];
                if (Array.isArray(records)) {
                    records.forEach(record => {
                        const status = record[currentStageStatusKey];
                        if (status === 'in_progress') {
                            // L·∫•y s·ªë k·ªá t·ª´ ke_id - ∆∞u ti√™n current stage, n·∫øu kh√¥ng c√≥ th√¨ d√πng previous stage
                            const keId = record[`${STAGE_CONFIG.KEY}_ke_id`] || record.xa_ke_id || record.ke_id || '';
                            const match = keId.match(/(\d+)/);
                            if (match) {
                                const keNumber = parseInt(match[1]);
                                availableRacks.push({ keNumber, status });
                            }
                        }
                    });
                }
            });
            
            if (availableRacks.length > 0) {
                console.log(`üéØ [autoSelectInProgressRacks] T√¨m th·∫•y ${availableRacks.length} k·ªá ƒëang x·ª≠ l√Ω (in_progress):`, availableRacks);
                
                // T·ª± ƒë·ªông ch·ªçn c√°c k·ªá n√†y
                availableRacks.forEach(({ keNumber, status }) => {
                    const item = document.getElementById(`ke-${keNumber}`);
                    if (item && previousProcessData[keNumber] && !item.classList.contains('selected')) {
                        item.classList.add('selected');
                        selectedKe++;
                        
                        // L∆∞u th√¥ng tin k·ªá ƒë∆∞·ª£c ch·ªçn
                        keData[keNumber] = {
                            process: previousProcessData[keNumber],
                            status: 'selected'
                        };
                        
                        console.log(`‚úÖ [autoSelectInProgressRacks] T·ª± ƒë·ªông ch·ªçn k·ªá ${keNumber} (tr·∫°ng th√°i: ${status})`);
                    }
                });
                
                // C·∫≠p nh·∫≠t UI sau khi t·ª± ƒë·ªông ch·ªçn
                updateSummary();
                console.log(`üì¶ [autoSelectInProgressRacks] ƒê√£ t·ª± ƒë·ªông ch·ªçn ${availableRacks.length} k·ªá ƒëang x·ª≠ l√Ω (in_progress)`);
            } else {
                console.log('‚ÑπÔ∏è [autoSelectInProgressRacks] Kh√¥ng t√¨m th·∫•y k·ªá n√†o ƒëang x·ª≠ l√Ω (in_progress)');
            }
            
        } catch (error) {
            console.error('‚ùå [autoSelectInProgressRacks] L·ªói khi t·ª± ƒë·ªông ch·ªçn k·ªá ƒëang x·ª≠ l√Ω (in_progress):', error);
        }
    }

    // Production control functions
    async function startProduction() {

        const order = currentEditingOrder;
        if (!order) {
            showNotification('L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c l·ªánh s·∫£n xu·∫•t', 'error');
            return;
        }
        
        try {
    
            showLoading('ƒêang b·∫Øt ƒë·∫ßu ca l√†m vi·ªác...');
            
            // L·∫•y th√¥ng tin t·ª´ form trong sidebar
            const formData = getFormData();
            
            // Ki·ªÉm tra ƒë√£ ch·ªçn ca l√†m vi·ªác ch∆∞a
            if (!formData.shift) {
                showNotification('‚ö†Ô∏è Vui l√≤ng ch·ªçn ca l√†m vi·ªác', 'warning');
                return;
            }
            
            // L·∫•y m√°y ƒë∆∞·ª£c g√°n th·ª±c t·∫ø cho l·ªánh n√†y
            const assignedMachine = getOrderMachine(order);
            if (!assignedMachine) {
                showNotification(`‚ö†Ô∏è L·ªánh n√†y kh√¥ng ƒë∆∞·ª£c g√°n cho m√°y ${STAGE_CONFIG.NAME} n√†o`, 'warning');
                return;
            }
            
            // Validation c∆° b·∫£n
            if (!formData.worker || !formData.worker.trim()) {
                showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n th·ª£ ph·ª• tr√°ch trong ph·∫ßn "Th√¥ng tin s·∫£n xu·∫•t"', 'warning');
                return;
            }
            
            // L·∫•y s·ªë ca ti·∫øp theo
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            const nextShiftNumber = shiftsData.shifts && shiftsData.shifts.length > 0
                ? Math.max(...shiftsData.shifts.map(s => s.shift_number)) + 1
                : 1;
            
            const now = new Date();
            const shiftDate = now.toISOString().split('T')[0];
            
            const mysqlDateTime = formatDateTimeForMySQL(now);
            
            // T·∫°o ca l√†m vi·ªác m·ªõi v·ªõi status 'in_progress'
            const createShiftData = {
                production_order_id: order.id,
                production_order: order.production_order,
                stage: STAGE_CONFIG.KEY,
                shift_number: nextShiftNumber,
                shift_name: formData.shift,
                shift_date: shiftDate,
                worker_name: formData.worker,
                machine_name: assignedMachine,
                start_time: mysqlDateTime,
                end_time: null,
                work_duration_minutes: 0,
                good_quantity: 0,
                ng_quantity: 0,
                ng_start_end_quantity: 0,
                return_quantity: 0,
                output_quantity: 0,
                handover_quantity: 0,
                efficiency_percent: 0,
                quality_score: 0,
                handover_person: '',
                receiver_person: '',
                ng_reason: '',
                quality_notes: '',
                is_overtime: 0,
                overtime_hours: 0,
                is_night_shift: 0,
                break_duration_minutes: 0,
                status: 'in_progress',
                notes: formData.note || `B·∫Øt ƒë·∫ßu ca l√†m vi·ªác ${formData.shift}`
            };
            
            // T·∫°o shift m·ªõi
            const response = await fetch(`${API_BASE_URL}/data/production_orders_shift`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(createShiftData)
            });
            
            const result = await response.json();
            
            if (response.ok) {
    
                showNotification('‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu ca l√†m vi·ªác th√†nh c√¥ng!', 'success');
                
                // L∆∞u ID v√† th·ªùi gian b·∫Øt ƒë·∫ßu c·ªßa shift hi·ªán t·∫°i ƒë·ªÉ s·ª≠ d·ª•ng khi b√†n giao
                window.currentShiftId = result.shift_id;
                window.currentShiftStartTime = mysqlDateTime;

                
                // C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI TRONG {STAGE}_INPUT_QUANTITY_JSON
                try {
                    // 1. L·∫•y d·ªØ li·ªáu JSON hi·ªán t·∫°i
                    let existingInputData = null;
                    try {
                        const existingResp = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`);
                        if (existingResp.ok) {
                            const data = await existingResp.json();
                            let raw = data && data.data ? data.data : null;
                            if (raw && typeof raw === 'string') {
                                try { 
                                    raw = JSON.parse(raw); 
                                    existingInputData = raw;
                                } catch (e) { 
                                    console.log('Kh√¥ng th·ªÉ parse JSON input data:', e);
                                }
                            } else if (raw && typeof raw === 'object') {
                                existingInputData = raw;
                            }
                        }
                    } catch (e) {
                        console.log('‚ÑπÔ∏è Kh√¥ng c√≥ d·ªØ li·ªáu input JSON c≈© ho·∫∑c l·ªói khi ƒë·ªçc:', e);
                    }
                    
                    // 2. C·∫≠p nh·∫≠t tr·∫°ng th√°i t·ª´ waiting th√†nh in_progress cho stage xen
                    if (existingInputData) {
                        // T√¨m t·∫•t c·∫£ c√°c key ch·ª©a "_ke_records" (v√≠ d·ª•: xa_ke_records)
                        const keRecordsKeys = Object.keys(existingInputData).filter(key => key.endsWith('_ke_records'));
                        
                        // Ki·ªÉm tra xem c√≥ k·ªá n√†o ƒë∆∞·ª£c ch·ªçn c·ª• th·ªÉ kh√¥ng
                        const selectedKeId = formData.selectedKeId || null; // ID c√≥ d·∫°ng "ke-1", "ke-2", v.v.
                        console.log(`üéØ [startProduction] K·ªá ƒë∆∞·ª£c ch·ªçn: ${selectedKeId}`);
                        
                        keRecordsKeys.forEach(keRecordsKey => {
                            const records = existingInputData[keRecordsKey];
                            if (Array.isArray(records)) {
                                // C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa c√°c k·ªá
                                existingInputData[keRecordsKey] = records.map(record => {
                                    // T·∫°o b·∫£n sao c·ªßa record ƒë·ªÉ tr√°nh thay ƒë·ªïi d·ªØ li·ªáu g·ªëc
                                    const updatedRecord = { ...record };
                                    
                                    // T√¨m tr∆∞·ªùng status c·ªßa stage hi·ªán t·∫°i (xen_status)
                                    const currentStageStatusKey = `${STAGE_CONFIG.KEY}_status`;
                                    
                                    // N·∫øu c√≥ ch·ªçn k·ªá c·ª• th·ªÉ
                                    if (selectedKeId) {
                                        // Ch·ªâ c·∫≠p nh·∫≠t k·ªá ƒë∆∞·ª£c ch·ªçn
                                        // selectedKeId c√≥ d·∫°ng "ke-1" -> chuy·ªÉn th√†nh "ke_1" ƒë·ªÉ match v·ªõi database
                                        const targetKeId = selectedKeId.replace('-', '_');
                                        const recordKeId = record.xa_ke_id || record.ke_id || '';
                                        
                                        console.log(`üîç [startProduction] So s√°nh: ${recordKeId} v·ªõi ${targetKeId}`);
                                        
                                        if (recordKeId === targetKeId && updatedRecord[currentStageStatusKey] === 'waiting') {
                                            updatedRecord[currentStageStatusKey] = 'in_progress';
                                            console.log(`üîÑ [startProduction] C·∫≠p nh·∫≠t k·ªá ƒë∆∞·ª£c ch·ªçn ${recordKeId} t·ª´ waiting -> in_progress`);
                                        }
                                    } else {
                                        // N·∫øu kh√¥ng ch·ªçn k·ªá c·ª• th·ªÉ, ch·ªâ c·∫≠p nh·∫≠t k·ªá ƒë·∫ßu ti√™n c√≥ tr·∫°ng th√°i waiting
                                        if (updatedRecord[currentStageStatusKey] === 'waiting') {
                                            // Ki·ªÉm tra xem ƒë√£ c√≥ k·ªá n√†o ƒë∆∞·ª£c c·∫≠p nh·∫≠t ch∆∞a
                                            const alreadyUpdated = records.some(r => r[currentStageStatusKey] === 'in_progress');
                                            if (!alreadyUpdated) {
                                                updatedRecord[currentStageStatusKey] = 'in_progress';
                                                console.log(`üîÑ [startProduction] C·∫≠p nh·∫≠t k·ªá ƒë·∫ßu ti√™n ${record.xa_ke_id || record.ke_id || 'k·ªá'} t·ª´ waiting -> in_progress`);
                                            }
                                        }
                                    }
                                    
                                    return updatedRecord;
                                });
                            }
                        });
                        
                        // C·∫≠p nh·∫≠t metadata n·∫øu c√≥
                        const metadataKeys = Object.keys(existingInputData).filter(key => key.endsWith('_metadata'));
                        metadataKeys.forEach(metadataKey => {
                            if (existingInputData[metadataKey]) {
                                existingInputData[metadataKey] = {
                                    ...existingInputData[metadataKey],
                                    updated_at: new Date().toISOString(),
                                    last_action: 'start_production',
                                    last_updated_by: formData.worker,
                                    last_updated_stage: STAGE_CONFIG.KEY
                                };
                            }
                        });
                        
                        console.log('üì¶ [startProduction] D·ªØ li·ªáu JSON input sau khi c·∫≠p nh·∫≠t:', existingInputData);
                        
                        // 3. L∆∞u d·ªØ li·ªáu JSON ƒë√£ c·∫≠p nh·∫≠t
                        const saveInputResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                ke_data_json: existingInputData
                            })
                        });
                        
                        if (saveInputResponse.ok) {
                            console.log('‚úÖ [startProduction] ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i trong input JSON th√†nh c√¥ng');
                        } else {
                            const saveError = await saveInputResponse.json();
                            console.warn('‚ö†Ô∏è [startProduction] L·ªói c·∫≠p nh·∫≠t input JSON:', saveError);
                        }
                    } else {
                        console.log('‚ÑπÔ∏è [startProduction] Kh√¥ng c√≥ d·ªØ li·ªáu input JSON ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i');
                    }
                } catch (inputJsonError) {
                    console.warn('‚ö†Ô∏è [startProduction] L·ªói khi x·ª≠ l√Ω input JSON:', inputJsonError);
                }
                
                // C·∫≠p nh·∫≠t tr·∫°ng th√°i production_orders v·ªõi stage_status = 'in_progress'
                try {
                    const orderUpdateData = {
                        status: 'in_progress',
                        [`${STAGE_CONFIG.KEY}_status`]: 'in_progress',
                        [`${STAGE_CONFIG.KEY}_worker_name`]: formData.worker,
                        [`${STAGE_CONFIG.KEY}_machine_name`]: assignedMachine,
                        [`${STAGE_CONFIG.KEY}_start_time`]: mysqlDateTime
                    };
                    

                    
                    const updateOrderResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(orderUpdateData)
                    });
                    
                    if (updateOrderResponse.ok) {
                        console.log('‚úÖ [startProduction] Production order status updated successfully');
                    } else {
                        const updateError = await updateOrderResponse.json();
                        console.warn('‚ö†Ô∏è Failed to update production order status:', updateError);
                    }
                } catch (updateError) {
                    console.warn('‚ö†Ô∏è Error updating production order status:', updateError);
                    // Kh√¥ng throw error v√¨ ƒë√¢y kh√¥ng ph·∫£i l·ªói nghi√™m tr·ªçng
                }
                
                // C·∫≠p nh·∫≠t UI ƒë·ªÉ hi·ªÉn th·ªã th·ªùi gian b·∫Øt ƒë·∫ßu
                const startTimeElement = document.querySelector('.detail-section .alert .row .col-6:first-child span');
                if (startTimeElement) {
                    startTimeElement.textContent = formatDateTime(new Date(mysqlDateTime));
                    startTimeElement.classList.add('text-primary');
                }
                
                // C·∫≠p nh·∫≠t th·ªùi gian b·∫Øt ƒë·∫ßu trong sidebar
                const startTimeInfo = document.getElementById('startTimeInfo');
                if (startTimeInfo) {
                    // Hi·ªÉn th·ªã th·ªùi gian ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng
                    startTimeInfo.textContent = formatDateTime(mysqlDateTime);

                }
                
                // Hi·ªÉn th·ªã ƒë·ªìng h·ªì th·ªùi gian
                const timeDisplayContainer = document.querySelector('.detail-section .alert');
                if (timeDisplayContainer) {
                    // Ki·ªÉm tra xem ƒë√£ c√≥ ph·∫ßn hi·ªÉn th·ªã th·ªùi gian ch·∫°y ch∆∞a
                    let timerSection = timeDisplayContainer.querySelector('.text-center');
                    
                    if (!timerSection) {
                        // T·∫°o ph·∫ßn hi·ªÉn th·ªã th·ªùi gian ch·∫°y n·∫øu ch∆∞a c√≥
                        const timerHtml = `
                            <hr class="my-2">
                            <div class="text-center">
                                <strong>Th·ªùi gian ƒëang ch·∫°y:</strong><br>
                                <span class="text-warning" id="productionRunningTime">ƒêang t√≠nh...</span>
                            </div>
                        `;
                        timeDisplayContainer.insertAdjacentHTML('beforeend', timerHtml);
                    }
                    
                    // B·∫Øt ƒë·∫ßu timer ngay l·∫≠p t·ª©c
                    startProductionTimer();
                }
                
                // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
                const startBtn = document.getElementById('startBtn');
                const handoverBtn = document.getElementById('handoverShiftBtn');
                const stopAndHandoverBtn = document.getElementById('stopAndHandoverBtn');
                const resetBtn = document.getElementById('resetBtn');
                
                // ·∫®n n√∫t b·∫Øt ƒë·∫ßu, hi·ªÉn th·ªã c√°c n√∫t kh√°c
                if (startBtn) {
                    startBtn.style.display = 'none';
                    startBtn.disabled = true;
                }
                
                if (handoverBtn) {
                    handoverBtn.style.display = 'flex';
                    handoverBtn.disabled = false;
                }
                
                if (stopAndHandoverBtn) {
                    stopAndHandoverBtn.style.display = 'flex';
                    stopAndHandoverBtn.disabled = false;
                }
                
                if (resetBtn) {
                    resetBtn.style.display = 'flex';
                    resetBtn.disabled = false;
                }
                
                // Refresh d·ªØ li·ªáu t·ª´ API
                await refreshData();
                
                // Refresh sidebar content
                showOrderDetails(order.id);
            } else {
                throw new Error(`API error: ${response.status} - ${result.message || result.error || 'Unknown error'}`);
            }
            
        } catch (error) {
            console.error('‚ùå L·ªói trong startProduction:', error);
            console.error('‚ùå Error stack:', error.stack);
            showNotification('L·ªói khi b·∫Øt ƒë·∫ßu s·∫£n xu·∫•t: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }
    






 /**
     * Reset l·ªánh s·∫£n xu·∫•t v·ªÅ tr·∫°ng th√°i ch∆∞a b·∫Øt ƒë·∫ßu
     */
     async function resetProduction() {
        const order = currentEditingOrder;
        
        if (!order) {
            showNotification('L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c l·ªánh s·∫£n xu·∫•t', 'error');
            return;
        }
        
        // Hi·ªÉn th·ªã dialog x√°c nh·∫≠n
        const confirmed = confirm('‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset l·ªánh s·∫£n xu·∫•t n√†y v·ªÅ tr·∫°ng th√°i ch∆∞a b·∫Øt ƒë·∫ßu?\n\nƒêi·ªÅu n√†y s·∫Ω:\n‚Ä¢ X√≥a th·ªùi gian b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c\n‚Ä¢ Reset tr·∫°ng th√°i v·ªÅ "ch∆∞a b·∫Øt ƒë·∫ßu"\n‚Ä¢ X√≥a d·ªØ li·ªáu s·∫£n xu·∫•t (s·ªë l∆∞·ª£ng, ghi ch√∫, v.v.)\n\nH√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!');
        
        if (!confirmed) {
            return;
        }
        
        try {
            showLoading('ƒêang reset l·ªánh s·∫£n xu·∫•t...');
            
            // Chu·∫©n b·ªã d·ªØ li·ªáu reset
            const resetData = {
                stage: STAGE_CONFIG.KEY,
                reset_to_not_started: true
            };
            
            // G·ª≠i request ƒë·∫øn API ƒë·ªÉ reset
            const response = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/reset_production`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(resetData)
            });
            
            const result = await response.json();
            
            if (response.ok) {
                // D·ª´ng timer n·∫øu ƒëang ch·∫°y
                stopProductionTimer();
                
                showNotification('‚úÖ ƒê√£ reset l·ªánh s·∫£n xu·∫•t th√†nh c√¥ng!', 'success');
                
                // C·∫≠p nh·∫≠t d·ªØ li·ªáu local
                if (currentEditingOrder) {
                    setOrderField(currentEditingOrder, 'status', 'waiting');
                    setOrderField(currentEditingOrder, 'start_time', null);
                    setOrderField(currentEditingOrder, 'end_time', null);
                    setOrderField(currentEditingOrder, 'worker', '');
                    setOrderField(currentEditingOrder, 'shift', '');
                    setOrderField(currentEditingOrder, 'good_quantity', 0);
                    setOrderField(currentEditingOrder, 'ng_quantity', 0);
                    setOrderField(currentEditingOrder, 'handover_quantity', 0);
                    setOrderField(currentEditingOrder, 'note', '');
                }
                
                await refreshData();
                
                // Refresh sidebar content
                showOrderDetails(order.id);
                
            } else {
                throw new Error(`API error: ${response.status} - ${result.message || result.error || 'Unknown error'}`);
            }
            
        } catch (error) {
            console.error('Reset production error:', error);
            
            // Fallback: N·∫øu API kh√¥ng h·ªó tr·ª£ reset, th·ª±c hi·ªán reset local
            if (error.message.includes('404') || error.message.includes('not found')) {
                showNotification('‚ö†Ô∏è API reset kh√¥ng kh·∫£ d·ª•ng, th·ª±c hi·ªán reset local...', 'warning');
                
                // Reset local data
                if (currentEditingOrder) {
                    setOrderField(currentEditingOrder, 'status', 'waiting');
                    setOrderField(currentEditingOrder, 'start_time', null);
                    setOrderField(currentEditingOrder, 'end_time', null);
                    setOrderField(currentEditingOrder, 'worker', '');
                    setOrderField(currentEditingOrder, 'shift', '');
                    setOrderField(currentEditingOrder, 'good_quantity', 0);
                    setOrderField(currentEditingOrder, 'ng_quantity', 0);
                    setOrderField(currentEditingOrder, 'handover_quantity', 0);
                    setOrderField(currentEditingOrder, 'note', '');
                }
                
                // D·ª´ng timer
                stopProductionTimer();
                
                // Refresh UI
                await refreshData();
                showOrderDetails(order.id);
                
                showNotification('‚úÖ ƒê√£ reset l·ªánh s·∫£n xu·∫•t (local)!', 'success');
            } else {
                showNotification('L·ªói khi reset l·ªánh s·∫£n xu·∫•t: ' + error.message, 'error');
            }
        } finally {
            hideLoading();
        }
    }



    // Utility functions for time display
    function formatDateTime(dateString) {
        if (!dateString) return 'N/A';
    
    try {
        // X√≥a Z ƒë·ªÉ JS kh√¥ng coi l√† UTC
        const localDateString = dateString.replace('Z', '');
        const date = new Date(localDateString);

        return date.toLocaleString('vi-VN', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            day: '2-digit',
            month: '2-digit',
            year: 'numeric'
        });
    } catch (error) {
        console.error('Error formatting date:', error);
        return 'Error';
    }
    }
    
 
    
    function formatDateTimeForInput(dateString) {
        if (!dateString) return '';
        
        try {
            const date = new Date(dateString);
            
            // Ki·ªÉm tra date c√≥ h·ª£p l·ªá kh√¥ng
            if (isNaN(date.getTime())) {
                console.error('Invalid date in formatDateTimeForInput:', dateString);
                return '';
            }
            
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        } catch (error) {
            console.error('Error in formatDateTimeForInput:', error);
            return '';
        }
    }
    
    function calculateWorkTime(startTime, endTime) {
        if (!startTime || !endTime) return 'N/A';
        
        try {
            const start = new Date(startTime);
            const end = new Date(endTime);
            
            // Ki·ªÉm tra n·∫øu date kh√¥ng h·ª£p l·ªá
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                console.error('Invalid date in calculateWorkTime:', { startTime, endTime });
                return 'Invalid date';
            }
            
            const diffMs = end - start;
            
            // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p th·ªùi gian √¢m
            if (diffMs < 0) {
                console.warn('Negative time difference in calculateWorkTime:', { startTime, endTime, diffMs });
                return '00:00:00';
            }

            const hours = Math.floor(diffMs / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        } catch (error) {
            console.error('Error calculating work time:', error);
            return 'Error';
        }
    }

    // Format datetime cho MySQL (YYYY-MM-DD HH:mm:ss)
    function formatDateTimeForMySQL(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    // Bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ ID c·ªßa timer
    let productionTimerId = null;

    /**
     * =================================================================
     * TAB SWITCHING FUNCTIONS - H√ÄM CHUY·ªÇN ƒê·ªîI TAB
     * =================================================================
     */

    /**
     * Switch between tabs in the sidebar
     */
    function switchTab(tabName) {

        
        // Remove active class from all tabs and panels in sidebar only
        document.querySelectorAll('.details-panel .tab-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.details-panel .tab-panel').forEach(panel => panel.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding panel
        const clickedTab = event.target.closest('.tab-btn');
        if (clickedTab) {
            clickedTab.classList.add('active');
        }
        
        const targetPanel = document.getElementById(tabName + '-panel');
        if (targetPanel) {
            targetPanel.classList.add('active');
    
        } else {
            console.error('‚ùå Panel not found:', tabName + '-panel');
        }
        
        // Load shifts data if switching to shifts tab
        if (tabName === 'shifts' && currentEditingOrder) {
            loadShiftsData(currentEditingOrder.id);
        }
    }

    /**
     * Load shifts data for an order
     */
    async function loadShiftsData(orderId) {
        const shiftsList = document.getElementById('shiftsList');
        const shiftsLoading = document.getElementById('shiftsLoading');
        
        if (!shiftsList || !shiftsLoading) {
            console.error('Shifts elements not found');
            return;
        }
        

        
        try {
            // Show loading
            shiftsLoading.style.display = 'flex';
            shiftsList.innerHTML = '';
            
            const apiUrl = `${API_BASE_URL}/data/production_orders/${orderId}/shifts?stage=${STAGE_CONFIG.KEY}`;

            
            // Fetch shifts data
            const response = await fetch(apiUrl);

            
            const data = await response.json();
                        if (response.ok) {
                
                renderShiftsList(data.shifts);
            } else {
                console.error('‚ùå API error:', response.status, data);
                throw new Error(data.error || 'Failed to load shifts data');
            }
        } catch (error) {
            console.error('üí• Error loading shifts data:', error);
            console.error('üí• Error stack:', error.stack);
            shiftsList.innerHTML = `
                <div class="empty-state">
                    <i class="bi bi-exclamation-triangle"></i>
                    <h5>Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu ca l√†m vi·ªác</h5>
                    <p>${error.message}</p>
                </div>
            `;
        } finally {
            shiftsLoading.style.display = 'none';
        }
    }
    
    /**
     * Render shifts list
     */
    function renderShiftsList(shifts) {
        const shiftsList = document.getElementById('shiftsList');
        
        if (!shiftsList) {
            console.error('‚ùå Shifts list element not found!');
            return;
        }
        
        if (!shifts || shifts.length === 0) {
            shiftsList.innerHTML = `
                <div class="empty-state">
                    <i class="bi bi-clock-history"></i>
                    <h5>Ch∆∞a c√≥ ca l√†m vi·ªác n√†o</h5>
                    <p>Ca l√†m vi·ªác s·∫Ω ƒë∆∞·ª£c t·∫°o khi b·∫Øt ƒë·∫ßu s·∫£n xu·∫•t</p>
                </div>
            `;
            return;
        }

        // T√≠nh to√°n th·ªëng k√™
        const completedShifts = shifts.filter(s => s.status === 'completed').length;
        const inProgressShifts = shifts.filter(s => s.status === 'in_progress').length;
        const pendingShifts = shifts.filter(s => s.status === 'pending').length;
        const totalQuantity = shifts.reduce((sum, s) => sum + (parseInt(s.handover_quantity) || 0), 0);

        // T·∫°o HTML cho th·ªëng k√™
        const statsHtml = `
            <div class="shifts-stats">
                <div class="stat-card">
                    <div class="stat-number">${completedShifts}</div>
                    <div class="stat-label">ƒê√£ ho√†n th√†nh</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${inProgressShifts}</div>
                    <div class="stat-label">ƒêang ch·∫°y</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${pendingShifts}</div>
                    <div class="stat-label">Ch·ªù b·∫Øt ƒë·∫ßu</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalQuantity.toLocaleString()}</div>
                    <div class="stat-label">T·ªïng s·∫£n l∆∞·ª£ng</div>
                </div>
            </div>
        `;
        
        const shiftsHtml = shifts.map(shift => {
            const statusClass = getShiftStatusClass(shift.status);
            const statusText = getShiftStatusText(shift.status);
            const startTime = shift.start_time ? formatDateTime(shift.start_time) : '--';
            const endTime = shift.end_time ? formatDateTime(shift.end_time) : '--';
            const workDuration = shift.work_duration_minutes ? `${shift.work_duration_minutes} ph√∫t` : '--';
            const efficiency = shift.efficiency_percent && !isNaN(shift.efficiency_percent) ? 
                `${parseFloat(shift.efficiency_percent).toFixed(1)}%` : '--';
            
            // T√≠nh to√°n progress cho ca ƒëang ch·∫°y
            let progressHtml = '';
            if (shift.status === 'in_progress' && shift.start_time) {
                const start = new Date(shift.start_time);
                const now = new Date();
                const totalDuration = 8 * 60; // 8 gi·ªù = 480 ph√∫t
                const elapsed = Math.floor((now - start) / (1000 * 60));
                const progress = Math.min(100, Math.max(0, (elapsed / totalDuration) * 100));
                const remaining = Math.max(0, totalDuration - elapsed);
                const remainingHours = Math.floor(remaining / 60);
                const remainingMinutes = remaining % 60;
                
                progressHtml = `
                    <div class="shift-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <div class="progress-text">${progress.toFixed(0)}% ho√†n th√†nh - C√≤n ${remainingHours} gi·ªù ${remainingMinutes} ph√∫t</div>
                    </div>
                `;
            }
            
            return `
                <div class="shift-item">
                    <div class="shift-header">
                        <div class="shift-title">
                            <i class="bi bi-clock"></i>
                            ${shift.shift_name || `Ca ${shift.shift_number}`}
                        </div>
                        <span class="shift-status ${statusClass}">${statusText}</span>
                    </div>
                    
                    <div class="shift-details">
                        <div class="shift-detail">
                            <div class="shift-detail-label">Th·ª£ ph·ª• tr√°ch</div>
                            <div class="shift-detail-value">${shift.worker_name || '--'}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">M√°y s·∫£n xu·∫•t</div>
                            <div class="shift-detail-value">${shift.machine_name || '--'}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">S·ªë l∆∞·ª£ng OK</div>
                            <div class="shift-detail-value">${shift.handover_quantity || 0}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">S·ªë l∆∞·ª£ng NG</div>
                            <div class="shift-detail-value">${(parseInt(shift.ng_quantity) || 0) + (parseInt(shift.ng_start_end_quantity) || 0)}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">Hi·ªáu su·∫•t</div>
                            <div class="shift-detail-value">${efficiency}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">Th·ªùi gian l√†m vi·ªác</div>
                            <div class="shift-detail-value">${workDuration}</div>
                        </div>
                    </div>

                    ${progressHtml}
                    
                    <div class="shift-times">
                        <span><i class="bi bi-play-circle"></i>B·∫Øt ƒë·∫ßu: ${startTime}</span>
                        <span><i class="bi bi-stop-circle"></i>K·∫øt th√∫c: ${endTime}</span>
                    </div>

                    <div class="shift-actions">
                        <a href="#" class="btn-action btn-view" onclick="viewShiftDetails('${shift.id}')">
                            <i class="bi bi-eye"></i>Xem chi ti·∫øt
                        </a>
                        ${shift.status === 'in_progress' ? `
                            <a href="#" class="btn-action btn-edit" onclick="editShift('${shift.id}')">
                                <i class="bi bi-pencil"></i>Ch·ªânh s·ª≠a
                            </a>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join('');
        
        shiftsList.innerHTML = statsHtml + shiftsHtml;
    }
    

    
    /**
     * Get shift status class for CSS
     */
    function getShiftStatusClass(status) {
        switch (status) {
            case 'completed': return 'completed';
            case 'in_progress': return 'in_progress';
            case 'waiting': return 'waiting';
            case 'paused': return 'paused';
            case 'handed_over': return 'handed_over';
            default: return 'waiting';
        }
    }
    
    /**
     * Get shift status text
     */
    function getShiftStatusText(status) {
        switch (status) {
            case 'completed': return 'Ho√†n th√†nh';
            case 'in_progress': return 'ƒêang l√†m';
            case 'waiting': return 'Ch·ªù';
            case 'paused': return 'T·∫°m d·ª´ng';
            case 'handed_over': return 'ƒê√£ b√†n giao';
            default: return 'Ch·ªù';
        }
    }

    /**
     * View shift details
     */
    function viewShiftDetails(shiftId) {
        console.log('üîç Viewing shift details for:', shiftId);
        // TODO: Implement shift details view
        showNotification('T√≠nh nƒÉng xem chi ti·∫øt ca l√†m vi·ªác ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn', 'info');
    }

    /**
     * Edit shift
     */
    function editShift(shiftId) {
        console.log('‚úèÔ∏è Editing shift:', shiftId);
        // TODO: Implement shift editing
        showNotification('T√≠nh nƒÉng ch·ªânh s·ª≠a ca l√†m vi·ªác ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn', 'info');
    }

    /**
     * B√†n giao ca l√†m vi·ªác
     */
    async function handoverShift() {
        const order = currentEditingOrder;
        
        if (!order) {
            showNotification('L·ªói: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c l·ªánh s·∫£n xu·∫•t', 'error');
            return;
        }
        
        // Ki·ªÉm tra c√≥ shift ƒëang ch·∫°y kh√¥ng
        if (!window.currentShiftId) {
            showNotification('‚ö†Ô∏è Kh√¥ng c√≥ ca l√†m vi·ªác n√†o ƒëang ch·∫°y. Vui l√≤ng b·∫Øt ƒë·∫ßu ca tr∆∞·ªõc khi b√†n giao.', 'warning');
            return;
        }
        
        // L·∫•y th√¥ng tin t·ª´ form trong sidebar
        const formData = getFormData();
        const goodQuantity = formData.goodQty;
        const ngQuantity = formData.ngQty;
        const ngStartEndQuantity = formData.ngStartEndQty;
        const returnQuantity = formData.returnQty;
        const handoverQuantity = formData.handoverQty;
        const workerName = formData.worker;
        const shift = formData.shift || getCurrentShift();
        const notes = formData.note;
        
        // L·∫•y m√°y ƒë∆∞·ª£c g√°n th·ª±c t·∫ø cho l·ªánh n√†y
        const assignedMachine = getOrderMachine(order);
        if (!assignedMachine) {
            showNotification(`‚ö†Ô∏è L·ªánh n√†y kh√¥ng ƒë∆∞·ª£c g√°n cho m√°y ${STAGE_CONFIG.NAME} n√†o`, 'warning');
            return;
        }
        
        // Validation c∆° b·∫£n
        if (!workerName || !workerName.trim()) {
            showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n th·ª£ ph·ª• tr√°ch trong ph·∫ßn "Th√¥ng tin s·∫£n xu·∫•t"', 'warning');
            return;
        }
        
        // L·∫•y t·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn (ch·ªâ k·ªá c√≥ status 'in_progress')
        const selectedRackTotalQuantity = await getTotalQuantityInSelectedRacks();
        console.log(`üìä [handoverShift] T·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn: ${selectedRackTotalQuantity}`);
        
        // Ki·ªÉm tra c√≥ k·ªá s·∫µn s√†ng ƒë·ªÉ b√†n giao ch∆∞a
        if (selectedRackTotalQuantity <= 0) {
            showNotification('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y k·ªá n√†o ƒëang x·ª≠ l√Ω (in_progress) ƒë·ªÉ b√†n giao. Vui l√≤ng ki·ªÉm tra l·∫°i tr·∫°ng th√°i k·ªá.', 'warning');
            return;
        }
        
        // T√≠nh t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
        const totalEnteredQuantity = goodQuantity + ngQuantity + ngStartEndQuantity + returnQuantity;
        console.log(`üìù [handoverShift] T·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p: ${totalEnteredQuantity} (OK: ${goodQuantity}, NG: ${ngQuantity}, NG ƒë·∫ßu/cu·ªëi: ${ngStartEndQuantity}, Tr·∫£: ${returnQuantity})`);
        
        // Ki·ªÉm tra logic: T·ªïng s·ªë l∆∞·ª£ng nh·∫≠p ph·∫£i b·∫±ng t·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn
        if (totalEnteredQuantity !== selectedRackTotalQuantity) {
            const errorMessage = `‚ùå S·ªë l∆∞·ª£ng kh√¥ng kh·ªõp!\n\n` +
                `üì• T·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p: ${totalEnteredQuantity}\n` +
                `üì¶ T·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn: ${selectedRackTotalQuantity}\n\n` +
                `Chi ti·∫øt s·ªë l∆∞·ª£ng nh·∫≠p:\n` +
                `‚Ä¢ OK: ${goodQuantity}\n` +
                `‚Ä¢ NG: ${ngQuantity}\n` +
                `‚Ä¢ NG ƒë·∫ßu/cu·ªëi: ${ngStartEndQuantity}\n` +
                `‚Ä¢ Tr·∫£: ${returnQuantity}\n\n` +
                `Vui l√≤ng ƒëi·ªÅu ch·ªânh s·ªë l∆∞·ª£ng nh·∫≠p cho kh·ªõp v·ªõi t·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn.`;
            
            showNotification(errorMessage, 'error');
            return;
        }
        
        // Ki·ªÉm tra ph·∫£i c√≥ √≠t nh·∫•t m·ªôt lo·∫°i s·∫£n ph·∫©m ƒë∆∞·ª£c nh·∫≠p
        if (totalEnteredQuantity <= 0) {
            showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt lo·∫°i s·ªë l∆∞·ª£ng (OK, NG, NG ƒë·∫ßu/cu·ªëi, ho·∫∑c Tr·∫£)', 'warning');
            return;
        }
        
        // Ki·ªÉm tra s·ªë l∆∞·ª£ng b√†n giao kh√¥ng v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng OK
        if (handoverQuantity > goodQuantity) {
            showNotification(`‚ö†Ô∏è S·ªë l∆∞·ª£ng b√†n giao (${handoverQuantity}) kh√¥ng th·ªÉ l·ªõn h∆°n s·ªë l∆∞·ª£ng OK (${goodQuantity})`, 'error');
            return;
        }
        
        // Ki·ªÉm tra s·ªë l∆∞·ª£ng b√†n giao ph·∫£i > 0 n·∫øu c√≥ s·ªë l∆∞·ª£ng OK
        if (goodQuantity > 0 && handoverQuantity <= 0) {
            showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng b√†n giao khi c√≥ s·∫£n ph·∫©m OK', 'warning');
            return;
        }
        
        // Validate t·ªïng s·ªë l∆∞·ª£ng kh√¥ng v∆∞·ª£t qu√° s·ªë l∆∞·ª£ng ƒë·∫ßu v√†o (n·∫øu c·∫ßn)
        if (!(await validateTotalQuantity(order, goodQuantity, ngQuantity, ngStartEndQuantity, returnQuantity))) {
            return;
        }
        
        // Hi·ªÉn th·ªã dialog x√°c nh·∫≠n v·ªõi th√¥ng tin ƒë√£ ƒë∆∞·ª£c validation
        const confirmationMessage = `üìã X√°c nh·∫≠n b√†n giao ca l√†m vi·ªác?\n\n` +
            `L·ªánh s·∫£n xu·∫•t: ${order.production_order}\n` +
            `Th·ª£ ph·ª• tr√°ch: ${workerName}\n` +
            `Ca l√†m vi·ªác: ${shift}\n\n` +
            `üìä S·ªë l∆∞·ª£ng:\n` +
            `‚Ä¢ OK: ${goodQuantity.toLocaleString()}\n` +
            `‚Ä¢ NG: ${ngQuantity.toLocaleString()}\n` +
            `‚Ä¢ NG ƒë·∫ßu/cu·ªëi: ${ngStartEndQuantity.toLocaleString()}\n` +
            `‚Ä¢ Tr·∫£: ${returnQuantity.toLocaleString()}\n` +
            `‚Ä¢ T·ªïng nh·∫≠p: ${totalEnteredQuantity.toLocaleString()}\n` +
            `‚Ä¢ B√†n giao: ${handoverQuantity.toLocaleString()}\n\n` +
            `üì¶ T·ªïng k·ªá ƒë√£ ch·ªçn: ${selectedRackTotalQuantity.toLocaleString()}\n\n` +
            `‚úÖ S·ªë l∆∞·ª£ng ƒë√£ ƒë∆∞·ª£c x√°c th·ª±c kh·ªõp!\n\n` +
            `Th√¥ng tin n√†y s·∫Ω ƒë∆∞·ª£c l∆∞u v√†o l·ªãch s·ª≠ ca l√†m vi·ªác.`;
        
        if (!confirm(confirmationMessage)) {
            return;
        }
        
        try {
            showLoading('ƒêang b√†n giao ca l√†m vi·ªác...');
            
            const now = new Date();
            const outputQuantity = goodQuantity + ngQuantity + ngStartEndQuantity + returnQuantity;
            const efficiencyPercent = outputQuantity > 0 ? (goodQuantity / outputQuantity) * 100 : 0;
            
            const mysqlDateTime = formatDateTimeForMySQL(now);
            

            
            // T√≠nh th·ªùi gian l√†m vi·ªác (work_duration_minutes)
            let workDurationMinutes = 0;
            if (window.currentShiftStartTime) {
                const startTime = new Date(window.currentShiftStartTime);
                const endTime = new Date(mysqlDateTime);
                workDurationMinutes = Math.round((endTime - startTime) / (1000 * 60));
            }
            
            // C·∫≠p nh·∫≠t shift hi·ªán t·∫°i v·ªõi th√¥ng tin b√†n giao
            const updateData = {
                end_time: mysqlDateTime,
                work_duration_minutes: workDurationMinutes,
                good_quantity: goodQuantity,
                ng_quantity: ngQuantity,
                ng_start_end_quantity: ngStartEndQuantity,
                return_quantity: returnQuantity,
                output_quantity: outputQuantity,
                handover_quantity: handoverQuantity,
                efficiency_percent: efficiencyPercent,
                handover_person: workerName,
                machine_name: assignedMachine,
                status: 'completed',
                notes: notes
            };
            
        
            const updateResponse = await fetch(`${API_BASE_URL}/data/production_orders_shift/${window.currentShiftId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(updateData)
            });
            
            const updateResult = await updateResponse.json();
            
            if (updateResponse.ok) {
                
                // C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI K·ªÜ T·ª™ IN_PROGRESS SANG COMPLETED TRONG INPUT JSON
                try {
                    // 1. L·∫•y d·ªØ li·ªáu input JSON hi·ªán t·∫°i
                    let existingInputData = null;
                    try {
                        const existingResp = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`);
                        if (existingResp.ok) {
                            const data = await existingResp.json();
                            let raw = data && data.data ? data.data : null;
                            if (raw && typeof raw === 'string') {
                                try { 
                                    raw = JSON.parse(raw); 
                                    existingInputData = raw;
                                } catch (e) { 
                                    console.log('Kh√¥ng th·ªÉ parse JSON input data:', e);
                                }
                            } else if (raw && typeof raw === 'object') {
                                existingInputData = raw;
                            }
                        }
                    } catch (e) {
                        console.log('‚ÑπÔ∏è Kh√¥ng c√≥ d·ªØ li·ªáu input JSON c≈© ho·∫∑c l·ªói khi ƒë·ªçc:', e);
                    }
                    
                    // 2. C·∫≠p nh·∫≠t tr·∫°ng th√°i t·ª´ in_progress th√†nh completed
                    if (existingInputData) {
                        // T√¨m t·∫•t c·∫£ c√°c key ch·ª©a "_ke_records"
                        const keRecordsKeys = Object.keys(existingInputData).filter(key => key.endsWith('_ke_records'));
                        
                        // L·∫•y k·ªá ƒë∆∞·ª£c ch·ªçn
                        const selectedKeId = formData.selectedKeId || null;
                        console.log(`üéØ [handoverShift] K·ªá ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ ho√†n th√†nh: ${selectedKeId}`);
                        
                        keRecordsKeys.forEach(keRecordsKey => {
                            const records = existingInputData[keRecordsKey];
                            if (Array.isArray(records)) {
                                // C·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa c√°c k·ªá
                                existingInputData[keRecordsKey] = records.map(record => {
                                    // T·∫°o b·∫£n sao c·ªßa record ƒë·ªÉ tr√°nh thay ƒë·ªïi d·ªØ li·ªáu g·ªëc
                                    const updatedRecord = { ...record };
                                    
                                    // T√¨m tr∆∞·ªùng status c·ªßa stage hi·ªán t·∫°i
                                    const currentStageStatusKey = `${STAGE_CONFIG.KEY}_status`;
                                    
                                    // N·∫øu c√≥ ch·ªçn k·ªá c·ª• th·ªÉ, ch·ªâ c·∫≠p nh·∫≠t k·ªá ƒë√≥
                                    if (selectedKeId) {
                                        // Ch·ªâ c·∫≠p nh·∫≠t k·ªá ƒë∆∞·ª£c ch·ªçn t·ª´ in_progress -> completed
                                        const targetKeId = selectedKeId.replace('-', '_');
                                        const recordKeId = record.xa_ke_id || record.ke_id || '';
                                        
                                        console.log(`üîç [handoverShift] So s√°nh: ${recordKeId} v·ªõi ${targetKeId} (status: ${updatedRecord[currentStageStatusKey]})`);
                                        
                                        if (recordKeId === targetKeId && updatedRecord[currentStageStatusKey] === 'in_progress') {
                                            updatedRecord[currentStageStatusKey] = 'completed';
                                            updatedRecord[`${STAGE_CONFIG.KEY}_completed_time`] = new Date().toISOString();
                                            updatedRecord[`${STAGE_CONFIG.KEY}_completed_by`] = formData.worker;
                                            console.log(`‚úÖ [handoverShift] C·∫≠p nh·∫≠t k·ªá ƒë∆∞·ª£c ch·ªçn ${recordKeId} t·ª´ in_progress -> completed`);
                                        }
                                    } else {
                                        // N·∫øu kh√¥ng c√≥ k·ªá ƒë∆∞·ª£c ch·ªçn, kh√¥ng c·∫≠p nh·∫≠t g√¨ c·∫£
                                        console.log(`‚ö†Ô∏è [handoverShift] Kh√¥ng c√≥ k·ªá ƒë∆∞·ª£c ch·ªçn, b·ªè qua c·∫≠p nh·∫≠t tr·∫°ng th√°i cho ${record.xa_ke_id || record.ke_id || 'k·ªá'}`);
                                    }
                                    
                                    return updatedRecord;
                                });
                            }
                        });
                        
                        // C·∫≠p nh·∫≠t metadata
                        const metadataKeys = Object.keys(existingInputData).filter(key => key.endsWith('_metadata'));
                        metadataKeys.forEach(metadataKey => {
                            if (existingInputData[metadataKey]) {
                                existingInputData[metadataKey] = {
                                    ...existingInputData[metadataKey],
                                    updated_at: new Date().toISOString(),
                                    last_action: 'handover_shift',
                                    last_updated_by: formData.worker,
                                    last_updated_stage: STAGE_CONFIG.KEY
                                };
                            }
                        });
                        
                        console.log('üì¶ [handoverShift] D·ªØ li·ªáu JSON input sau khi c·∫≠p nh·∫≠t tr·∫°ng th√°i completed:', existingInputData);
                        
                        // 3. L∆∞u d·ªØ li·ªáu JSON ƒë√£ c·∫≠p nh·∫≠t
                        const saveInputResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                ke_data_json: existingInputData
                            })
                        });
                        
                        if (saveInputResponse.ok) {
                            console.log('‚úÖ [handoverShift] ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i completed trong input JSON th√†nh c√¥ng');
                        } else {
                            const saveError = await saveInputResponse.json();
                            console.warn('‚ö†Ô∏è [handoverShift] L·ªói c·∫≠p nh·∫≠t input JSON:', saveError);
                        }
                    } else {
                        console.log('‚ÑπÔ∏è [handoverShift] Kh√¥ng c√≥ d·ªØ li·ªáu input JSON ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i');
                    }
                } catch (inputJsonError) {
                    console.warn('‚ö†Ô∏è [handoverShift] L·ªói khi x·ª≠ l√Ω input JSON:', inputJsonError);
                }
                
                // L∆ØU D·ªÆ LI·ªÜU JSON K·ªÜ V√ÄO DATABASE
                try {
                    // Thu th·∫≠p d·ªØ li·ªáu t·ª´ b·∫£ng k·ªá
                    const keTableData = collectQuantityOKTableData();
                    
                    if (keTableData.length > 0) {
                        // L·∫•y d·ªØ li·ªáu k·ªá c≈© t·ª´ database
                        let existingKeData = null;
                        try {
                            const existingResp = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/handover_json/${STAGE_CONFIG.KEY}`);
                            if (existingResp.ok) {
                                const existingData = await existingResp.json();
                                let raw = existingData && existingData.data ? existingData.data : null;
                                if (raw && typeof raw === 'string') {
                                    try { raw = JSON.parse(raw); } catch (_) { }
                                }
                                if (raw) {
                                    existingKeData = raw;
                                }
                            }
                        } catch (e) {
                            console.log('‚ÑπÔ∏è Kh√¥ng c√≥ d·ªØ li·ªáu k·ªá c≈© ho·∫∑c l·ªói khi ƒë·ªçc:', e);
                        }
                        
                        // T·∫°o c·∫•u tr√∫c JSON k·ªá v·ªõi key ƒë∆∞·ª£c prefix b·ªüi {stage}
                        const stagePrefix = STAGE_CONFIG.KEY + '_';
                        const keRecordsKey = stagePrefix + 'ke_records';
                        const metadataKey = stagePrefix + 'metadata';
                        const nextStage = (order && (order.next_stage || getNextStageFromWorkflow(order.workflow_definition, STAGE_CONFIG.KEY))) || '';
                        const nextstagePrefix = nextStage ? (nextStage + '_') : 'next_';
                        
                        // G·ªôp d·ªØ li·ªáu k·ªá c≈© v√† m·ªõi
                        let allKeRecords = [];
                        
                        // Th√™m d·ªØ li·ªáu k·ªá c≈© n·∫øu c√≥
                        if (existingKeData && existingKeData[keRecordsKey]) {
                            allKeRecords = [...existingKeData[keRecordsKey]];
                        }
                        
                        // Th√™m d·ªØ li·ªáu k·ªá m·ªõi
                        const newKeRecords = keTableData.map(row => ({
                            [stagePrefix + 'ke_id']: `ke_${row.row_id}`,
                            [stagePrefix + 'ke_name']: row.ke,
                            [stagePrefix + 'status']: 'completed',
                            [stagePrefix + 'quantity']: row.ok_quantity,
                            [stagePrefix + 'shift']: shift,
                            [stagePrefix + 'operator']: workerName,
                            [stagePrefix + 'handover_time']: new Date().toISOString(),
                            [stagePrefix + 'notes']: `B√†n giao t·ª´ ca ${shift} - ${workerName}`,
                            [nextstagePrefix + 'status']: 'waiting'
                        }));
                        
                        allKeRecords = [...allKeRecords, ...newKeRecords];
                        
                        const keDataJSON = {
                            [keRecordsKey]: allKeRecords,
                            [metadataKey]: {
                                [stagePrefix + 'total_ke']: allKeRecords.length,
                                [stagePrefix + 'total_quantity']: allKeRecords.reduce((s, r) => s + (r[stagePrefix + 'quantity'] || 0), 0),
                                [stagePrefix + 'handover_quantity']: allKeRecords.reduce((s, r) => s + (r[stagePrefix + 'quantity'] || 0), 0),
                                [stagePrefix + 'last_updated']: new Date().toISOString()
                            }
                        };
                        
                        console.log('üì¶ [handoverShift] D·ªØ li·ªáu JSON k·ªá ƒë·ªÉ l∆∞u:', keDataJSON);
                        
                        // L∆∞u v√†o c·ªôt {stage}_handover_quantity_json c·ªßa production_orders
                        const saveKeResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/save_ke_json`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                stage: STAGE_CONFIG.KEY,
                                ke_data_json: keDataJSON,
                                production_order: order.production_order
                            })
                        });
                        
                        if (saveKeResponse.ok) {
                            const saveKeResult = await saveKeResponse.json();
                            console.log('‚úÖ [handoverShift] ƒê√£ l∆∞u JSON k·ªá th√†nh c√¥ng:', saveKeResult);
                            
                            // Kh√¥ng c·∫ßn g·ªçi endpoint c·∫≠p nh·∫≠t ri√™ng n·ªØa (ƒë√£ l∆∞u tr·ª±c ti·∫øp b·∫±ng save_ke_json)
                        } else {
                            const saveKeError = await saveKeResponse.json();
                            console.warn('‚ö†Ô∏è [handoverShift] L·ªói khi l∆∞u JSON k·ªá:', saveKeError);
                        }
                    } else {
                        console.log('‚ÑπÔ∏è [handoverShift] Kh√¥ng c√≥ d·ªØ li·ªáu k·ªá ƒë·ªÉ l∆∞u');
                    }
                } catch (keError) {
                    console.warn('‚ö†Ô∏è [handoverShift] L·ªói khi x·ª≠ l√Ω JSON k·ªá:', keError);
                }
                
                // Ki·ªÉm tra logic status: n·∫øu t·ªïng s·ªë l∆∞·ª£ng nh·∫≠p b·∫±ng s·ªë l∆∞·ª£ng c√≤n s·∫£n xu·∫•t c√≤n l·∫°i th√¨ status=handed_over
                try {
                    // Log th√¥ng tin order tr∆∞·ªõc khi x·ª≠ l√Ω
                    console.log('üîç [handoverShift] Th√¥ng tin order tr∆∞·ªõc khi x·ª≠ l√Ω:', {
                        orderId: order.id,
                        orderCode: order.production_order,
                        nextStage: order.next_stage,
                        currentStageStatus: order[`${STAGE_CONFIG.KEY}_status`],
                        allStageFields: Object.keys(order).filter(key => key.includes('_status'))
                    });
                    
                    const inputQuantity = getInputQuantityFromPreviousStage(order);
                    const remainingQuantity = await getRemainingQuantity(order);
              
                    
                    // N·∫øu s·ªë l∆∞·ª£ng c√≤n l·∫°i sau ca n√†y = 0, th√¨ status = 'handed_over'
                    const newStatus = remainingQuantity <= 0 ? 'handed_over' : 'waiting';
                    
                    // X√°c ƒë·ªãnh c√¥ng ƒëo·∫°n ti·∫øp theo
                    const nextStage = order.next_stage;
                    
                    const orderUpdateData = {
                        status: remainingQuantity <= 0 ? 'Ho√†n th√†nh' : 'ƒêang s·∫£n xu·∫•t',
                        [`${STAGE_CONFIG.KEY}_status`]: newStatus
                    };
                    
                    // Log th√¥ng tin tr∆∞·ªõc khi c·∫≠p nh·∫≠t
                    console.log('üîç [handoverShift] Th√¥ng tin tr∆∞·ªõc khi c·∫≠p nh·∫≠t:', {
                        orderId: order.id,
                        orderCode: order.production_order,
                        nextStage: nextStage,
                        handoverQuantity: handoverQuantity,
                        handoverQty: handoverQty,
                        newStatus: newStatus,
                        remainingQuantity: remainingQuantity,
                        currentStage: STAGE_CONFIG.KEY
                    });
                    
                    // N·∫øu c√≥ c√¥ng ƒëo·∫°n ti·∫øp theo v√† c√≥ s·ªë l∆∞·ª£ng b√†n giao, c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng ƒëo·∫°n ti·∫øp theo th√†nh 'waiting'
                    if (nextStage && handoverQuantity > 0) {
                        orderUpdateData[`${nextStage}_status`] = 'waiting';
                        console.log(`üîÑ [handoverShift] C·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng ƒëo·∫°n ti·∫øp theo ${nextStage} th√†nh 'waiting'`);
                    } else {
                        console.log(`‚ö†Ô∏è [handoverShift] Kh√¥ng c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng ƒëo·∫°n ti·∫øp theo:`, {
                            hasNextStage: !!nextStage,
                            hasHandoverQty: handoverQuantity > 0,
                            nextStage: nextStage,
                            handoverQuantity: handoverQuantity
                        });
                    }
                    
                    console.log('üì§ [handoverShift] D·ªØ li·ªáu g·ª≠i l√™n API:', orderUpdateData);
                    
                    const updateOrderResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(orderUpdateData)
                    });
                    
                    if (updateOrderResponse.ok) {
                        const updateResult = await updateOrderResponse.json();
                        console.log(`‚úÖ [handoverShift] Production order status updated successfully:`, {
                            mainStatus: orderUpdateData.status,
                            stageStatus: newStatus,
                            nextStage: nextStage ? nextStage + ' -> waiting' : 'N/A',
                            apiResponse: updateResult,
                            updatedFields: updateResult.updated_fields || []
                        });
                        
                        // Ki·ªÉm tra xem c√≥ c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng ƒëo·∫°n ti·∫øp theo kh√¥ng
                        if (nextStage && updateResult.updated_fields) {
                            const nextStageField = `${nextStage}_status`;
                            const hasNextStageUpdate = updateResult.updated_fields.includes(nextStageField);
                            console.log(`üîç [handoverShift] Ki·ªÉm tra c·∫≠p nh·∫≠t tr·∫°ng th√°i c√¥ng ƒëo·∫°n ti·∫øp theo:`, {
                                nextStageField: nextStageField,
                                hasNextStageUpdate: hasNextStageUpdate,
                                allUpdatedFields: updateResult.updated_fields
                            });
                        }
                    } else {
                        const updateError = await updateOrderResponse.json();
                        console.warn('‚ö†Ô∏è [handoverShift] Failed to update production order status after handover:', updateError);
                    }
                } catch (updateError) {
                    console.warn('‚ö†Ô∏è Error updating production order status after handover:', updateError);
                    // Kh√¥ng throw error v√¨ ƒë√¢y kh√¥ng ph·∫£i l·ªói nghi√™m tr·ªçng
                }
                
                showNotification('‚úÖ ƒê√£ b√†n giao ca l√†m vi·ªác th√†nh c√¥ng!', 'success');
            } else {
                console.error('‚ùå Update shift failed:', updateResult);
                throw new Error(`C·∫≠p nh·∫≠t ca: ${updateResult.error || 'Unknown error'}`);
            }
            
            // Reset form s·ªë l∆∞·ª£ng
            setElementValue('goodQty', '0');
            setElementValue('ngQty', '0');
            setElementValue('ngStartEndQty', '0');
            setElementValue('returnQty', '0');
            setElementValue('handoverQty', '0');
            
            // Enable n√∫t "B·∫Øt ƒë·∫ßu", disable n√∫t "B√†n giao ca"
            const startBtn = document.querySelector('button[onclick="startProduction()"]');
            const handoverBtn = document.querySelector('button[onclick="handoverShift()"]');
            if (startBtn) startBtn.disabled = false;
            if (handoverBtn) handoverBtn.disabled = true;
            
            // D·ª´ng timer
            stopProductionTimer();
            
            // C·∫≠p nh·∫≠t d·ªØ li·ªáu local
            await refreshData();
            
            // Refresh sidebar content
            showOrderDetails(order.id);
            
            // Chuy·ªÉn sang tab "Th√¥ng tin ca" ƒë·ªÉ xem k·∫øt qu·∫£
            setTimeout(() => {
                const shiftsTab = document.querySelector('.details-panel .tab-btn[onclick*="shifts"]');
                if (shiftsTab) {
                    shiftsTab.click();
                }
            }, 500);
            
                        } catch (error) {
                    console.error('üí• Error in handoverShift:', error);
                    console.error('üí• Error stack:', error.stack);
                    console.error('üí• Error message:', error.message);
                    showNotification('L·ªói khi b√†n giao ca l√†m vi·ªác: ' + error.message, 'error');
                } finally {
            hideLoading();
        }
    }

    /**
     * Reset form fields in the sidebar
     */
    function resetForm() {
        // Reset all input fields
        document.querySelectorAll('#detailsPanel input, #detailsPanel select, #detailsPanel textarea').forEach(field => {
            if (field.type === 'checkbox') {
                field.checked = false;
            } else {
                field.value = '';
            }
        });
        
        // Reset quantity inputs to 0
        document.querySelectorAll('.quantity-input').forEach(input => {
            input.value = '0';
        });
        
        showNotification('ƒê√£ reset form th√†nh c√¥ng!', 'success');
    }


    
    // H√†m t√≠nh th·ªùi gian ƒëang ch·∫°y (t·ª´ th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu ƒë·∫øn hi·ªán t·∫°i)
    function calculateRunningTime(startTime, endTime) {

        
        try {
            // Parse th·ªùi gian b·∫Øt ƒë·∫ßu
            const start = new Date(startTime);
            // S·ª≠ d·ª•ng th·ªùi gian hi·ªán t·∫°i v√† chuy·ªÉn v·ªÅ m√∫i gi·ªù local
            const end = endTime ? new Date(endTime) : new Date();
            
            // Th√™m 7 gi·ªù v√†o end time ƒë·ªÉ chuy·ªÉn v·ªÅ m√∫i gi·ªù Vi·ªát Nam
            const endLocal = new Date(end.getTime() + (7 * 60 * 60 * 1000));
          
            
            // Ki·ªÉm tra n·∫øu date kh√¥ng h·ª£p l·ªá
            if (isNaN(start.getTime()) || isNaN(endLocal.getTime())) {
                console.error('‚ùå Invalid date in calculateRunningTime:', { startTime, endTime });
                return 'Invalid date';
            }
            
            const diffMs = endLocal.getTime() - start.getTime();
            
            const hours = Math.floor(diffMs / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
            
            const result = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            return result;
        } catch (error) {
            return 'Error';
        }
    }
    
    // H√†m c·∫≠p nh·∫≠t th·ªùi gian ch·∫°y trong giao di·ªán
    function updateRunningTimer() {
        // T√¨m element timer trong sidebar m·ªõi
        const statusTimeElement = document.getElementById('statusTime');
        const runningTimeInfoElement = document.getElementById('runningTimeInfo');
        const endTimeInfoElement = document.getElementById('endTimeInfo');
        // Fallback cho element c≈© n·∫øu c√≤n t·ªìn t·∫°i
        const timerElement = document.getElementById('productionRunningTime');
        
        if (window.currentShiftStartTime) {
            // T√≠nh th·ªùi gian ch·∫°y t·ª´ th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu ƒë·∫øn hi·ªán t·∫°i (ho·∫∑c th·ªùi ƒëi·ªÉm k·∫øt th√∫c n·∫øu c√≥)
            const endTime = getOrderField(currentEditingOrder, 'end_time');
            const time = calculateRunningTime(window.currentShiftStartTime, endTime);
            
  
            
            // C·∫≠p nh·∫≠t timer trong sidebar m·ªõi (production status)
            if (statusTimeElement) {
                statusTimeElement.textContent = `Th·ªùi gian: ${time}`;
            }
            
            // C·∫≠p nh·∫≠t th·ªùi gian ch·∫°y trong tab th√¥ng tin
            if (runningTimeInfoElement) {
                // Lu√¥n c·∫≠p nh·∫≠t, kh√¥ng quan t√¢m c√≥ end_time hay kh√¥ng
                runningTimeInfoElement.textContent = time;
            }
            
            // C·∫≠p nh·∫≠t th·ªùi gian k·∫øt th√∫c n·∫øu ƒë√£ k·∫øt th√∫c
            if (endTimeInfoElement && getOrderField(currentEditingOrder, 'end_time')) {
                endTimeInfoElement.textContent = formatDateTime(getOrderField(currentEditingOrder, 'end_time'));
            }
            
            // C·∫≠p nh·∫≠t timer c≈© n·∫øu c√≤n t·ªìn t·∫°i (fallback)
            if (timerElement) {
                timerElement.textContent = time;
            }
        } else {
            console.warn('‚ö†Ô∏è Kh√¥ng c√≥ th·ªùi gian b·∫Øt ƒë·∫ßu (window.currentShiftStartTime)');
            
            // N·∫øu ch∆∞a b·∫Øt ƒë·∫ßu ho·∫∑c kh√¥ng c√≥ th·ªùi gian
            if (statusTimeElement) {
                statusTimeElement.textContent = 'Th·ªùi gian: 00:00:00';
            }
            if (runningTimeInfoElement) {
                runningTimeInfoElement.textContent = '--';
            }
            if (endTimeInfoElement) {
                endTimeInfoElement.textContent = '--';
            }
        }
    }
    
    // H√†m b·∫Øt ƒë·∫ßu timer
    function startProductionTimer() {
        // X√≥a timer c≈© n·∫øu c√≥
        stopProductionTimer();
        
        // Log order information for debugging
        if (currentEditingOrder) {
            
        }
        
        // B·∫Øt ƒë·∫ßu timer m·ªõi, c·∫≠p nh·∫≠t m·ªói gi√¢y
        updateRunningTimer();
        productionTimerId = setInterval(updateRunningTimer, 1000);

    }
    
    // H√†m d·ª´ng timer
    function stopProductionTimer() {
        if (productionTimerId) {
            clearInterval(productionTimerId);
            productionTimerId = null;
        }
    }

    // Export functions for global access
    window.refreshData = refreshData;
    window.showReportTab = showReportTab;

    

    window.updateHandoverQuantity = updateHandoverQuantity;
    
    // Filter functions
    window.applyFilters = applyFilters;
    window.clearFilters = clearFilters;
    
    // Wizard functions
    window.wizardNextStep = wizardNextStep;
    window.wizardPreviousStep = wizardPreviousStep;

    window.updateWizardHandoverQuantity = updateWizardHandoverQuantity;
    
    // Details panel functions
    window.showOrderDetails = showOrderDetails;
    window.closeDetailsPanel = closeDetailsPanel;

    // Rack selection and validation functions
    window.getTotalQuantityInSelectedRacks = getTotalQuantityInSelectedRacks;
    window.updateSelectedRackQuantityDisplay = updateSelectedRackQuantityDisplay;
    window.updateHandoverButtonValidation = updateHandoverButtonValidation;
    window.autoSelectInProgressRacks = autoSelectInProgressRacks;
    
    // Sync wrapper functions
    window.updateSelectedRackQuantityDisplaySync = updateSelectedRackQuantityDisplaySync;
    window.updateHandoverButtonValidationSync = updateHandoverButtonValidationSync;

    // Wrapper functions for async calls from event listeners
    function updateSelectedRackQuantityDisplaySync() {
        updateSelectedRackQuantityDisplay().catch(error => {
            console.error('‚ùå Error in updateSelectedRackQuantityDisplay:', error);
        });
    }

    function updateHandoverButtonValidationSync() {
        updateHandoverButtonValidation().catch(error => {
            console.error('‚ùå Error in updateHandoverButtonValidation:', error);
        });
    }

    window.startProduction = startProduction;
    // window.endProduction = endProduction;

    // Tab switching functions
    window.switchTab = switchTab;
    window.resetForm = resetForm;
    // window.pauseProduction = pauseProduction;
    
    // Quantity OK table functions
    window.addQuantityOKRow = addQuantityOKRow;
    window.removeQuantityOKRow = removeQuantityOKRow;

    




    /**
     * =================================================================
     * REPORT FUNCTIONS - H√ÄM X·ª¨ L√ù B√ÅO C√ÅO
     * =================================================================
     */

    /**
     * Hi·ªÉn th·ªã tab b√°o c√°o
     */
    function showReportTab() {
        
        // Chuy·ªÉn sang tab b√°o c√°o
        const reportTab = document.getElementById('report-tab');
        
        if (reportTab) {
            reportTab.click();
        } else {
            console.error('Report tab not found!');
        }
        
        // Load d·ªØ li·ªáu b√°o c√°o
        loadReportData();
    }

    /**
     * Load d·ªØ li·ªáu b√°o c√°o - c√°c l·ªánh ƒë√£ b√†n giao
     */
    async function loadReportData() {
      
        
        try {
            showLoading('ƒêang t·∫£i d·ªØ li·ªáu b√°o c√°o...');
            
                    // L·ªçc c√°c l·ªánh ƒë√£ ho√†n th√†nh (s·ªë l∆∞·ª£ng c·∫ßn s·∫£n xu·∫•t = 0) v√† ƒë√£ ƒë∆∞·ª£c b√†n giao t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
        const handedOverOrders = ordersData.filter(order => {
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // T√≠nh t·ªïng s·ªë l∆∞·ª£ng b√†n giao v√† input
            const previousStageHandover = order.previous_stage_handover_quantity || 0;
            const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
            const currentStageInput = getOrderField(order, 'input_quantity') || 0;
            
  
            return inputQuantity <= 0 && previousStageHandover > 0;
        });  
        
            
            // Render b·∫£ng b√°o c√°o
            renderReportTable(handedOverOrders);
            
            // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng
            updateReportCount(handedOverOrders.length);
            
        } catch (error) {
            console.error('Error in loadReportData:', error);
            showNotification('L·ªói khi t·∫£i d·ªØ li·ªáu b√°o c√°o: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    /**
     * Render b·∫£ng b√°o c√°o
     */
    function renderReportTable(orders) {
        const tableBody = document.getElementById('reportTableBody');
        if (!tableBody) {
            console.error('reportTableBody not found!');
            return;
        }
        
        // X√≥a d·ªØ li·ªáu c≈©
        tableBody.innerHTML = '';
        
        // Ki·ªÉm tra c√≥ d·ªØ li·ªáu kh√¥ng
        if (orders.length === 0) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="13" class="text-center text-muted py-4">
                        <i class="bi bi-file-earmark-text fs-1 mb-2 d-block"></i>
                        Ch∆∞a c√≥ l·ªánh n√†o ƒë∆∞·ª£c b√†n giao
                    </td>
                </tr>
            `;
            return;
        }

        // S·∫Øp x·∫øp theo th·ªùi gian b√†n giao (m·ªõi nh·∫•t l√™n ƒë·∫ßu)
        const sortedOrders = [...orders].sort((a, b) => {
            const aTime = getOrderField(a, 'handover_date') ? new Date(getOrderField(a, 'handover_date')).getTime() : 0;
            const bTime = getOrderField(b, 'handover_date') ? new Date(getOrderField(b, 'handover_date')).getTime() : 0;
            return bTime - aTime;
        });

        // Render t·ª´ng d√≤ng
        sortedOrders.forEach((order, index) => {
            const row = createReportTableRow(order, index);
            tableBody.appendChild(row);
        });
    }

    /**
     * T·∫°o d√≤ng b√°o c√°o
     */
    function createReportTableRow(order, index) {
        const row = document.createElement('tr');
        row.className = 'order-row';
        row.setAttribute('data-order-id', order.id);
        
        // T√≠nh to√°n ti·∫øn ƒë·ªô
        const inputQty = getOrderField(order, 'input_quantity') || 0;
        const sheet_count = order.sheet_count || 0;
        const goodQty = getOrderField(order, 'good_quantity') || 0;
        const ngQty = getOrderField(order, 'ng_quantity') || 0;
        const deployedQty = order.deployed_quantity || 0;
        const progressPercent = inputQty > 0 ? Math.round((goodQty / inputQty) * 100) : 0;
        
        // L·∫•y th√¥ng tin b√†n giao
        const handoverDate = getOrderField(order, 'handover_date') ? formatDateTime(getOrderField(order, 'handover_date')) : 'N/A';
        const handoverQuantity = getOrderField(order, 'handover_quantity') || 0;
        
        // X√°c ƒë·ªãnh icon v√† m√†u s·∫Øc cho tr·∫°ng th√°i ƒë√£ b√†n giao
        const statusIcon = 'bi-arrow-right-circle';
        const statusClass = 'text-info';
        const statusText = 'ƒê√£ b√†n giao';
        
        row.innerHTML = `
            <td class="text-center">
                <span class="badge bg-light text-dark">${index + 1}</span>
            </td>
            <td>
                <div class="d-flex align-items-center">
                    <i class="bi ${statusIcon} ${statusClass} me-2"></i>
                    <div>
                        <div class="fw-bold">${order.production_order}</div>
                        <small class="text-muted">${formatDate(order.deployment_date)} - ${getOrderField(order, 'shift')}</small>
                        <small class="text-info d-block">${statusText}</small>
                    </div>
                </div>
            </td>
            <td class="text-center">
                <span class="fw-bold">${order.order_type || ''}</span>
            </td>
            <td>
                <div>
                    <div class="fw-bold">${order.internal_product_code}</div>
                    <small class="text-muted" title="${order.product_name}">${truncateText(order.product_name, 100)}</small>
                </div>
            </td>
            <td class="text-center">
                <span class="badge bg-secondary">${order.paper_type || 'N/A'}</span>
            </td>
            <td class="text-center">
                <span class="fw-bold">${order.paper_weight || 0} gsm</span>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(deployedQty)}</div>
                <small class="text-muted">pcs</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-primary">${formatNumber(sheet_count)}</div>
                <small class="text-muted">t·ªù gi·∫•y</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-success">${formatNumber(order.paper_length || 0)}</div>
                <small class="text-muted">KT</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-danger">${formatNumber(order.paper_width || 0)}</div>
                <small class="text-muted">chi·ªÅu r·ªông</small>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(order.blank_count || 0)}</div>
                <small class="text-muted">ph√¥i</small>
            </td>
            <td class="text-center">
                <div class="progress" style="height: 20px;">
                    <div class="progress-bar bg-success" style="width: ${Math.min(progressPercent, 100)}%">
                        ${progressPercent}%
                    </div>
                </div>
                <small class="text-muted">${statusText}</small>
            </td>
            <td class="text-center">
                <small class="text-muted d-block" title="${order.assigned_machine || 'N/A'}">${truncateText(order.assigned_machine || 'N/A', 15)}</small>
            </td>
        `;
        
        // Th√™m click event ƒë·ªÉ xem chi ti·∫øt
        row.style.cursor = 'pointer';
        row.addEventListener('click', () => {
            showOrderDetails(order.id);
        });
        
        return row;
    }

    /**
     * C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng b√°o c√°o
     */
    function updateReportCount(count) {
        const reportCountElement = document.getElementById('report-count');
        if (reportCountElement) {
            reportCountElement.textContent = count;
        } else {
            console.error('report-count element not found!');
        }
    }

    /**
     * =================================================================
     * FILTER FUNCTIONS - H√ÄM L·ªåC D·ªÆ LI·ªÜU
     * =================================================================
     */

    // Bi·∫øn l∆∞u tr·ªØ d·ªØ li·ªáu g·ªëc v√† d·ªØ li·ªáu ƒë√£ l·ªçc
    let originalOrdersData = [];
    let filteredOrdersData = [];

    /**
     * √Åp d·ª•ng c√°c b·ªô l·ªçc
     */
    function applyFilters() {
        const fromDateFilter = document.getElementById('fromDateFilter')?.value || '';
        const toDateFilter = document.getElementById('toDateFilter')?.value || '';
        const searchInput = document.getElementById('searchInput')?.value?.toLowerCase() || '';

        // L·ªçc d·ªØ li·ªáu
        let filteredCount = 0;
        filteredOrdersData = originalOrdersData.filter(order => {
            // L·ªçc theo kho·∫£ng ng√†y s·∫£n xu·∫•t
            if (fromDateFilter && toDateFilter) {
                const orderDate = order.deployment_date || order.created_at;
                if (!orderDate || orderDate < fromDateFilter || orderDate > toDateFilter) {
                    return false;
                }
            } else if (fromDateFilter) {
                const orderDate = order.deployment_date || order.created_at;
                if (!orderDate || orderDate < fromDateFilter) {
                    return false;
                }
            } else if (toDateFilter) {
                const orderDate = order.deployment_date || order.created_at;
                if (!orderDate || orderDate > toDateFilter) {
                    return false;
                }
            }



            // L·ªçc theo t√¨m ki·∫øm
            if (searchInput) {
                const searchFields = [
                    order.order_type,
                    order.production_order,
                    order.internal_product_code,
                    order.paper_type,
                    order.assigned_machine,
                    getOrderField(order, 'worker_name')
                ].map(field => (field || '').toLowerCase());

                const hasMatch = searchFields.some(field => field.includes(searchInput));
                if (!hasMatch) {
                    return false;
                }
            }

            // ‚úÖ KI·ªÇM TRA STAGE TR∆Ø·ªöC ƒê√É HO√ÄN TH√ÄNH HAY CH∆ØA (T·∫†M TH·ªúI DISABLE)
            /*
            if (!isPreviousStageReady(order)) {
                console.log(`Order ${order.id} filtered out by previous stage not ready:`, {
                    previous_stage: order.previous_stage,
                    previous_stage_status: order.previous_stage_status,
                    current_status: getOrderField(order, 'status')
                });
                return false; // ·∫®n l·ªánh n√†y v√¨ stage tr∆∞·ªõc ch∆∞a xong
            }
            */

            filteredCount++;
            return true;
        });



        // C·∫≠p nh·∫≠t d·ªØ li·ªáu hi·ªÉn th·ªã
        ordersData = filteredOrdersData;
        
        // Render l·∫°i b·∫£ng
        renderOrdersTable();
        updateStatistics();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o
        if (filteredOrdersData.length === 0) {
            showNotification('Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ph√π h·ª£p v·ªõi b·ªô l·ªçc', 'warning');
        } else {
            showNotification(`ƒê√£ l·ªçc: ${filteredOrdersData.length} l·ªánh s·∫£n xu·∫•t`, 'info');
        }
    }

    /**
     * X√≥a t·∫•t c·∫£ b·ªô l·ªçc
     */
    function clearFilters() {
        const fromDateFilter = document.getElementById('fromDateFilter');
        const toDateFilter = document.getElementById('toDateFilter');
        const searchInput = document.getElementById('searchInput');
        
        if (fromDateFilter) fromDateFilter.value = '';
        if (toDateFilter) toDateFilter.value = '';
        if (searchInput) searchInput.value = '';

        // X√≥a cache filter ng√†y khi clear
        localStorage.removeItem(DATE_FILTER_CACHE_KEY);

        // Kh√¥i ph·ª•c d·ªØ li·ªáu g·ªëc
        ordersData = [...originalOrdersData];
        
        // Chuy·ªÉn v·ªÅ tab "T·∫•t c·∫£" khi x√≥a filter
        const allTab = document.getElementById('all-tab');
        if (allTab) {
            allTab.click();
        }
        
        // Render l·∫°i b·∫£ng
        renderOrdersTable();
        updateStatistics();
        
        showNotification('ƒê√£ x√≥a t·∫•t c·∫£ b·ªô l·ªçc', 'info');
    }

    /**
     * T·ª± ƒë·ªông l·ªçc khi nh·∫≠p t√¨m ki·∫øm (debounce)
     */
    let searchTimeout;
    function setupSearchDebounce() {
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    applyFilters();
                }, 300); // Delay 300ms
            });
        }
    }

    /**
     * T·ª± ƒë·ªông l·ªçc khi thay ƒë·ªïi b·ªô l·ªçc
     */
    function setupFilterChangeListeners() {
        // Ch·ªâ setup listener cho c√°c element th·ª±c s·ª± t·ªìn t·∫°i
        const fromDateFilter = document.getElementById('fromDateFilter');
        const toDateFilter = document.getElementById('toDateFilter');

        if (fromDateFilter) {
            fromDateFilter.addEventListener('change', applyFilters);
        }
        if (toDateFilter) {
            toDateFilter.addEventListener('change', applyFilters);
        }
    }

    /**
     * C·∫≠p nh·∫≠t danh s√°ch m√°y t·ª´ d·ªØ li·ªáu th·ª±c t·∫ø
     */
    function updateMachineFilterOptions() {
        const machineFilter = document.getElementById('machineFilter');
        if (!machineFilter) {
            return;
        }

        // L·ªçc c√°c m√°y thu·ªôc Stage_${STAGE_CONFIG.KEY} t·ª´ d·ªØ li·ªáu m√°y
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        ).map(machine => machine.machine_name);

        // X√≥a options c≈© (gi·ªØ l·∫°i option "T·∫•t c·∫£")
        machineFilter.innerHTML = '<option value="">T·∫•t c·∫£</option>';

        // Th√™m options m·ªõi
        MStageMachines.sort().forEach(machine => {
            const option = document.createElement('option');
            option.value = machine;
            option.textContent = machine;
            machineFilter.appendChild(option);
        });
    }


    /**
     * T√≠nh s·ªë l∆∞·ª£ng c·∫ßn s·∫£n xu·∫•t c√≤n l·∫°i
     * = S·ªë l∆∞·ª£ng t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc - (T·ªïng s·ªë l∆∞·ª£ng b√†n giao + NG c·ªßa c√°c ca ƒë√£ l√†m)
     */
    async function getRemainingQuantity(order) {
        try {
            // L·∫•y s·ªë l∆∞·ª£ng t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // L·∫•y t·ªïng s·ªë l∆∞·ª£ng b√†n giao c·ªßa c√°c ca ƒë√£ l√†m
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            let totalHandoverQuantity = 0;
            let totalNgQuantity = 0;
            if (shiftsData.shifts && Array.isArray(shiftsData.shifts)) {
                shiftsData.shifts.forEach(shift => {
                    totalHandoverQuantity += (parseInt(shift.handover_quantity) || 0);
                    totalNgQuantity += (parseInt(shift.ng_quantity) || 0);
                });
            }
            
            const remainingQuantity = Math.max(0, inputQuantity - totalHandoverQuantity - totalNgQuantity);
            
            return remainingQuantity;
        } catch (error) {
            console.error('‚ùå L·ªói t√≠nh s·ªë l∆∞·ª£ng c√≤n l·∫°i:', error);
            return getInputQuantityFromPreviousStage(order); // Fallback
        }
    }

    /**
     * Load v√† hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
     */
    async function loadRemainingQuantity() {
        if (!currentEditingOrder) return;
        
        try {
            const remainingQuantity = await getRemainingQuantity(currentEditingOrder);
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
            const remainingQuantityDisplay = document.getElementById('remainingQuantityDisplay');
            if (remainingQuantityDisplay) {
                remainingQuantityDisplay.textContent = `${remainingQuantity} t·ªù gi·∫•y`;
            }
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
            const totalQuantityDisplay = document.getElementById('totalQuantityDisplay');
            if (totalQuantityDisplay) {
                const currentTotal = parseInt(getElementValue('goodQty') || 0) + 
                                   parseInt(getElementValue('ngQty') || 0) + 
                                   parseInt(getElementValue('ngStartEndQty') || 0) + 
                                   parseInt(getElementValue('returnQty') || 0);
                
                // L·∫•y t·ªïng s·ªë l∆∞·ª£ng trong k·ªá ƒë√£ ch·ªçn
                const selectedRackTotalQuantity = await getTotalQuantityInSelectedRacks();
                totalQuantityDisplay.textContent = `${currentTotal} / ${selectedRackTotalQuantity}`;
                
                // Thay ƒë·ªïi m√†u s·∫Øc d·ª±a tr√™n validation
                if (currentTotal > selectedRackTotalQuantity) {
                    totalQuantityDisplay.style.color = '#dc3545'; // ƒê·ªè - v∆∞·ª£t qu√°
                    totalQuantityDisplay.style.fontWeight = 'bold';
                } else if (currentTotal === selectedRackTotalQuantity) {
                    totalQuantityDisplay.style.color = '#28a745'; // Xanh l√° - kh·ªõp ch√≠nh x√°c
                    totalQuantityDisplay.style.fontWeight = 'bold';
                } else {
                    totalQuantityDisplay.style.color = '#6c757d'; // X√°m - ch∆∞a ƒë·ªß
                    totalQuantityDisplay.style.fontWeight = 'normal';
                }
            }
            
        } catch (error) {
            console.error('‚ùå L·ªói load s·ªë l∆∞·ª£ng c√≤n l·∫°i:', error);
        }
    }

    /**
     * C·∫≠p nh·∫≠t hi·ªÉn th·ªã th·ªëng k√™ real-time
     */
    function updateStatisticsDisplay() {
        const goodQty = parseInt(getElementValue('goodQty')) || 0;
        const ngQty = parseInt(getElementValue('ngQty')) || 0;
        const ngStartEndQty = parseInt(getElementValue('ngStartEndQty')) || 0;
        const returnQty = parseInt(getElementValue('returnQty')) || 0;
        
        const totalProduced = goodQty + ngQty + ngStartEndQty + returnQty;
        const inputQuantity = getInputQuantityFromPreviousStage(currentEditingOrder);
        const efficiency = inputQuantity > 0 ? Math.round((totalProduced / inputQuantity) * 100) : 0;
        const ngRate = totalProduced > 0 ? Math.round(((ngQty + ngStartEndQty) / totalProduced) * 100) : 0;
        
        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã th·ªëng k√™
        const totalProducedElement = document.getElementById('totalProducedValue');
        const efficiencyElement = document.getElementById('efficiencyValue');
        const ngRateElement = document.getElementById('ngRateValue');
        
        if (totalProducedElement) {
            totalProducedElement.textContent = `${totalProduced} s·∫£n ph·∫©m`;
        }
        if (efficiencyElement) {
            efficiencyElement.textContent = `${efficiency}%`;
        }
        if (ngRateElement) {
            ngRateElement.textContent = `${ngRate}%`;
        }
        
        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
        handleUpdateTotalQuantityDisplay();
    }

    /**
     * Load v√† hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
     */
    async function loadRemainingQuantity() {
        if (!currentEditingOrder) return;
        
        try {
            const remainingQuantity = await getRemainingQuantity(currentEditingOrder);
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
            const remainingQuantityDisplay = document.getElementById('remainingQuantityDisplay');
            if (remainingQuantityDisplay) {
                remainingQuantityDisplay.textContent = `${remainingQuantity} t·ªù gi·∫•y`;
            }
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
            const totalQuantityDisplay = document.getElementById('totalQuantityDisplay');
            if (totalQuantityDisplay) {
                const currentTotal = parseInt(getElementValue('goodQty') || 0) + 
                                   parseInt(getElementValue('ngQty') || 0) + 
                                   parseInt(getElementValue('ngStartEndQty') || 0) + 
                                   parseInt(getElementValue('returnQty') || 0);
                totalQuantityDisplay.textContent = `${currentTotal} / ${remainingQuantity}`;
            }
            
        } catch (error) {
            console.error('‚ùå L·ªói load s·ªë l∆∞·ª£ng c√≤n l·∫°i:', error);
        }
    }

    /**
     * Ki·ªÉm tra shift hi·ªán t·∫°i v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
     */
    async function checkCurrentShiftStatus() {
        if (!currentEditingOrder) return;
        
        try {
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            // T√¨m shift ƒëang ch·∫°y (status = 'in_progress')
            const currentShift = shiftsData.shifts?.find(shift => shift.status === 'in_progress');
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
            const startBtn = document.getElementById('startBtn');
            const handoverBtn = document.getElementById('handoverShiftBtn');
            const stopAndHandoverBtn = document.getElementById('stopAndHandoverBtn');
            const handoverBtn2 = document.getElementById('handoverBtn');
            const resetBtn = document.getElementById('resetBtn');
            
            if (currentShift) {
                // C√≥ shift ƒëang ch·∫°y
        
                
                // C·∫≠p nh·∫≠t UI d·ª±a tr√™n tr·∫°ng th√°i ca k√≠p
                if (startBtn) {
                    startBtn.style.display = 'none';
                    startBtn.disabled = true;
                }
                
                if (handoverBtn) {
                    handoverBtn.style.display = 'flex';
                    handoverBtn.disabled = false;
                }
                
                if (stopAndHandoverBtn) {
                    stopAndHandoverBtn.style.display = 'flex';
                    stopAndHandoverBtn.disabled = false;
                }
                
                if (resetBtn) {
                    resetBtn.style.display = 'flex';
                    resetBtn.disabled = false;
                }
                
                // L∆∞u ID v√† th·ªùi gian b·∫Øt ƒë·∫ßu c·ªßa shift hi·ªán t·∫°i
                window.currentShiftId = currentShift.id;
                window.currentShiftStartTime = currentShift.start_time;
                
                // C·∫≠p nh·∫≠t hi·ªÉn th·ªã th·ªùi gian b·∫Øt ƒë·∫ßu trong sidebar
                const startTimeInfo = document.getElementById('startTimeInfo');
                if (startTimeInfo) {
                    // Hi·ªÉn th·ªã th·ªùi gian ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng
                    startTimeInfo.textContent = formatDateTime(currentShift.start_time);
    
                }
                
                // B·∫Øt ƒë·∫ßu timer n·∫øu ch∆∞a c√≥
                if (!productionTimerId) {
                    startProductionTimer();
                }
                

            } else {
                // Kh√¥ng c√≥ shift ƒëang ch·∫°y

                
                // Ki·ªÉm tra tr·∫°ng th√°i l·ªánh ƒë·ªÉ quy·∫øt ƒë·ªãnh hi·ªÉn th·ªã n√∫t b·∫Øt ƒë·∫ßu
                const orderStatus = getOrderField(currentEditingOrder, 'status');
                
                if (startBtn) {
                    if (orderStatus === 'completed' || orderStatus === 'handed_over') {
                        // N·∫øu l·ªánh ƒë√£ ho√†n th√†nh ho·∫∑c ƒë√£ b√†n giao, ·∫©n n√∫t b·∫Øt ƒë·∫ßu
                        startBtn.style.display = 'none';
                        startBtn.disabled = true;
        
                    } else {
                        // N·∫øu l·ªánh ch∆∞a ho√†n th√†nh, hi·ªÉn th·ªã n√∫t b·∫Øt ƒë·∫ßu
                        startBtn.style.display = 'flex';
                        startBtn.disabled = false;
        
                    }
                }
                
                if (handoverBtn) {
                    handoverBtn.style.display = 'none';
                    handoverBtn.disabled = true;
                }
                
                if (stopAndHandoverBtn) {
                    stopAndHandoverBtn.style.display = 'none';
                    stopAndHandoverBtn.disabled = true;
                }
                
                if (resetBtn) {
                    resetBtn.style.display = 'none';
                    resetBtn.disabled = true;
                }
                
                // D·ª´ng timer
                stopProductionTimer();
                
    
            }
            
        } catch (error) {
            console.error('‚ùå L·ªói ki·ªÉm tra tr·∫°ng th√°i shift:', error);
        }
    }

    /**
     * Load v√† hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
     */
    async function loadRemainingQuantity() {
        if (!currentEditingOrder) return;
        
        try {
            const remainingQuantity = await getRemainingQuantity(currentEditingOrder);
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã s·ªë l∆∞·ª£ng c√≤n l·∫°i
            const remainingQuantityDisplay = document.getElementById('remainingQuantityDisplay');
            if (remainingQuantityDisplay) {
                remainingQuantityDisplay.textContent = `${remainingQuantity} t·ªù gi·∫•y`;
            }
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠p
            const totalQuantityDisplay = document.getElementById('totalQuantityDisplay');
            if (totalQuantityDisplay) {
                const currentTotal = parseInt(getElementValue('goodQty') || 0) + 
                                   parseInt(getElementValue('ngQty') || 0) + 
                                   parseInt(getElementValue('ngStartEndQty') || 0) + 
                                   parseInt(getElementValue('returnQty') || 0);
                totalQuantityDisplay.textContent = `${currentTotal} / ${remainingQuantity}`;
            }
            
        } catch (error) {
            console.error('‚ùå L·ªói load s·ªë l∆∞·ª£ng c√≤n l·∫°i:', error);
        }
    }
  </script>
  
  <!-- User Info Update Script -->
  <script>
    // Update user info when page loads
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(checkAuthAndUpdateUser, 100);
    });
    

    
    function checkAuthAndUpdateUser() {
      if (typeof auth === 'undefined') {
        setTimeout(checkAuthAndUpdateUser, 100);
        return;
      }
      
      if (!auth.isLoggedIn()) {
        showLoginPopup({
          onLoginSuccess: function(userData) {
            updateUserInfo();
            refreshData();
          },
          onLoginError: function(error) {
            console.error('Login failed:', error);
          }
        });
        return;
      }
      
      updateUserInfo();
    }
    
    function updateUserInfo() {
      const userNameElement = document.getElementById('userName');
      
      if (!userNameElement) {
        setTimeout(updateUserInfo, 100);
        return;
      }
      
      if (typeof auth === 'undefined') {
        setTimeout(updateUserInfo, 100);
        return;
      }
      
      const user = auth.getUser();
      
      if (user) {
        userNameElement.textContent = user.full_name;
      } else {
        userNameElement.textContent = 'Ch∆∞a ƒëƒÉng nh·∫≠p';
      }
    }
    

    
    // Multi-Select Worker Functions
    function initializeWorkerMultiSelect(order) {
        const selectedWorkers = document.getElementById('selectedWorkers');
        const workerSearch = document.getElementById('workerSearch');
        const workerDropdown = document.getElementById('workerDropdown');
        const workerOptions = document.getElementById('workerOptions');
        
        // L·∫•y danh s√°ch user t·ª´ API
        let availableWorkers = [];
        
        async function loadWorkersFromAPI() {
            try {
                const response = await fetch(`${API_BASE_URL}/data/user`);
                
                if (response.ok) {
                    const users = await response.json();
           
                    
                    // Ki·ªÉm tra format c·ªßa response
                    if (Array.isArray(users)) {
                        availableWorkers = users.map(user => {
                            // Format: "M√£ nh√¢n vi√™n - T√™n nh√¢n vi√™n"
                            const name = `${user.ma_nhan_vien} - ${user.ten_nhan_vien}`;
                            return name;
                        }).filter(name => name && name.trim());
                    } else if (users.data && Array.isArray(users.data)) {
                        availableWorkers = users.data.map(user => `${user.ma_nhan_vien} - ${user.ten_nhan_vien}`).filter(name => name);
                    } else {
                        console.error('Unexpected API response format:', users);
                        availableWorkers = [];
                    }
                    
                    // Sau khi load workers, ƒë·ªÅ xu·∫•t user ƒëƒÉng nh·∫≠p hi·ªán t·∫°i
                    suggestCurrentUser();
                    
                    // N·∫øu dropdown ƒëang m·ªü, c·∫≠p nh·∫≠t l·∫°i options
                    if (workerDropdown.style.display === 'block') {
                        renderDropdownOptions(workerSearch.value);
                    }
                } else {
                    console.error('Failed to load workers from API, status:', response.status);
                    availableWorkers = [];
                }
            } catch (error) {
                console.error('Error loading workers:', error);
                availableWorkers = [];
            }
        }
        
        // ƒê·ªÅ xu·∫•t user ƒëƒÉng nh·∫≠p hi·ªán t·∫°i
        function suggestCurrentUser() {
            
            if (typeof auth !== 'undefined') {
                const currentUser = auth.getUser();
                // console.log('üë§ Current user:', currentUser);
                
                if (currentUser && currentUser.full_name) {

                    
                    // T√¨m user trong danh s√°ch available workers
                    const userWorkerName = availableWorkers.find(worker => 
                        worker.includes(currentUser.full_name) || 
                        worker.includes(currentUser.ma_nhan_vien)
                    );
                    
                    
                    if (userWorkerName && selectedWorkerList.length === 0) {
                        selectedWorkerList = [userWorkerName];
                        renderSelectedWorkers();
                        updateWorkerInput();
                
                    } else if (selectedWorkerList.length > 0) {
                    } else {
                    }
                } else {
                }
            } else {
            }
        }
        
        let selectedWorkerList = [];
        
        // Kh√¥ng load d·ªØ li·ªáu t·ª´ database, ch·ªâ ƒë·ªÉ tr·ªëng ƒë·ªÉ nh·∫≠p m·ªõi
        
        // Render selected workers
        function renderSelectedWorkers() {
            selectedWorkers.innerHTML = '';
            selectedWorkerList.forEach(worker => {
                const tag = document.createElement('div');
                tag.className = 'selected-tag';
                tag.innerHTML = `
                    ${worker}
                    <button class="remove-btn" onclick="event.stopPropagation(); event.preventDefault(); removeWorker('${worker}')">√ó</button>
                `;
                selectedWorkers.appendChild(tag);
            });
        }
        
        // Render dropdown options
        function renderDropdownOptions(filter = '') {
            
            
            workerOptions.innerHTML = '';
            const filteredWorkers = availableWorkers.filter(worker => 
                worker.toLowerCase().includes(filter.toLowerCase()) &&
                !selectedWorkerList.includes(worker)
            );
            
            
            filteredWorkers.forEach(worker => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.textContent = worker;
                item.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    addWorker(worker);
                };
                workerOptions.appendChild(item);
            });
            
        }
        
        // Add worker
        window.addWorker = function(worker) {
            if (!selectedWorkerList.includes(worker)) {
                selectedWorkerList.push(worker);
                renderSelectedWorkers();
                renderDropdownOptions(workerSearch.value);
                updateWorkerInput();
            }
            // Kh√¥ng ƒë√≥ng dropdown ngay, ƒë·ªÉ user c√≥ th·ªÉ ch·ªçn th√™m
            workerSearch.focus();
        };
        
        // Remove worker
        window.removeWorker = function(worker) {
            selectedWorkerList = selectedWorkerList.filter(w => w !== worker);
            renderSelectedWorkers();
            renderDropdownOptions(workerSearch.value);
            updateWorkerInput();
            // Focus l·∫°i v√†o search input sau khi x√≥a
            workerSearch.focus();
        };
        
        // Update hidden input for form submission
        function updateWorkerInput() {
            const workerInput = document.getElementById('worker');
            if (workerInput) {
                workerInput.value = selectedWorkerList.join(', ');
            }
        }
        
        // Event listeners
        workerSearch.addEventListener('focus', () => {
            workerDropdown.style.display = 'block';
            renderDropdownOptions();
        });
        
        // NgƒÉn ch·∫∑n event propagation cho to√†n b·ªô multi-select container
        const multiSelectContainer = document.querySelector('.multi-select-container');
        if (multiSelectContainer) {
            multiSelectContainer.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        }
        
        workerSearch.addEventListener('input', (e) => {
            renderDropdownOptions(e.target.value);
        });
        
        // NgƒÉn ch·∫∑n event propagation cho dropdown
        workerDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            // Ch·ªâ ƒë√≥ng dropdown n·∫øu click outside multi-select v√† kh√¥ng ph·∫£i click v√†o dropdown item
            if (!e.target.closest('.multi-select-container') && !e.target.closest('.dropdown-item')) {
                workerDropdown.style.display = 'none';
            }
        });
        
        // Initialize
        loadWorkersFromAPI().then(() => {
            renderSelectedWorkers();
            updateWorkerInput();
        });
    }
    
    // JavaScript cho ph·∫ßn ch·ªçn k·ªá - √Åp d·ª•ng t·ª´ demo-ke-sidebar.html
    let keData = {};
    let selectedKe = 0;
    let totalKe = 0;
    let previousProcessData = {};
    
    // H√†m t·∫°o k·ªá t·ª´ sheet_count khi l√† c√¥ng ƒëo·∫°n ƒë·∫ßu ti√™n
    function createKeDataFromSheetCount(order) {
        if (!order || !order.sheet_count) {
            console.log('‚ùå Kh√¥ng c√≥ order ho·∫∑c sheet_count');
            return;
        }
        
        console.log(`üìù T·∫°o k·ªá t·ª´ sheet_count: ${order.sheet_count} t·ªù`);
        
        // T·∫°o 1 k·ªá duy nh·∫•t v·ªõi s·ªë l∆∞·ª£ng b·∫±ng sheet_count
        previousProcessData = {
            1: {
                name: 'K·ªá ban ƒë·∫ßu',
                quantity: order.sheet_count,
                status: 'ready',
                previous_stage: 'initial',
                original_data: {
                    order_id: order.id,
                    sheet_count: order.sheet_count,
                    created_at: new Date().toISOString()
                }
            }
        };
        
        console.log('‚úÖ ƒê√£ t·∫°o k·ªá ban ƒë·∫ßu t·ª´ sheet_count:', previousProcessData);
        
        // C·∫≠p nh·∫≠t UI
        updateKeToggleGrid();
    }
    
    // H√†m l·∫•y d·ªØ li·ªáu k·ªá t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
    async function loadPreviousStageKeData(order) {
        if (!order || !order.workflow_definition) {
            console.log('‚ùå Kh√¥ng c√≥ order ho·∫∑c workflow_definition');
            return;
        }
        
        try {
            console.log('üîÑ B·∫Øt ƒë·∫ßu t·∫£i d·ªØ li·ªáu k·ªá cho order:', order.id, 'workflow:', order.workflow_definition);
            
            // X√°c ƒë·ªãnh c√¥ng ƒëo·∫°n tr∆∞·ªõc
            const workflow = order.workflow_definition.split(',').map(s => s.trim());
            const currentStageIndex = workflow.indexOf(STAGE_CONFIG.KEY);
            const previousStage = currentStageIndex > 0 ? workflow[currentStageIndex - 1] : null;
            
            console.log('üìù Workflow:', workflow, 'Current stage:', STAGE_CONFIG.KEY, 'Previous stage:', previousStage);
            
            if (!previousStage) {
                console.log('‚ÑπÔ∏è ƒê√¢y l√† c√¥ng ƒëo·∫°n ƒë·∫ßu ti√™n trong workflow');
                // T·∫°o 1 k·ªá t·ª´ sheet_count c·ªßa order
                createKeDataFromSheetCount(order);
                return;
            }
            
            console.log(`üîç ƒêang l·∫•y d·ªØ li·ªáu k·ªá t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc: ${previousStage}`);
            
            // L·∫•y d·ªØ li·ªáu k·ªá t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
            const apiUrl = `${API_BASE_URL}/data/production_orders/${order.id}/handover_json/${previousStage}`;
            console.log('üåê API URL:', apiUrl);
            
            const resp = await fetch(apiUrl);
            if (!resp.ok) {
                console.log(`‚ÑπÔ∏è API kh√¥ng th√†nh c√¥ng (status: ${resp.status}). Kh√¥ng c√≥ d·ªØ li·ªáu k·ªá t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc`);
                return;
            }
            
            const data = await resp.json();
            console.log('üì¶ D·ªØ li·ªáu API tr·∫£ v·ªÅ:', data);
            let raw = data && data.data ? data.data : null;
            if (!raw) return;
            
            if (typeof raw === 'string') {
                try { raw = JSON.parse(raw); } catch (_) { return; }
            }
            
            const recordsKey = `${previousStage}_ke_records`;
            const records = raw[recordsKey] || [];
            
            if (records.length === 0) {
                console.log(`‚ÑπÔ∏è Kh√¥ng c√≥ d·ªØ li·ªáu k·ªá trong c√¥ng ƒëo·∫°n ${previousStage}`);
                return;
            }
            
            // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu th√†nh format ph√π h·ª£p
            previousProcessData = {};
            records.forEach((rec, index) => {
                const keId = rec[`${previousStage}_ke_id`] || `ke_${index + 1}`;
                const keName = rec[`${previousStage}_ke_name`] || `K·ªá ${index + 1}`;
                const quantity = rec[`${previousStage}_quantity`] || 0;
                const status = rec[`${previousStage}_status`] || 'completed';
                
                // L·∫•y s·ªë k·ªá t·ª´ ke_id (v√≠ d·ª•: ke_3 -> 3)
                const match = keId.match(/(\d+)/);
                const keNumber = match ? parseInt(match[1]) : (index + 1);
                
                previousProcessData[keNumber] = {
                    name: keName,
                    quantity: quantity,
                    status: status,
                    previous_stage: previousStage,
                    original_data: rec
                };
            });
            
            console.log(`‚úÖ ƒê√£ t·∫£i ${Object.keys(previousProcessData).length} k·ªá t·ª´ c√¥ng ƒëo·∫°n ${previousStage}:`, previousProcessData);
            
            // C·∫≠p nh·∫≠t UI
            updateKeToggleGrid();
            
        } catch (error) {
            console.error('‚ùå L·ªói khi l·∫•y d·ªØ li·ªáu k·ªá t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc:', error);
        }
    }
    
    function createKeToggleItem(keNumber) {
        const processData = previousProcessData[keNumber];
        if (!processData) {
            return ''; // Kh√¥ng hi·ªÉn th·ªã n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu
        }
        
        // X√°c ƒë·ªãnh tr·∫°ng th√°i v√† class
        let statusClass = '';
        let statusText = '';
        
        if (processData.previous_stage === 'initial') {
            // D·ªØ li·ªáu t·ª´ order ban ƒë·∫ßu (stage ƒë·∫ßu workflow)
            statusClass = 'ready';
            statusText = 'S·∫µn s√†ng';
        } else {
            // D·ªØ li·ªáu t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
            statusClass = processData.status === 'completed' ? 'completed' : '';
            statusText = processData.status === 'completed' ? 'Ho√†n th√†nh' : 'ƒêang x·ª≠ l√Ω';
        }
        
        return `
            <div class="ke-toggle-item ${statusClass}" id="ke-${keNumber}" onclick="toggleKe(${keNumber})">
                <div class="ke-toggle-header">
                    <div class="ke-info">
                        <div class="ke-title-row">
                            <svg class="ke-icon" viewBox="0 0 224 96.06" xmlns="http://www.w3.org/2000/svg">
                                <polygon class="cls-1" points="224 48.06 224 96.06 192 96.06 192 64.06 128 64.06 128 96.06 96 96.06 96 64.06 32 64.06 32 96.06 0 96.06 0 48.06 224 48.06"/>
                                <polygon class="cls-1" points="97 .06 88 40.06 48 40.06 72 .06 97 .06"/>
                                <polygon class="cls-1" points="152 .06 176 40.06 136 40.06 127 .06 152 .06"/>
                                <path class="cls-1" d="M67,.06c.73.64-3.45,6.24-4.18,7.32-7.49,11.06-15.25,22.04-23.32,32.68H1C14.27,25.89,29.07,13.08,43.5.06h23.5Z"/>
                                <path class="cls-1" d="M223,40.06h-38.5c-8.07-10.64-15.83-21.63-23.32-32.68-1.49-2.2-3.71-4.71-4.18-7.32h23.5c14.43,13.02,29.23,25.83,42.5,40Z"/>
                                <polygon class="cls-1" points="96 40.06 102.58 0 121.95 .11 128 40.06 96 40.06"/>
                            </svg>
                            <h6 class="ke-toggle-title">${processData.name}</h6>
                        </div>
                        <div class="ke-quantity">S·ªë l∆∞·ª£ng: ${processData.quantity.toLocaleString()} t·ªù</div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function updateKeToggleGrid() {
        const grid = document.getElementById('keToggleGrid');
        if (!grid) return;
        
        grid.innerHTML = '';
        
        const keNumbers = Object.keys(previousProcessData).map(Number).sort((a, b) => a - b);
        
        if (keNumbers.length === 0) {
            grid.innerHTML = '<div class="no-ke-data">Kh√¥ng c√≥ d·ªØ li·ªáu k·ªá t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc</div>';
            return;
        }
        
        keNumbers.forEach(keNumber => {
            const itemHtml = createKeToggleItem(keNumber);
            if (itemHtml) {
                grid.innerHTML += itemHtml;
            }
        });
        
        // C·∫≠p nh·∫≠t t·ªïng s·ªë k·ªá
        totalKe = keNumbers.length;
        
        // T·ª± ƒë·ªông ch·ªçn k·ªá c√≥ tr·∫°ng th√°i 'in_progress' cho stage hi·ªán t·∫°i
        setTimeout(() => {
            autoSelectInProgressRacks();
        }, 100);
        
        updateSummary();
    }
    
    function toggleKe(keNumber) {
        const item = document.getElementById(`ke-${keNumber}`);
        const isSelected = item.classList.contains('selected');
        
        if (isSelected) {
            item.classList.remove('selected');
            selectedKe--;
            delete keData[keNumber];
        } else {
            item.classList.add('selected');
            selectedKe++;
            
            // L∆∞u th√¥ng tin k·ªá ƒë∆∞·ª£c ch·ªçn
            keData[keNumber] = {
                process: previousProcessData[keNumber],
                status: 'selected'
            };
        }
        
        updateSummary();
    }
    
    function updateSummary() {
        const summarySection = document.getElementById('summarySection');
        
        if (selectedKe > 0) {
            summarySection.style.display = 'block';
            
            // Calculate summary
            let totalQuantity = 0;
            Object.values(keData).forEach(data => {
                totalQuantity += data.process.quantity;
            });
            
            document.getElementById('totalKe').textContent = totalKe;
            document.getElementById('selectedKe').textContent = selectedKe;
            document.getElementById('totalQuantity').textContent = totalQuantity.toLocaleString();
            document.getElementById('completionRate').textContent = Math.round((selectedKe / totalKe) * 100) + '%';
            
            // Update selected rack quantity display in sidebar
            updateSelectedRackQuantityDisplaySync();
        } else {
            summarySection.style.display = 'none';
            
            // Clear selected rack quantity display
            const selectedRackDisplay = document.getElementById('selectedRackQuantityDisplay');
            if (selectedRackDisplay) {
                selectedRackDisplay.textContent = 'Ch∆∞a ch·ªçn k·ªá';
                selectedRackDisplay.style.color = '#9e9e9e';
            }
        }
        
        // Update handover button validation
        updateHandoverButtonValidationSync();
    }
    
    function toggleSelectAllKe(master) {
        const items = document.querySelectorAll('.ke-toggle-item');
        
        // Reset selectedKe count
        selectedKe = 0;
        keData = {};
        
        items.forEach(item => {
            const keNumberMatch = item.id.match(/ke-(\d+)/);
            const keNumber = keNumberMatch ? parseInt(keNumberMatch[1]) : null;
            
            if (keNumber && previousProcessData[keNumber]) {
                if (master.checked) {
                    item.classList.add('selected');
                    selectedKe++;
                    
                    keData[keNumber] = {
                        process: previousProcessData[keNumber],
                        status: 'selected'
                    };
                } else {
                    item.classList.remove('selected');
                }
            }
        });
        
        updateSummary();
    }
    
    function resetAllKe() {
        if (selectedKe === 0) return;
        
        const items = document.querySelectorAll('.ke-toggle-item.selected');
        items.forEach(item => item.classList.remove('selected'));
        
        selectedKe = 0;
        Object.keys(keData).forEach(key => delete keData[key]);
        
        updateSummary();
    }
    
    // Initialize ke toggle grid
    function initializeKeToggleGrid() {
        const grid = document.getElementById('keToggleGrid');
        if (grid) {
            updateKeToggleGrid();
        }
    }
    
    // Kh·ªüi t·∫°o khi trang load xong
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(() => {
            initializeKeToggleGrid();
        }, 500);
    });
    
    // Th√™m event listener ƒë·ªÉ kh·ªüi t·∫°o l·∫°i khi chuy·ªÉn tab
    function initializeKeSelectionWhenTabActive() {
        const infoPanel = document.getElementById('info-panel');
        if (infoPanel && infoPanel.classList.contains('active')) {
            setTimeout(() => {
                // T·ª± ƒë·ªông t·∫£i d·ªØ li·ªáu k·ªá t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc n·∫øu c√≥ order
                if (currentEditingOrder) {
                    loadKeDataWhenOrderSelected(currentEditingOrder);
                }
            }, 100);
        }
    }
    
    // H√†m g·ªçi khi load order ƒë·ªÉ t·∫£i d·ªØ li·ªáu k·ªá t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
    async function loadKeDataWhenOrderSelected(order) {
        if (!order) return;
        
        // Reset d·ªØ li·ªáu
        previousProcessData = {};
        // ƒê·ª´ng reset keData v√¨ n√≥ s·∫Ω x√≥a d·ªØ li·ªáu ƒëang ch·ªçn
        // keData = {}; // ƒê√£ x√≥a d√≤ng n√†y ƒë·ªÉ tr√°nh l·ªói const
        selectedKe = 0;
        
        // T·∫£i d·ªØ li·ªáu k·ªá t·ª´ c√¥ng ƒëo·∫°n tr∆∞·ªõc
        await loadPreviousStageKeData(order);
    }
    
    // G·ªçi function n√†y khi chuy·ªÉn tab
    if (typeof switchTab === 'function') {
        const originalSwitchTab = switchTab;
        window.switchTab = function(tabName) {
            originalSwitchTab(tabName);
            if (tabName === 'info') {
                initializeKeSelectionWhenTabActive();
            }
        };
    }
    
    // handleLogout ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü tr√™n
    
    // ========================================
    // FUNCTIONS RI√äNG CHO PH·∫¶N CH·ªåN K·ªÜ
    // ========================================
    

    
    // ========================================
    // FUNCTIONS UI CHO PH·∫¶N CH·ªåN K·ªÜ
    // ========================================
    
    // H√†m l∆∞u d·ªØ li·ªáu k·ªá t·ª´ UI
    async function saveKeDataToUI() {
      if (!currentEditingOrder) {
        alert('Vui l√≤ng ch·ªçn m·ªôt l·ªánh s·∫£n xu·∫•t tr∆∞·ªõc!');
        return;
      }

      if (selectedKe === 0) {
        alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt k·ªá tr∆∞·ªõc khi l∆∞u!');
        return;
      }

      try {
        // Hi·ªÉn th·ªã loading
        showLoading('ƒêang l∆∞u d·ªØ li·ªáu k·ªá...');
        
        // T·∫°o d·ªØ li·ªáu JSON t·ª´ d·ªØ li·ªáu hi·ªán t·∫°i
        const keDataJSON = createKeDataJSON();
        
        // L∆∞u v√†o database
        const result = await saveKeDataToDatabase(
          currentEditingOrder.id,
          'xen', // Stage hi·ªán t·∫°i (c√≥ th·ªÉ thay ƒë·ªïi)
          keDataJSON,
          currentEditingOrder.production_order
        );
        
        // ·∫®n loading
        hideLoading();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
        showSuccessMessage('ƒê√£ l∆∞u d·ªØ li·ªáu k·ªá th√†nh c√¥ng!');
        
        console.log('‚úÖ D·ªØ li·ªáu k·ªá ƒë√£ ƒë∆∞·ª£c l∆∞u:', result);
        
      } catch (error) {
        // ·∫®n loading
        hideLoading();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói
        showErrorMessage('L·ªói khi l∆∞u d·ªØ li·ªáu k·ªá: ' + error.message);
        
        console.error('‚ùå L·ªói khi l∆∞u d·ªØ li·ªáu k·ªá:', error);
      }
    }

    // H√†m t·∫£i d·ªØ li·ªáu k·ªá t·ª´ UI
    async function loadKeDataFromUI() {
      if (!currentEditingOrder) {
        alert('Vui l√≤ng ch·ªçn m·ªôt l·ªánh s·∫£n xu·∫•t tr∆∞·ªõc!');
        return;
      }

      try {
        // Hi·ªÉn th·ªã loading
        showLoading('ƒêang t·∫£i d·ªØ li·ªáu k·ªá...');
        
        // T·∫£i d·ªØ li·ªáu t·ª´ database
        const keDataJSON = await loadKeDataFromDatabase(
          currentEditingOrder.id,
          'xen' // Stage hi·ªán t·∫°i (c√≥ th·ªÉ thay ƒë·ªïi)
        );
        
        // ·∫®n loading
        hideLoading();
        
        if (keDataJSON) {
          // Kh√¥i ph·ª•c d·ªØ li·ªáu k·ªá t·ª´ JSON
          restoreKeDataFromJSON(keDataJSON);
          
          // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
          showSuccessMessage('ƒê√£ t·∫£i d·ªØ li·ªáu k·ªá th√†nh c√¥ng!');
          
          console.log('‚úÖ D·ªØ li·ªáu k·ªá ƒë√£ ƒë∆∞·ª£c t·∫£i:', keDataJSON);
        } else {
          // Hi·ªÉn th·ªã th√¥ng b√°o kh√¥ng c√≥ d·ªØ li·ªáu
          showInfoMessage('Ch∆∞a c√≥ d·ªØ li·ªáu k·ªá ƒë·ªÉ t·∫£i!');
        }
        
      } catch (error) {
        // ·∫®n loading
        hideLoading();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói
        showErrorMessage('L·ªói khi t·∫£i d·ªØ li·ªáu k·ªá: ' + error.message);
        
        console.error('‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu k·ªá:', error);
      }
    }

    // H√†m x√≥a d·ªØ li·ªáu k·ªá t·ª´ UI
    async function deleteKeDataFromUI() {
      if (!currentEditingOrder) {
        alert('Vui l√≤ng ch·ªçn m·ªôt l·ªánh s·∫£n xu·∫•t tr∆∞·ªõc!');
        return;
      }

      // X√°c nh·∫≠n x√≥a
      if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a d·ªØ li·ªáu k·ªá? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!')) {
        return;
      }

      try {
        // Hi·ªÉn th·ªã loading
        showLoading('ƒêang x√≥a d·ªØ li·ªáu k·ªá...');
        
        // X√≥a d·ªØ li·ªáu t·ª´ database
        const result = await deleteKeDataFromDatabase(
          currentEditingOrder.id,
          'xen' // Stage hi·ªán t·∫°i (c√≥ th·ªÉ thay ƒë·ªïi)
        );
        
        // ·∫®n loading
        hideLoading();
        
        // Reset d·ªØ li·ªáu k·ªá hi·ªán t·∫°i
        resetAllKe();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
        showSuccessMessage('ƒê√£ x√≥a d·ªØ li·ªáu k·ªá th√†nh c√¥ng!');
        
        console.log('‚úÖ D·ªØ li·ªáu k·ªá ƒë√£ ƒë∆∞·ª£c x√≥a:', result);
        
      } catch (error) {
        // ·∫®n loading
        hideLoading();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói
        showErrorMessage('L·ªói khi x√≥a d·ªØ li·ªáu k·ªá: ' + error.message);
        
        console.error('‚ùå L·ªói khi x√≥a d·ªØ li·ªáu k·ªá:', error);
      }
    }

    // H√†m hi·ªÉn th·ªã loading
    function showLoading(message = 'ƒêang x·ª≠ l√Ω...') {
      const loadingOverlay = document.getElementById('loadingOverlay');
      if (loadingOverlay) {
        const loadingText = loadingOverlay.querySelector('.mt-2');
        if (loadingText) {
          loadingText.textContent = message;
        }
        loadingOverlay.style.display = 'flex';
      }
    }

    // H√†m ·∫©n loading
    function hideLoading() {
      const loadingOverlay = document.getElementById('loadingOverlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
      }
    }

    // H√†m hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
    function showSuccessMessage(message) {
      // T·∫°o toast notification
      const toast = document.createElement('div');
      toast.className = 'alert alert-success alert-dismissible fade show position-fixed';
      toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
      toast.innerHTML = `
        <i class="bi bi-check-circle me-2"></i>
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(toast);
      
      // T·ª± ƒë·ªông ·∫©n sau 3 gi√¢y
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 3000);
    }

    // H√†m hi·ªÉn th·ªã th√¥ng b√°o l·ªói
    function showErrorMessage(message) {
      // T·∫°o toast notification
      const toast = document.createElement('div');
      toast.className = 'alert alert-danger alert-dismissible fade show position-fixed';
      toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
      toast.innerHTML = `
        <i class="bi bi-exclamation-triangle me-2"></i>
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(toast);
      
      // T·ª± ƒë·ªông ·∫©n sau 5 gi√¢y
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 5000);
    }

    // H√†m hi·ªÉn th·ªã th√¥ng b√°o th√¥ng tin
    function showInfoMessage(message) {
      // T·∫°o toast notification
      const toast = document.createElement('div');
      toast.className = 'alert alert-info alert-dismissible fade show position-fixed';
      toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
      toast.innerHTML = `
        <i class="bi bi-info-circle me-2"></i>
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(toast);
      
      // T·ª± ƒë·ªông ·∫©n sau 3 gi√¢y
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 3000);
    }
    
    // ========================================
    // FUNCTIONS HI·ªÇN TH·ªä D·ªÆ LI·ªÜU K·ªÜ ƒê√É L∆ØU
    // ========================================
    
    // H√†m t·∫£i d·ªØ li·ªáu k·ªá ƒë√£ l∆∞u t·ª´ database
    async function loadSavedKeData() {
      if (!currentEditingOrder) {
        console.log('‚ÑπÔ∏è Kh√¥ng c√≥ l·ªánh s·∫£n xu·∫•t n√†o ƒëang ƒë∆∞·ª£c ch·ªânh s·ª≠a');
        return;
      }
      
      try {
        showLoading('ƒêang t·∫£i d·ªØ li·ªáu k·ªá...');
        
        // S·ª≠ d·ª•ng API m·ªõi t·ª´ production_orders
        const response = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/handover_json/${STAGE_CONFIG.KEY}`);
        
        if (response.ok) {
          const result = await response.json();
          
          if (result.success && result.data.ke_data_json) {
            displaySavedKeData(result.data.ke_data_json);
            document.getElementById('savedKeSection').style.display = 'block';
            console.log('‚úÖ ƒê√£ t·∫£i d·ªØ li·ªáu k·ªá t·ª´ production_orders:', result.data);
          } else {
            console.log('‚ÑπÔ∏è Kh√¥ng c√≥ d·ªØ li·ªáu k·ªá ƒë√£ l∆∞u');
            document.getElementById('savedKeSection').style.display = 'none';
          }
        } else if (response.status === 404) {
          console.log('‚ÑπÔ∏è Ch∆∞a c√≥ d·ªØ li·ªáu JSON k·ªá cho c√¥ng ƒëo·∫°n:', STAGE_CONFIG.KEY);
          document.getElementById('savedKeSection').style.display = 'none';
        } else {
          const errorData = await response.json();
          throw new Error(errorData.error || 'L·ªói khi t·∫£i d·ªØ li·ªáu k·ªá');
        }
      } catch (error) {
        console.error('‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu k·ªá:', error);
        showNotification('L·ªói khi t·∫£i d·ªØ li·ªáu k·ªá: ' + error.message, 'error');
      } finally {
        hideLoading();
      }
    }
    
    // H√†m hi·ªÉn th·ªã d·ªØ li·ªáu k·ªá ƒë√£ l∆∞u
    function displaySavedKeData(keData) {
      const contentElement = document.getElementById('savedKeContent');
      if (!contentElement) return;
      
      if (!keData.ke_records || keData.ke_records.length === 0) {
        contentElement.innerHTML = '<p class="text-muted text-center">Kh√¥ng c√≥ d·ªØ li·ªáu k·ªá n√†o</p>';
        return;
      }
      
      const keItemsHTML = keData.ke_records.map(ke => `
        <div class="saved-ke-item">
          <div class="saved-ke-info">
            <div class="saved-ke-name">${ke.ke_name}</div>
            <div class="saved-ke-details">
              <i class="bi bi-person me-1"></i>${ke.operator || 'N/A'} | 
              <i class="bi bi-clock me-1"></i>${ke.shift || 'N/A'} | 
              <i class="bi bi-calendar me-1"></i>${formatDateTime(ke.handover_time) || 'N/A'}
            </div>
            ${ke.notes ? `<div class="saved-ke-details mt-1"><i class="bi bi-chat-text me-1"></i>${ke.notes}</div>` : ''}
          </div>
          <div class="saved-ke-quantity">${ke.quantity}</div>
        </div>
      `).join('');
      
      contentElement.innerHTML = keItemsHTML;
    }
    
    // H√†m x√≥a d·ªØ li·ªáu k·ªá ƒë√£ l∆∞u
    async function clearSavedKeData() {
      if (!currentEditingOrder) {
        showNotification('Kh√¥ng c√≥ l·ªánh s·∫£n xu·∫•t n√†o ƒëang ƒë∆∞·ª£c ch·ªânh s·ª≠a', 'warning');
        return;
      }
      
      const confirmed = confirm(`X√°c nh·∫≠n x√≥a d·ªØ li·ªáu k·ªá ƒë√£ l∆∞u cho l·ªánh ${currentEditingOrder.production_order}?\n\nD·ªØ li·ªáu n√†y s·∫Ω b·ªã x√≥a vƒ©nh vi·ªÖn!`);
      
      if (!confirmed) return;
      
      try {
        showLoading('ƒêang x√≥a d·ªØ li·ªáu k·ªá...');
        
        // S·ª≠ d·ª•ng API m·ªõi t·ª´ production_orders
        const response = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/handover_json/${STAGE_CONFIG.KEY}`, {
          method: 'DELETE'
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'L·ªói khi x√≥a d·ªØ li·ªáu k·ªá');
        }
        
        const result = await response.json();
        console.log('‚úÖ ƒê√£ x√≥a d·ªØ li·ªáu k·ªá t·ª´ production_orders:', result);
        
        // ·∫®n section v√† hi·ªÉn th·ªã th√¥ng b√°o
        document.getElementById('savedKeSection').style.display = 'none';
        showNotification('‚úÖ ƒê√£ x√≥a d·ªØ li·ªáu k·ªá th√†nh c√¥ng!', 'success');
        
      } catch (error) {
        console.error('‚ùå L·ªói khi x√≥a d·ªØ li·ªáu k·ªá:', error);
        showNotification('L·ªói khi x√≥a d·ªØ li·ªáu k·ªá: ' + error.message, 'error');
      } finally {
        hideLoading();
      }
    }
  </script>

  <!-- Details Panel - Will be generated dynamically -->
  <div class="details-panel" id="detailsPanel">
    <!-- Content will be generated by showOrderDetails() function -->
  </div>
  
  <!-- Loading Overlay -->
  <div id="loadingOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; justify-content: center; align-items: center;">
    <div class="text-center text-white">
      <div class="spinner-border" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <div class="mt-2">ƒêang t·∫£i d·ªØ li·ªáu t·ª´ API...</div>
    </div>
  </div>
  
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
