<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Công đoạn Xén - Carton Manager</title>
  <!-- Bootstrap Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <!-- Universal Stage CSS -->
  <link rel="stylesheet" href="universal-stage.css">
  <!-- Sidebar Generator -->
  <script src="sidebar-generator.js"></script>
  <!-- Custom Logout Handler -->
  <script>
    // Định nghĩa handleLogout trước khi auth.js load
    window.handleLogout = function() {
      // Xóa session
      localStorage.removeItem('user_session');
      
      // Ẩn thông tin user
      updateUserInfo();
      
      // Hiển thị login popup
      showLoginPopup({
        onLoginSuccess: function(userData) {
          updateUserInfo();
          refreshData();
        }
      });
    };
  </script>
  
  <!-- Auth Manager -->
  <script src="../js/auth.js"></script>
  <!-- Login Popup Component -->
  <script src="../js/login-popup.js"></script>

  <!-- Custom CSS for Shifts Tab -->
  <style>
    /* Shifts Tab Styles */
    .shifts-container {
      padding: 0;
    }
    
    .shifts-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #e9ecef;
    }
    
    .shifts-header h6 {
      margin: 0;
      color: #495057;
      font-weight: 600;
    }
    
    .shifts-loading {
      display: flex;
      align-items: center;
      color: #6c757d;
      font-size: 0.875rem;
    }
    
    .shifts-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .shifts-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: #f8fafc;
      padding: 16px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid #e2e8f0;
    }

    .stat-number {
      font-size: 24px;
      font-weight: 700;
      color: #2563eb;
      margin-bottom: 4px;
    }

    .stat-label {
      font-size: 12px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .shift-item {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .shift-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      border-color: #2563eb;
    }

    .shift-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: #2563eb;
    }
    
    .shift-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    
    .shift-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: #1f2937;
    }

    .shift-title i {
      color: #2563eb;
      font-size: 16px;
    }
    
    .shift-status {
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .shift-status.completed {
      background: #dcfce7;
      color: #16a34a;
    }
    
    .shift-status.in_progress {
      background: #fef3c7;
      color: #ca8a04;
    }
    
    .shift-status.waiting {
      background: #e0e7ff;
      color: #2563eb;
    }
    
    .shift-status.paused {
      background: #fecaca;
      color: #dc2626;
    }
    
    .shift-status.handed_over {
      background: #cffafe;
      color: #0891b2;
    }
    
    .shift-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .shift-detail {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .shift-detail-label {
      font-size: 12px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }
    
    .shift-detail-value {
      font-size: 14px;
      font-weight: 600;
      color: #1f2937;
    }
    
    .shift-times {
      display: flex;
      gap: 24px;
      padding-top: 16px;
      border-top: 1px solid #e2e8f0;
      font-size: 13px;
      color: #6b7280;
    }

    .shift-times span {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .shift-times i {
      font-size: 14px;
    }

    .shift-progress {
      margin-top: 12px;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
    }

    .progress-bar {
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #16a34a, #2563eb);
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 12px;
      color: #6b7280;
      text-align: center;
    }

    .shift-actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e2e8f0;
    }

    .btn-action {
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .btn-view {
      background: #2563eb;
      color: white;
    }

    .btn-view:hover {
      background: #1d4ed8;
      color: white;
    }

    .btn-edit {
      background: #ca8a04;
      color: white;
    }

    .btn-edit:hover {
      background: #a16207;
      color: white;
    }

    .empty-state {
      text-align: center;
      padding: 48px 24px;
      color: #6b7280;
    }

    .empty-state i {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .empty-state h5 {
      margin-bottom: 8px;
      color: #1f2937;
    }

    .empty-state p {
      margin: 0;
      font-size: 14px;
    }

    @media (max-width: 768px) {
      .shifts-stats {
        grid-template-columns: 1fr;
      }
      
      .shift-details {
        grid-template-columns: 1fr;
      }
      
      .shift-times {
        flex-direction: column;
        gap: 8px;
      }
    }
    
    .shift-summary {
      background: #e9ecef;
      border-radius: 6px;
      padding: 1rem;
      margin-top: 1rem;
    }
    
    .shift-summary h6 {
      margin-bottom: 0.75rem;
      color: #495057;
      font-weight: 600;
    }
    
    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.75rem;
    }
    
    .summary-stat {
      text-align: center;
      padding: 0.5rem;
      background: white;
      border-radius: 4px;
    }
    
    .summary-stat-value {
      font-size: 1.25rem;
      font-weight: 600;
      color: #495057;
    }
    
    .summary-stat-label {
      font-size: 0.75rem;
      color: #6c757d;
      margin-top: 0.25rem;
    }
    
    .no-shifts {
      text-align: center;
      padding: 2rem;
      color: #6c757d;
    }
    
    .no-shifts i {
      font-size: 2rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }
    
    .shifts-container {
      min-height: 200px;
      border: 1px solid #ddd;
      padding: 15px;
      background: #fff;
    }
    
    /* Button styles for shift handover */
    .btn-info-custom {
      background: linear-gradient(135deg, #17a2b8, #138496);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 120px;
      justify-content: center;
    }
    
    .btn-info-custom:hover {
      background: linear-gradient(135deg, #138496, #117a8b);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(23, 162, 184, 0.3);
    }
    
    .btn-info-custom:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(23, 162, 184, 0.3);
    }
    
    /* Quantity Table Styles */
    .quantity-table {
      background: white;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0,0,0,0.08);
      margin-bottom: 20px;
    }
    
    .table-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .table-header h6 {
      margin: 0;
      font-weight: 600;
      font-size: 1rem;
    }
    
    .table-actions {
      display: flex;
      gap: 10px;
    }
    
    .btn-add-row {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 0.875rem;
    }
    
    .btn-add-row:hover {
      background: rgba(255,255,255,0.3);
      transform: translateY(-1px);
    }
    
    .table-container {
      overflow-x: auto;
    }
    
    .quantity-table table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .quantity-table th {
      background: #f8f9fa;
      padding: 12px 8px;
      text-align: center;
      font-weight: 600;
      color: #495057;
      border-bottom: 2px solid #dee2e6;
      font-size: 0.875rem;
    }
    
    .quantity-table td {
      padding: 10px 8px;
      text-align: center;
      border-bottom: 1px solid #dee2e6;
      vertical-align: middle;
      font-size: 0.875rem;
    }
    
    .quantity-table tr:hover {
      background: #f8f9fa;
    }
    
    /* .quantity-input {
      width: 80px;
      padding: 6px 8px;
      border: 2px solid #e9ecef;
      border-radius: 6px;
      text-align: center;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 0.875rem;
    } */
    
    /* .quantity-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    } */
    
    .quantity-input.ok {
      border-color: #28a745;
      color: #28a745;
    }
    
    .quantity-input.ng {
      border-color: #dc3545;
      color: #dc3545;
    }
    
    .btn-remove-row {
      background: #dc3545;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.75rem;
    }
    
    .btn-remove-row:hover {
      background: #c82333;
      transform: scale(1.05);
    }
         /* ========================================
     * CSS RIÊNG CHO PHẦN CHỌN KỆ
     * ======================================== */
     
     /* Saved Ke Section Styles */
     .saved-ke-section {
       background: #f8f9fa;
       border-radius: 12px;
       padding: 20px;
       margin-top: 25px;
     }
     
     .saved-ke-header {
       text-align: center;
       margin-bottom: 20px;
     }
     
     .saved-ke-actions {
       display: flex;
       gap: 10px;
       justify-content: center;
       margin-top: 15px;
     }
     
     .saved-ke-content {
       background: white;
       border-radius: 8px;
       padding: 15px;
       border: 1px solid #dee2e6;
     }
     
     .saved-ke-item {
       display: flex;
       justify-content: space-between;
       align-items: center;
       padding: 12px;
       border-bottom: 1px solid #e9ecef;
       background: #f8f9fa;
       border-radius: 6px;
       margin-bottom: 8px;
     }
     
     .saved-ke-item:last-child {
       border-bottom: none;
       margin-bottom: 0;
     }
     
     .saved-ke-info {
       flex: 1;
     }
     
     .saved-ke-name {
       font-weight: 600;
       color: #495057;
       margin-bottom: 4px;
     }
     
     .saved-ke-details {
       font-size: 0.9rem;
       color: #6c757d;
     }
     
     .saved-ke-quantity {
       font-weight: 700;
       color: #28a745;
       font-size: 1.1rem;
       margin-left: 15px;
     }
     
     /* Kệ Toggle Styles */
     .ke-toggle-list {
       margin-bottom: 20px;
     }
     
     .ke-toggle-grid {
       display: grid;
       grid-template-columns: 1fr 1fr;
       gap: 12px;
       margin-bottom: 20px;
     }
     
     .ke-toggle-item {
       background: white;
       border-radius: 12px;
       border: 2px solid #e9ecef;
       overflow: hidden;
       transition: all 0.3s ease;
       min-height: 80px;
       cursor: pointer;
     }
     
     .ke-toggle-item:hover {
       transform: translateY(-2px);
       box-shadow: 0 5px 15px rgba(0,0,0,0.1);
     }
     
     .ke-toggle-item.selected {
       border-color: #667eea;
       box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
       background: linear-gradient(135deg, #f8f9ff 0%, #f0f2ff 100%);
     }
     
     .ke-toggle-item.in-progress {
       border-color: #ffc107;
       background: linear-gradient(135deg, #fff8e1 0%, #fff3cd 100%);
       box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.1);
       color: #495057;  
     }
          
     .ke-toggle-item.in-progress.selected .ke-quantity {

       color: #495057;  
     } 
     .ke-toggle-item.in-progress:hover {
       border-color: #ffb300;
       background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
       box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.2);
     }
     
     .ke-toggle-item.in-progress .ke-toggle-header {
       background: linear-gradient(135deg, #fff8e1 0%, #fff3cd 100%);
     }
     
     .ke-toggle-item.in-progress .ke-icon {
       fill: #ff8f00;
     }
     
     /* Ensure in-progress styling wins over selected when both are present */
     .ke-toggle-item.in-progress.selected {
       border-color: #ffc107;
       background: linear-gradient(135deg, #fff8e1 0%, #fff3cd 100%);
       box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.2);
     }
     
     .ke-toggle-item.in-progress.selected .ke-toggle-header {
       background: linear-gradient(135deg, #fff8e1 0%, #fff3cd 100%);
       color: #495057; /* keep readable text on yellow background */
     }
     
     .ke-toggle-item.in-progress.selected .ke-icon {
       fill: #ff8f00;
     }
     
     .ke-toggle-header {
       background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
       padding: 15px;
       display: flex;
       align-items: center;
       transition: all 0.3s ease;
       height: 100%;
     }
     
     .ke-toggle-item.selected .ke-toggle-header {
       background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
       color: white;
     }
     
     .ke-info {
       display: flex;
       flex-direction: column;
       gap: 3px;
       width: 100%;
     }
     
     .ke-title-row {
       display: flex;
       align-items: center;
       gap: 8px;
     }
     
     .ke-icon {
       width: 24px;
       height: 24px;
       fill: #667eea;
       flex-shrink: 0;
     }
     
     .ke-toggle-item.selected .ke-icon {
       fill: white;
     }
     
     .ke-toggle-title {
       font-size: 1rem;
       font-weight: 600;
       margin: 0;
     }
     
     .ke-quantity {
       font-size: 0.8rem;
       color: #6c757d;
       font-weight: 500;
     }
     
     .ke-toggle-item.selected .ke-quantity {
       color: rgba(255, 255, 255, 0.8);
     }

     
     /* Progress Section Styles */
     .progress-section {
       background: #f8f9fa;
       border-radius: 12px;
       padding: 20px;
       margin-bottom: 20px;
     }
     
     .progress-title {
       color: #667eea;
       font-weight: 600;
       margin-bottom: 15px;
       text-align: center;
       font-size: 1.1rem;
     }
     
     .progress-bar {
       height: 8px;
       background: #e9ecef;
       border-radius: 4px;
       overflow: hidden;
       margin-bottom: 15px;
     }
     
     .progress-fill {
       height: 100%;
       background: linear-gradient(90deg, #667eea, #764ba2);
       border-radius: 4px;
       transition: width 0.3s ease;
     }
     
     .progress-stats {
       display: grid;
       grid-template-columns: 1fr 1fr;
       gap: 15px;
     }
     
     .stat-item {
       background: white;
       border-radius: 8px;
       padding: 15px;
       text-align: center;
       border: 1px solid #e9ecef;
     }
     
     .stat-value {
       font-size: 1.5rem;
       font-weight: 700;
       color: #667eea;
       margin-bottom: 5px;
     }
     
     .ke-stat-label {
       color: #6c757d;
       font-size: 0.8rem;
       font-weight: 500;
     }
     
     /* Summary Section Styles */
     .summary-section {
       background: #f8f9fa;
       border-radius: 12px;
       padding: 20px;
       margin-bottom: 20px;
     }
     
     .summary-title {
       color: #667eea;
       font-weight: 600;
       margin-bottom: 15px;
       text-align: center;
       font-size: 1.1rem;
     }
     
     .summary-grid {
       display: grid;
       grid-template-columns: 1fr 1fr;
       gap: 15px;
       margin-bottom: 20px;
     }
     
     .summary-card {
       background: white;
       border-radius: 8px;
       padding: 15px;
       text-align: center;
       border: 1px solid #e9ecef;
     }
     
     .summary-value {
       font-size: 1.4rem;
       font-weight: 700;
       color: #667eea;
       margin-bottom: 5px;
     }
     
     .summary-label {
       color: #6c757d;
       font-size: 0.8rem;
       font-weight: 500;
     }
     
     /* Bulk Controls Styles */
     .bulk-controls {
       display: flex;
       flex-direction: column;
       gap: 10px;
       margin-bottom: 20px;
     }
     
     .form-check-ke {
       margin: 0;
     }
     
     .form-check-label-ke {
       font-weight: 500;
       color: #495057;
     }
  </style>
</head>
<body data-stage="xen">
  <!-- Sidebar will be generated by JavaScript -->

  <!-- Main Content -->
  <div class="main-content sidebar-collapsed" id="mainContent">
    <div class="content-area">
    <div class="container-fluid p-4">
      
      <!-- Stage Header -->
      <div class="stage-header">
        <div class="d-flex justify-content-between align-items-center">
          <div>
            <h1>
              <i class="bi bi-bullseye me-2"></i>
              Công đoạn Xén
            </h1>

            <p class="mb-0">Xén giấy - Quản lý chi tiết sản xuất</p>
          </div>
          
          <div class="user-controls">
            <div class="user-info d-flex align-items-center me-3">
              <i class="fas fa-user-circle me-2"></i>
              <span id="userName" class="fw-bold me-2">Loading...</span>
              <!-- <span class="badge bg-primary" id="userRole">...</span> -->
            </div>
            <button class="btn btn-outline-primary btn-sm" onclick="handleLogout()">
              <i class="fas fa-sign-out-alt me-1"></i>Đăng xuất
            </button>
          </div>
        </div>
      </div>
      
      <!-- Statistics -->
      <div class="row mb-4" id="stageStats">
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalOrders">0</div>
            <div class="stat-label">Tổng lệnh</div>
          </div>
        </div>
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalPlan">0</div>
            <div class="stat-label">SL Kế hoạch</div>
          </div>
        </div>
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalGood">0</div>
            <div class="stat-label">SL Đạt</div>
          </div>
        </div>
        <div class="col-xl-3 col-md-6 mb-3">
          <div class="stat-card">
            <div class="stat-value" id="totalNg">0</div>
            <div class="stat-label">SL NG</div>
          </div>
        </div>
      </div>
      
      <!-- Main Card -->
      <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
                          <h5 class="mb-0">Danh sách lệnh sản xuất </h5>
          <div class="d-flex align-items-center">

            <!-- Main Actions -->
            <button class="btn btn-primary me-2" onclick="refreshData()">
              <i class="bi bi-arrow-clockwise me-1"></i>Làm mới
            </button>
            <button class="btn btn-outline-primary me-2" onclick="loadDataWithDateFilter()">
              <i class="bi bi-calendar-range me-1"></i>Tải theo ngày
            </button>
          </div>
        </div>
        
        <div class="card-body">
          <!-- Filters -->
          <div class="card mb-3">
            <div class="card-header bg-light">
              <div class="d-flex justify-content-between align-items-center">
                <h6 class="mb-0">
                  <i class="bi bi-funnel me-2"></i>Bộ lọc dữ liệu
                </h6>
                <button class="btn btn-outline-secondary btn-sm" onclick="clearFilters()" title="Xóa tất cả bộ lọc">
                  <i class="bi bi-x-circle me-1"></i>Xóa bộ lọc
                </button>
              </div>
            </div>
            <div class="card-body">
              <div class="row g-3">
                <div class="col-md-3">
                  <label class="form-label fw-bold">
                    <i class="bi bi-calendar me-1"></i>Từ ngày:
                  </label>
                  <input type="date" class="form-control" id="fromDateFilter" placeholder="Chọn ngày bắt đầu">
                </div>
                <div class="col-md-3">
                  <label class="form-label fw-bold">
                    <i class="bi bi-calendar me-1"></i>Đến ngày:
                  </label>
                  <input type="date" class="form-control" id="toDateFilter" placeholder="Chọn ngày kết thúc">
                </div>
                <!-- <div class="col-md-2">
                  <label class="form-label fw-bold">
                    <i class="bi bi-clock me-1"></i>Ca:
                  </label>
                  <select class="form-select" id="shiftFilter">
                    <option value="">Tất cả</option>
                    <option value="Ca 1">Ca 1</option>
                    <option value="Ca 2">Ca 2</option>
                    <option value="Ca 3">Ca 3</option>
                    <option value="Kíp 1">Kíp 1</option>
                    <option value="Kíp 2">Kíp 2</option>
                  </select>
                </div> -->
                <!-- <div class="col-md-2">
                  <label class="form-label fw-bold">
                    <i class="bi bi-gear me-1"></i>Máy:
                  </label>
                  <select class="form-select" id="machineFilter">
                    <option value="">Tất cả</option>
                    <option value="Xả 1">Xả 1</option>
                    <option value="Xả 2">Xả 2</option>
                    <option value="Xả 3">Xả 3</option>
                  </select>
                </div> -->
                <div class="col-md-5">
                  <label class="form-label fw-bold">
                    <i class="bi bi-search me-1"></i>Tìm kiếm:
                  </label>
                  <div class="input-group">
                    <input type="text" class="form-control" id="searchInput" placeholder="Tìm theo mã lệnh, sản phẩm, máy, thợ...">
                    <button class="btn btn-primary" type="button" onclick="applyFilters()">
                      <i class="bi bi-search"></i>
                    </button>
                  </div>
                  <!-- <small class="text-muted">Tự động tìm kiếm khi nhập (300ms delay)</small> -->
                </div>
              </div>
            </div>
          </div>
          
          <!-- Tabs Navigation -->
          <ul class="nav nav-tabs mb-3" id="machineTabs" role="tablist">
            <!-- Dynamic tabs will be generated here -->
          </ul>
          
          <!-- Tab Content -->
          <div class="tab-content" id="machineTabContent">
            <!-- Dynamic tab content will be generated here -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // === CẤU HÌNH CÔNG ĐOẠN HIỆN TẠI ===
    const $stage_now = 'xen'; // Thay đổi giá trị này để chuyển sang công đoạn khác: xa, xen, in_offset, boi, be, dan, kho
    
    // === CẤU HÌNH STAGE TỰ ĐỘNG ===
    const STAGE_CONFIGS = {
        xa: { KEY: 'xa', NAME: 'XẢ', DISPLAY: 'XẢ GIẤY CUỘN' },
        xen: { KEY: 'xen', NAME: 'XÉN', DISPLAY: 'XÉN GIẤY' },
        in_offset: { KEY: 'in_offset', NAME: 'IN OFFSET', DISPLAY: 'IN OFFSET' },
        boi: { KEY: 'boi', NAME: 'BỒI', DISPLAY: 'BỒI GIẤY' },
        be: { KEY: 'be', NAME: 'BẾ', DISPLAY: 'BẾ GIẤY' },
        dan: { KEY: 'dan', NAME: 'DÁN', DISPLAY: 'DÁN GIẤY' },
        kho: { KEY: 'kho', NAME: 'KHO', DISPLAY: 'KHO THÀNH PHẨM' }
    };
    
    const STAGE_CONFIG = STAGE_CONFIGS[$stage_now];
    
    // === HELPER FUNCTIONS FOR DYNAMIC FIELD NAMES ===
    function getFieldName(field) {
        return `${STAGE_CONFIG.KEY}_${field}`;
    }
    
    function getOrderField(order, field) {
        const fieldName = getFieldName(field);
        return order[fieldName] || order[field] || 0;
    }
    
    function setOrderField(order, field, value) {
        const fieldName = getFieldName(field);
        order[fieldName] = value;
    }
    
    /**
     * =================================================================
     * ${STAGE_CONFIG.NAME} STAGE MANAGEMENT - QUẢN LÝ CÔNG ĐOẠN ${STAGE_CONFIG.NAME}
     * =================================================================
     * Chức năng chính:
     * 1. Hiển thị danh sách lệnh sản xuất ở công đoạn ${STAGE_CONFIG.NAME}
     * 2. Hoàn thành công đoạn ${STAGE_CONFIG.NAME} (cập nhật số lượng OK, NG)
     * 3. Bàn giao sang công đoạn tiếp theo theo workflow_definition
     */

    // === CẤU HÌNH API & WEBHOOK ===
    const API_BASE_URL = 'https://api.autoslp.com/api';
    const WEBHOOK_BASE_URL = 'https://api.autoslp.com:5678/webhook';

    // === BIẾN GLOBAL ===
    let ordersData = [];        // Dữ liệu lệnh sản xuất
    let currentEditingOrder = null;  // Đơn hàng đang chỉnh sửa
    let machineStatusData = []; // Dữ liệu trạng thái máy

    /**
     * =================================================================
     * MACHINE STATUS FUNCTIONS - HÀM QUẢN LÝ TRẠNG THÁI MÁY
     * =================================================================
     */

    /**
     * Tải dữ liệu trạng thái máy từ API
     */
    async function loadMachineStatus() {
        try {
            const response = await fetch(`${API_BASE_URL}/data/production_machines`);
            if (response.ok) {
                machineStatusData = await response.json();
            } else {
                console.error('❌ Lỗi khi tải dữ liệu máy:', response.status);
                machineStatusData = [];
            }
        } catch (error) {
            console.error('❌ Lỗi khi tải dữ liệu máy:', error);
            machineStatusData = [];
        }
    }

    /**
     * Kiểm tra xem máy có đang sản xuất lệnh nào không
     * @param {string} machineName - Tên máy
     * @returns {object|null} - Thông tin lệnh đang sản xuất hoặc null
     */
    function getMachineCurrentOrder(machineName) {
        if (!machineStatusData || machineStatusData.length === 0) {
            return null;
        }
        
        const machine = machineStatusData.find(m => m.machine_name === machineName);
        return machine && machine.current_order_id ? machine : null;
    }

    /**
     * Kiểm tra xem máy cụ thể có đang chạy lệnh không
     * @param {string} machineName - Tên máy cần kiểm tra
     * @returns {object} - { isRunning: boolean, runningOrder: object|null }
     */
    function checkMachineStatus(machineName) {
        const machine = machineStatusData.find(m => m.machine_name === machineName);
        
        if (!machine) {
            return { isRunning: false, runningOrder: null };
        }
        
        const isRunning = !!(machine.current_order_id && machine.current_order_id !== null);
        
        return {
            isRunning: isRunning,
            runningOrder: isRunning ? machine : null
        };
    }

    /**
     * Kiểm tra xem lệnh có thuộc máy nào không
     * @param {object} order - Lệnh sản xuất
     * @returns {string|null} - Tên máy hoặc null
     */
    function getOrderMachine(order) {
        const assignedMachine = order.assigned_machine || '';
        
        // Lọc các máy thuộc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Tìm máy ${STAGE_CONFIG.NAME} trong danh sách máy được gán
        for (const MStageMachine of MStageMachines) {
            if (assignedMachine.includes(MStageMachine.machine_name)) {
                return MStageMachine.machine_name;
            }
        }
        
        return null;
    }



    /**
     * Kiểm tra xem lệnh có đang chạy không
     * @param {object} order - Lệnh sản xuất
     * @returns {object} - { isRunning: boolean, reason: string }
     */
    function isOrderRunning(order) {
        // Kiểm tra xem có máy nào đang sản xuất lệnh này không
        const machineWithThisOrder = machineStatusData.find(machine => 
            machine.current_order_id == order.id
        );

        // Nếu lệnh này đang được sản xuất bởi một máy nào đó
        if (machineWithThisOrder) {
            return { isRunning: true, reason: `Lệnh hiện tại của máy ${machineWithThisOrder.machine_name}` };
        }

        // Nếu không có máy nào đang sản xuất lệnh này
        return { isRunning: false, reason: 'Lệnh không đang được sản xuất' };
    }

    /**
     * =================================================================
     * ENHANCED API FUNCTIONS - API CẢI TIẾN
     * =================================================================
     */

    /**
     * Fetch với timeout và retry
     */
    async function fetchWithTimeout(url, options = {}, timeout = 10000) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);

        try {
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            clearTimeout(timeoutId);
            return response;
        } catch (error) {
            clearTimeout(timeoutId);
            throw error;
        }
    }

    /**
     * Fetch với retry logic
     */
    async function fetchWithRetry(url, options = {}, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const timeout = attempt === 1 ? 10000 : 3000;
                const response = await fetchWithTimeout(url, options, timeout);
                
                if (response.ok) {
                    return response;
                }
                
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                
            } catch (error) {
                lastError = error;
                
                if (attempt < maxRetries) {
                    const delay = Math.min(1000 * attempt, 2000);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        throw lastError;
    }


    /**
     * Cache key cho filter ngày
     */
    const DATE_FILTER_CACHE_KEY = `date_filter_${STAGE_CONFIG.KEY}`;
    
    /**
     * Lưu giá trị filter ngày vào cache
     */
    function saveDateFilterToCache() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (fromDateInput && toDateInput) {
            const cacheData = {
                fromDate: fromDateInput.value,
                toDate: toDateInput.value,
                timestamp: Date.now()
            };
            localStorage.setItem(DATE_FILTER_CACHE_KEY, JSON.stringify(cacheData));
        }
    }
    
    /**
     * Khôi phục giá trị filter ngày từ cache
     */
    function loadDateFilterFromCache() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (!fromDateInput || !toDateInput) return false;
        
        try {
            const cachedData = localStorage.getItem(DATE_FILTER_CACHE_KEY);
            if (cachedData) {
                const data = JSON.parse(cachedData);
                
                // Kiểm tra cache có hợp lệ không (không quá 7 ngày)
                const cacheAge = Date.now() - data.timestamp;
                const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 ngày
                
                if (cacheAge < maxAge && data.fromDate && data.toDate) {
                    fromDateInput.value = data.fromDate;
                    toDateInput.value = data.toDate;
                    return true;
                }
            }
        } catch (error) {
            console.error('Lỗi khi load cache filter ngày:', error);
        }
        
        return false;
    }
    
    /**
     * Set giá trị mặc định cho filter ngày
     */
    function setDefaultDateFilter() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (fromDateInput && toDateInput) {
            // Thử load từ cache trước
            const cacheLoaded = loadDateFilterFromCache();
            
            // Nếu không có cache, set giá trị mặc định
            if (!cacheLoaded) {
                const today = new Date();
                const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
                
                fromDateInput.value = oneWeekAgo.toISOString().split('T')[0];
                toDateInput.value = today.toISOString().split('T')[0];
            }
        }
    }
    
    /**
     * Reset filter ngày về giá trị mặc định và xóa cache
     */
    function resetDateFilter() {
        const fromDateInput = document.getElementById('fromDateFilter');
        const toDateInput = document.getElementById('toDateFilter');
        
        if (fromDateInput && toDateInput) {
            // Xóa cache
            localStorage.removeItem(DATE_FILTER_CACHE_KEY);
            
            // Set giá trị mặc định
            const today = new Date();
            const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
            
            fromDateInput.value = oneWeekAgo.toISOString().split('T')[0];
            toDateInput.value = today.toISOString().split('T')[0];
            
            // Reload dữ liệu
            refreshData();
            
            showNotification('Đã reset filter ngày về mặc định', 'info');
        }
    }

    /**
     * Tải dữ liệu với filter ngày cụ thể
     */
    async function loadDataWithDateFilter() {
        const fromDateFilter = document.getElementById('fromDateFilter')?.value;
        const toDateFilter = document.getElementById('toDateFilter')?.value;
        
        if (!fromDateFilter || !toDateFilter) {
            showNotification('Vui lòng chọn cả ngày bắt đầu và ngày kết thúc', 'warning');
            return;
        }
        
        if (fromDateFilter > toDateFilter) {
            showNotification('Ngày bắt đầu không thể lớn hơn ngày kết thúc', 'warning');
            return;
        }
        
        showLoading('Đang tải dữ liệu theo khoảng ngày...');
        await loadOrdersData();
        hideLoading();
        showNotification(`Đã tải dữ liệu từ ${fromDateFilter} đến ${toDateFilter}`, 'success');
    }

    /**
     * Tải dữ liệu lệnh sản xuất từ API
     */
    async function loadOrdersData() {
        const timingKey = 'loadOrdersData';
        try {
            // Load dữ liệu máy trước
            await loadMachineStatus();
            // Load dữ liệu theo ngày từ filter hoặc mặc định 30 ngày trước
            const fromDateFilter = document.getElementById('fromDateFilter')?.value;
            const toDateFilter = document.getElementById('toDateFilter')?.value;
            
            // Thêm event listener cho filter ngày
            const fromDateInput = document.getElementById('fromDateFilter');
            const toDateInput = document.getElementById('toDateFilter');
            if (fromDateInput && toDateInput) {
                // Set giá trị mặc định: từ 1 tuần trước đến hôm nay
                if (!fromDateInput.value && !toDateInput.value) {
                    const today = new Date();
                    const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
                    fromDateInput.value = oneWeekAgo.toISOString().split('T')[0];
                    toDateInput.value = today.toISOString().split('T')[0];
                }
                
                fromDateInput.addEventListener('change', () => {
                    // Lưu cache khi thay đổi ngày
                    saveDateFilterToCache();
                    
                    if (fromDateInput.value && toDateInput.value) {
                        refreshData(); // Reload dữ liệu khi có đủ cả 2 ngày
                    }
                });
                toDateInput.addEventListener('change', () => {
                    // Lưu cache khi thay đổi ngày
                    saveDateFilterToCache();
                    
                    if (fromDateInput.value && toDateInput.value) {
                        refreshData(); // Reload dữ liệu khi có đủ cả 2 ngày
                    }
                });
            }
            
            let fromDate, toDate;
            if (fromDateFilter && toDateFilter) {
                // Sử dụng ngày từ filter
                fromDate = fromDateFilter;
                toDate = toDateFilter;
            } else {
                // Mặc định 1 tuần trước đến hiện tại
                const today = new Date();
                const oneWeekAgo = new Date(today.getTime() - (7 * 24 * 60 * 60 * 1000));
                fromDate = oneWeekAgo.toISOString().split('T')[0];
                toDate = today.toISOString().split('T')[0];
            }
            
            // Sử dụng date range thay vì limit để tránh quá tải
            const url = `${API_BASE_URL}/data/production_orders?stage=${STAGE_CONFIG.KEY}&from_date=${fromDate}&to_date=${toDate}`;
            
            // Gọi API để lấy tất cả dữ liệu
            const response = await fetchWithRetry(url, {}, 3);
            const apiData = await response.json();
            
            // Kiểm tra dữ liệu raw từ API
            if (apiData.length > 0) {
                // Log các mẫu để kiểm tra start_time
                apiData.slice(0, 3).forEach((record, idx) => {
                    // Sample data logging removed
                });
                
                // Đếm số bản ghi có start_time
                const recordsWithStartTime = apiData.filter(r => getOrderField(r, 'start_time')).length;
            }
            
            const allData = Array.isArray(apiData) ? apiData : [];
            ordersData = transformApiData(allData);
            
            // Kiểm tra dữ liệu sau khi transform và lọc
            if (ordersData.length > 0) {
                // Log các mẫu để kiểm tra start_time
                ordersData.slice(0, 3).forEach((record, idx) => {
                    // Sample transformed data logging removed
                });
                
                // Đếm số bản ghi có start_time
                const recordsWithStartTime = ordersData.filter(r => getOrderField(r, 'start_time')).length;
            }
            
            // Lưu dữ liệu gốc cho filtering
            originalOrdersData = [...ordersData];
            filteredOrdersData = [...ordersData];
            
            // Log sample data để debug
            if (ordersData.length > 0) {
                // Sample orders data logging removed
            }
        } catch (error) {
            ordersData = [];
            showNotification('Không thể tải dữ liệu: ' + error.message, 'error');
        }
    }

    /**
     * Transform API data
     */
    function transformApiData(apiData) {
        if (!Array.isArray(apiData)) {
            return [];
        }

        const transformedData = [];
        
        for (let i = 0; i < apiData.length; i++) {
            transformedData[i] = transformOrder(apiData[i]);
        }
        
        return transformedData;
    }

    /**
     * Transform một order
     */
    function transformOrder(order) {
        let workflowDef = order.workflow_definition;
        
        // Log dữ liệu thô từ API để debug
        
        if (getOrderField(order, 'start_time')) {
            // API Data logging removed
        }
        
        const nextStage = getNextStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY);
        
        // Tạo đối tượng kết quả
        const transformedOrder = {
            id: order.id || order.order_id || order.production_order_id,
            production_order: order.order_code || order.production_order,
            order_type: order.order_type || '', // Thêm trường loại LSX
            product_name: order.product_name,
            internal_product_code: order.internal_product_code,
            customer_name: order.customer_name,
            total_quantity: order.quantity || order.total_quantity,
            deployed_quantity: order.deployed_quantity || 0, // Thêm deployed_quantity
            sheet_count: order.sheet_count || 0, // Thêm sheet_count
            [getFieldName('input_quantity')]: order.quantity || order.total_quantity || 0,
            [getFieldName('output_quantity')]: getOrderField(order, 'output_quantity'),
            [getFieldName('good_quantity')]: getOrderField(order, 'good_quantity'),
            [getFieldName('ng_quantity')]: getOrderField(order, 'ng_quantity'),
            [getFieldName('handover_quantity')]: getOrderField(order, 'handover_quantity'),
            [getFieldName('status')]: getOrderField(order, 'status') || 'waiting',
            [getFieldName('machine_name')]: getOrderField(order, 'machine_name'),
            [getFieldName('worker_name')]: getOrderField(order, 'worker_name'),
            [getFieldName('note')]: getOrderField(order, 'note') || order.notes || '',
            [getFieldName('start_time')]: getOrderField(order, 'start_time'),
            [getFieldName('end_time')]: getOrderField(order, 'end_time'),
            paper_type: order.paper_type || '',
            paper_weight: order.paper_weight || 0,
            paper_length: order.paper_length  || 0,
            paper_width: order.paper_width  || 0,
            blank_count: order.blank_count|| 0, // Số phôi
            [getFieldName('shift')]: getOrderField(order, 'shift'),
            delivery_date: order.delivery_date,
            deployment_date: order.deployment_date || order.created_at,
            assigned_machine: order.assigned_machine || '', // Thêm trường assigned_machine
            workflow_definition: workflowDef,
            next_stage: nextStage,
            previous_stage: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY),
            
            // Dữ liệu từ stage trước
            previous_stage_good_quantity: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_good_quantity`] || 0) : 0,
            previous_stage_ng_quantity: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_ng_quantity`] || 0) : 0,
            previous_stage_handover_quantity: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_handover_quantity`] || 0) : 0,
            previous_stage_status: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_status`] || 'waiting') : null,
            previous_stage_worker_name: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_worker_name`] || '') : '',
            previous_stage_machine_name: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_machine_name`] || '') : '',
            previous_stage_start_time: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_start_time`] || null) : null,
            previous_stage_end_time: getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY) ? (order[`${getPreviousStageFromWorkflow(workflowDef, STAGE_CONFIG.KEY)}_end_time`] || null) : null,
            
            // Dữ liệu từ stage tiếp theo
            next_stage_good_quantity: nextStage ? (order[`${nextStage}_good_quantity`] || 0) : 0,
            next_stage_ng_quantity: nextStage ? (order[`${nextStage}_ng_quantity`] || 0) : 0,
            next_stage_handover_quantity: nextStage ? (order[`${nextStage}_handover_quantity`] || 0) : 0,
            next_stage_status: nextStage ? (order[`${nextStage}_status`] || 'waiting') : null,
            next_stage_worker_name: nextStage ? (order[`${nextStage}_worker_name`] || '') : '',
            next_stage_machine_name: nextStage ? (order[`${nextStage}_machine_name`] || '') : '',
            next_stage_start_time: nextStage ? (order[`${nextStage}_start_time`] || null) : null,
            next_stage_end_time: nextStage ? (order[`${nextStage}_end_time`] || null) : null,
            
            created_at: order.created_at,
            updated_at: order.updated_at
        };
        
        // Log dữ liệu sau khi transform để debug
        if (transformedOrder[getFieldName('start_time')]) {
            // Transformed data logging removed
        }
        
        return transformedOrder;
    }

    /**
     * =================================================================
     * WORKFLOW FUNCTIONS - HÀM XỬ LÝ WORKFLOW
     * =================================================================
     */

    /**
     * Lấy stage tiếp theo từ workflow definition
     * @param {string} workflowDef - Workflow definition (VD: "xa,xen,in" hoặc "xa,in_offset")
     * @param {string} currentStage - Stage hiện tại
     * @returns {string|null} Stage tiếp theo hoặc null nếu là stage cuối
     */
    function getNextStageFromWorkflow(workflowDef, currentStage) {
        if (!workflowDef) {
            return null;
        }
        
        const stages = workflowDef.split(',').map(s => s.trim());
        const currentIndex = stages.indexOf(currentStage);
        
        if (currentIndex === -1 || currentIndex >= stages.length - 1) {
            return null; // Không tìm thấy hoặc đã là stage cuối
        }
        
        const nextStage = stages[currentIndex + 1];
        return nextStage;
    }

    /**
     * Lấy stage trước đó từ workflow
     * @param {string} workflowDef - Định nghĩa workflow
     * @param {string} currentStage - Stage hiện tại
     * @returns {string|null} Stage trước đó hoặc null nếu là stage đầu
     */
    function getPreviousStageFromWorkflow(workflowDef, currentStage) {
        if (!workflowDef) {
            return null;
        }
        
        const stages = workflowDef.split(',').map(s => s.trim());
        const currentIndex = stages.indexOf(currentStage);
        
        if (currentIndex === -1 || currentIndex <= 0) {
            return null; // Không tìm thấy hoặc đã là stage đầu
        }
        
        const previousStage = stages[currentIndex - 1];
        return previousStage;
    }

    /**
     * Lấy tên hiển thị của stage
     * @param {string} stageKey - Key của stage
     * @returns {string} Tên hiển thị
     */
    function getStageDisplayName(stageKey) {
        const stageNames = {
            'xa': 'Xả',
            'xen': 'Xén', 
            'in_offset': 'In Offset',
            'boi': 'Bồi',
            'be': 'Bế',
            'dan': 'Dán',
            'kho': 'Kho'
        };
        
        return stageNames[stageKey] || stageKey.toUpperCase();
    }

    /**
     * Lấy màu sắc theo stage
     * @param {string} stageKey - Key của stage
     * @returns {string} CSS class màu sắc
     */
    function getStageColor(stageKey) {
        const stageColors = {
            'xa': 'primary',
            'xen': 'success',
            'in_offset': 'purple',
            'boi': 'warning',
            'be': 'danger',
            'dan': 'dark',
            'kho': 'secondary'
        };
        
        return stageColors[stageKey] || 'secondary';
    }

        

    /**
     * =================================================================
     * KHỞI TẠO TRANG - PAGE INITIALIZATION
     * =================================================================
     */
    
    // Khởi tạo khi trang được load
    document.addEventListener('DOMContentLoaded', function() {
        initializePage();
    });
    /**
     * Khởi tạo trang - load dữ liệu và setup UI
     */
    async function initializePage() {

        
        try {
            showLoading('Đang tải dữ liệu...');
            
            // Set giá trị mặc định cho filter ngày
            setDefaultDateFilter();
            
            // Tải dữ liệu từ API
            await loadOrdersData();
            await loadMachineStatus();
            
            // Khởi tạo tabs trước khi render
            await initializeTabs();
            
            // Cập nhật filter options sau khi có dữ liệu máy
            updateMachineFilterOptions();
            
            // Render giao diện
            renderOrdersTable();
            updateStatistics();
            
            // Khởi tạo filters
            setupFilterChangeListeners();
            setupSearchDebounce();
            
            // Khởi tạo summary section
            updateSummary();
            
            // Cập nhật hiển thị tổng số lượng đã nhập
            setTimeout(() => {
                updateTotalQuantityDisplay();
            }, 100);
            
            // Log tổng thời gian
            // logTotalLoadTime();
            
            // showNotification('Đã tải dữ liệu thành công', 'success');
            
        } catch (error) {
            showNotification('Lỗi tải dữ liệu: ' + error.message, 'error');
            
   
            
            renderOrdersTable();
            updateStatistics();
        } finally {
            hideLoading();
        }
    }

    

    /**
     * Render bảng danh sách lệnh sản xuất với tab structure
     */
    function renderOrdersTable() {
        // Kiểm tra có dữ liệu không
        if (ordersData.length === 0) {
            // Hiển thị thông báo trống cho tất cả các tab
            const emptyMessage = `
                <tr>
                    <td colspan="13" class="text-center text-muted py-4">
                        <i class="bi bi-inbox fs-1 mb-2 d-block"></i>
                        Không có lệnh sản xuất nào cho công đoạn ${STAGE_CONFIG.NAME}
                    </td>
                </tr>
            `;
            
            // Lấy tất cả các tab body đã được tạo động
            const tabBodies = document.querySelectorAll('[id$="TableBody"]');
            tabBodies.forEach(tbody => {
                tbody.innerHTML = emptyMessage;
            });
            
            // Cập nhật số lượng cho các tab
            updateTabCountsDynamic();
            return;
        }
        
        // Lọc các máy thuộc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Phân loại dữ liệu theo máy (hiển thị tất cả lệnh chưa bàn giao, kể cả chưa sẵn sàng)
        const machineOrders = {};
        MStageMachines.forEach(machine => {
            const machineName = machine.machine_name;
            machineOrders[machineName] = ordersData.filter(order => {
                const assignedMachine = order.assigned_machine || '';
                const inputQuantity = getInputQuantityFromPreviousStage(order);
                
                // Tính tổng số lượng bàn giao và input
                const previousStageHandover = order.previous_stage_handover_quantity || 0;
                const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
                const currentStageInput = getOrderField(order, 'input_quantity') || 0;
                
 
                
                return assignedMachine.includes(machineName);
            });
        });
        
        // Render từng tab máy
        MStageMachines.forEach(machine => {
            const machineName = machine.machine_name;
            const machineId = `machine-${machineName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            const tableBodyId = `${machineId}TableBody`;
            renderTabTable(tableBodyId, machineOrders[machineName] || []);
        });
        
        // Render tab "Tất cả" (hiển thị tất cả lệnh, kể cả đã hoàn thành)
        const activeOrders = ordersData.filter(order => {
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // Tính tổng số lượng bàn giao và input
            const previousStageHandover = order.previous_stage_handover_quantity || 0;
            const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
            const currentStageInput = getOrderField(order, 'input_quantity') || 0;
            

            
            return true; // Hiển thị tất cả lệnh
        });
        renderTabTable('allTableBody', activeOrders);
        
        // Cập nhật số lượng cho các tab
        updateTabCountsDynamic(machineOrders);
        
        // Load dữ liệu báo cáo
        loadReportData();
    }
    

    
    /**
     * Render bảng cho một tab cụ thể
     */
    function renderTabTable(tableBodyId, orders) {
        const tableBody = document.getElementById(tableBodyId);
        if (!tableBody) {
            console.error(`Table body not found: ${tableBodyId}`);
            return;
        }
        
        // Xóa dữ liệu cũ
        tableBody.innerHTML = '';
        
        // Kiểm tra có dữ liệu không
        if (orders.length === 0) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="13" class="text-center text-muted py-4">
                        <i class="bi bi-inbox fs-1 mb-2 d-block"></i>
                        Không có lệnh sản xuất nào
                    </td>
                </tr>
            `;
            return;
        }

        // Sắp xếp orders: lệnh sẵn sàng lên đầu, sau đó lệnh bị disable, cuối cùng theo thời gian bắt đầu
        const sortedOrders = [...orders].sort((a, b) => {
            // Kiểm tra lệnh nào đang chạy
            const aIsRunning = isOrderRunning(a).isRunning;
            const bIsRunning = isOrderRunning(b).isRunning;
            
            // Kiểm tra lệnh nào sẵn sàng (không bị disable)
            const aIsReady = isPreviousStageReady(a) && getOrderMachine(a);
            const bIsReady = isPreviousStageReady(b) && getOrderMachine(b);
            
            // Ưu tiên 1: Lệnh đang chạy
            if (aIsRunning && !bIsRunning) return -1;
            if (!aIsRunning && bIsRunning) return 1;
            
            // Ưu tiên 2: Lệnh sẵn sàng (không bị disable) lên đầu
            if (aIsReady && !bIsReady) return -1;
            if (!aIsReady && bIsReady) return 1;
            
            // Ưu tiên 3: Nếu cả hai đều sẵn sàng hoặc đều không sẵn sàng, sắp xếp theo thời gian bắt đầu
            const aStartTime = getOrderField(a, 'start_time') ? new Date(getOrderField(a, 'start_time')).getTime() : 0;
            const bStartTime = getOrderField(b, 'start_time') ? new Date(getOrderField(b, 'start_time')).getTime() : 0;
            
            // Lệnh bắt đầu sớm hơn lên đầu (thời gian lớn hơn = mới hơn)
            return bStartTime - aStartTime;
        });

        
        const fragment = document.createDocumentFragment();
        
        sortedOrders.forEach((order, index) => {
            try {
                const row = createOrderTableRow(order, index);
                fragment.appendChild(row);
            } catch (error) {
                console.error(`Error creating row for order ${order.id}:`, error);
                // Create a simple error row
                const errorRow = document.createElement('tr');
                errorRow.innerHTML = `
                    <td colspan="13" class="text-center text-danger">
                        Lỗi hiển thị lệnh ${order.id || 'N/A'}
                    </td>
                `;
                fragment.appendChild(errorRow);
            }
        });
        
        tableBody.appendChild(fragment);
    }
    
    /**
     * Cập nhật số lượng hiển thị trên các tab động
     */
    function updateTabCountsDynamic(machineOrders = {}) {
        // Lọc các máy thuộc Stage hiện tại
        const stageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Cập nhật số lượng cho từng máy
        stageMachines.forEach(machine => {
            const machineName = machine.machine_name;
            const machineId = `machine-${machineName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            const countElement = document.getElementById(`${machineId}-count`);
            if (countElement) {
                const orderCount = machineOrders[machineName] ? machineOrders[machineName].length : 0;
                countElement.textContent = orderCount;
            }
        });
        
        // Cập nhật số lượng cho tab "Tất cả" (chỉ lệnh chưa bàn giao)
        const allCountElement = document.getElementById('all-count');
        if (allCountElement) {
            const activeOrders = ordersData.filter(order => {
                const inputQuantity = getInputQuantityFromPreviousStage(order);
                return inputQuantity > 0;
            });
            allCountElement.textContent = activeOrders.length;
        }
        
        // Cập nhật số lượng cho tab "Báo cáo"
        const handedOverOrders = ordersData.filter(order => {
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // Tính tổng số lượng bàn giao và input
            const previousStageHandover = order.previous_stage_handover_quantity || 0;
            const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
            const currentStageInput = getOrderField(order, 'input_quantity') || 0;

            
            return inputQuantity <= 0 && previousStageHandover > 0;
        });
        updateReportCount(handedOverOrders.length);
    }


    /**
     * Khởi tạo tab functionality
     */
    async function initializeTabs() {
        // Tải dữ liệu máy từ API
        await loadMachineStatus();
        
        // Tạo các tab động dựa trên dữ liệu máy
        await createDynamicTabs();
        
        // Thêm event listeners cho các tab
        const tabs = document.querySelectorAll('#machineTabs .nav-link');
        tabs.forEach(tab => {
            tab.addEventListener('click', function(e) {
                // Cập nhật active state
                tabs.forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // Hiển thị tab content tương ứng
                const targetId = this.getAttribute('data-bs-target');
                const targetContent = document.querySelector(targetId);
                
                if (targetContent) {
                    document.querySelectorAll('.tab-pane').forEach(pane => {
                        pane.classList.remove('show', 'active');
                    });
                    targetContent.classList.add('show', 'active');
                }
                
                // Nếu click vào tab báo cáo, load dữ liệu báo cáo
                if (targetId === '#report-content') {
                    loadReportData();
                }
                
                // Cập nhật URL hash để bookmark
                window.location.hash = targetId.replace('#', '');
            });
        });
        
        // Khôi phục tab từ URL hash nếu có
        const hash = window.location.hash;
        if (hash) {
            const targetTab = document.querySelector(`[data-bs-target="${hash}"]`);
            if (targetTab) {
                // Xóa active class từ tất cả tabs và content
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                    link.setAttribute('aria-selected', 'false');
                });
                document.querySelectorAll('.tab-pane').forEach(pane => {
                    pane.classList.remove('show', 'active');
                });
                
                // Kích hoạt tab được chỉ định
                targetTab.classList.add('active');
                targetTab.setAttribute('aria-selected', 'true');
                
                const targetContent = document.querySelector(hash);
                if (targetContent) {
                    targetContent.classList.add('show', 'active');
                }
            }
        }
    }
    
    /**
     * Tạo các tab động dựa trên dữ liệu máy từ production_machines
     */
    async function createDynamicTabs() {
        const machineTabsContainer = document.getElementById('machineTabs');
        const tabContentContainer = document.getElementById('machineTabContent');
        

        
        // Lưu tab "Báo cáo" nếu có
        const reportTab = machineTabsContainer.querySelector('#report-tab');
        const reportContent = tabContentContainer.querySelector('#report-content');
        
        // Xóa nội dung cũ (nhưng giữ lại tab "Báo cáo")
        machineTabsContainer.innerHTML = '';
        tabContentContainer.innerHTML = '';
        
        // Lọc các máy thuộc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        

        
        // Tạo tab cho từng máy ${STAGE_CONFIG.NAME}
        MStageMachines.forEach((machine, index) => {
            const machineName = machine.machine_name;
            // Tạo ID an toàn cho CSS selector (không bắt đầu bằng số)
            const machineId = `machine-${machineName.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            const tabId = `${machineId}-tab`;
            const contentId = `${machineId}-content`;
            
            // Tạo tab navigation
            const tabItem = document.createElement('li');
            tabItem.className = 'nav-item';
            tabItem.setAttribute('role', 'presentation');
            
            const isFirstTab = index === 0;
            tabItem.innerHTML = `
                <button class="nav-link ${isFirstTab ? 'active' : ''}" id="${tabId}" 
                        data-bs-toggle="tab" data-bs-target="#${contentId}" 
                        type="button" role="tab" aria-controls="${contentId}" 
                        aria-selected="${isFirstTab}">
                    <i class="bi bi-gear me-1"></i>${machineName}
                    <!-- <span class="badge bg-primary ms-1" id="${machineId}-count">0</span> -->
                </button>
            `;
            
            machineTabsContainer.appendChild(tabItem);
            
            // Tạo tab content
            const tabPane = document.createElement('div');
            tabPane.className = `tab-pane fade ${isFirstTab ? 'show active' : ''}`;
            tabPane.id = contentId;
            tabPane.setAttribute('role', 'tabpanel');
            tabPane.setAttribute('aria-labelledby', tabId);
            
            tabPane.innerHTML = `
                <div class="table-container">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th style="width: 40px!important; min-width: 40px!important;" class="text-center">#</th>
                                <th style="width: 150px!important; min-width: 120px!important;" class="text-center">Lệnh SX</th>
                                <th style="width: 70px!important; min-width: 50px!important;" class="text-center">Loại LSX</th>
                                <th style="width: 260px!important; min-width: 150px!important;" class="text-center">Sản phẩm</th>
                                <th style="width: 130px!important; min-width: 130px!important;" class="text-center">Loại giấy</th>
                                <th style="width: 90px!important; min-width: 90px!important;" class="text-center">Định lượng</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">Kế hoạch</th>
                                <th style="width: 150px!important; min-width: 150px!important;" class="text-center">Triển khai</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT xả</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT xả</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">Số phôi</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Tiến độ</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Máy/Thợ</th>
                            </tr>
                        </thead>
                        <tbody id="${machineId}TableBody">
                        </tbody>
                    </table>
                </div>
            `;
            
            tabContentContainer.appendChild(tabPane);
        });
        
        // Thêm tab "Tất cả" ở cuối
        const allTabItem = document.createElement('li');
        allTabItem.className = 'nav-item';
        allTabItem.setAttribute('role', 'presentation');
        
        // Nếu không có máy nào, "Tất cả" tab sẽ là active mặc định
        const isAllTabActive = MStageMachines.length === 0;
        
        allTabItem.innerHTML = `
            <button class="nav-link ${isAllTabActive ? 'active' : ''}" id="all-tab" 
                    data-bs-toggle="tab" data-bs-target="#all-content" 
                    type="button" role="tab" aria-controls="all-content" 
                    aria-selected="${isAllTabActive}">
                <i class="bi bi-list-ul me-1"></i>Tất cả
                <span class="badge bg-secondary ms-1" id="all-count">0</span>
            </button>
        `;
        
        machineTabsContainer.appendChild(allTabItem);
        
        // Thêm content cho tab "Tất cả"
        const allTabPane = document.createElement('div');
        allTabPane.className = `tab-pane fade ${isAllTabActive ? 'show active' : ''}`;
        allTabPane.id = 'all-content';
        allTabPane.setAttribute('role', 'tabpanel');
        allTabPane.setAttribute('aria-labelledby', 'all-tab');
        
        allTabPane.innerHTML = `
            <div class="table-container">
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            <th style="width: 40px!important; min-width: 40px!important;" class="text-center">#</th>
                            <th style="width: 150px!important; min-width: 120px!important;" class="text-center">Lệnh SX</th>
                            <th style="width: 70px!important; min-width: 50px!important;" class="text-center">Loại LSX</th>
                            <th style="width: 260px!important; min-width: 150px!important;" class="text-center">Sản phẩm</th>
                            <th style="width: 130px!important; min-width: 130px!important;" class="text-center">Loại giấy</th>
                            <th style="width: 90px!important; min-width: 90px!important;" class="text-center">Định lượng</th>
                            <th style="width: 100px!important; min-width: 100px!important;" class="text-center">Kế hoạch</th>
                            <th style="width: 150px!important; min-width: 150px!important;" class="text-center">Triển khai</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT ${STAGE_CONFIG.KEY}</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT ${STAGE_CONFIG.KEY}</th>
                            <th style="width: 100px!important; min-width: 100px!important;" class="text-center">Số phôi</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Tiến độ</th>
                            <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Máy/Thợ</th>
                        </tr>
                    </thead>
                    <tbody id="allTableBody">
                    </tbody>
                </table>
            </div>
        `;
        
        tabContentContainer.appendChild(allTabPane);
        
        // Thêm lại tab "Báo cáo" nếu có
        if (reportTab) {
            machineTabsContainer.appendChild(reportTab);
        } else {
            // Tạo tab "Báo cáo" nếu chưa có
            const reportTabItem = document.createElement('li');
            reportTabItem.className = 'nav-item';
            reportTabItem.setAttribute('role', 'presentation');
            
            reportTabItem.innerHTML = `
                <button class="nav-link" id="report-tab" 
                        data-bs-toggle="tab" data-bs-target="#report-content" 
                        type="button" role="tab" aria-controls="report-content" 
                        aria-selected="false">
                    <i class="bi bi-file-earmark-text me-1"></i>Báo cáo
                    <span class="badge bg-info ms-1" id="report-count">0</span>
                </button>
            `;
            
            machineTabsContainer.appendChild(reportTabItem);
        }
        
        if (reportContent) {
            tabContentContainer.appendChild(reportContent);
        } else {
            // Tạo content cho tab "Báo cáo" nếu chưa có
            const reportTabPane = document.createElement('div');
            reportTabPane.className = 'tab-pane fade';
            reportTabPane.id = 'report-content';
            reportTabPane.setAttribute('role', 'tabpanel');
            reportTabPane.setAttribute('aria-labelledby', 'report-tab');
            
            reportTabPane.innerHTML = `
                <div class="table-container">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th style="width: 40px!important; min-width: 40px!important;" class="text-center">#</th>
                                <th style="width: 150px!important; min-width: 120px!important;" class="text-center">Lệnh SX</th>
                                <th style="width: 70px!important; min-width: 50px!important;" class="text-center">Loại LSX</th>
                                <th style="width: 260px!important; min-width: 150px!important;" class="text-center">Sản phẩm</th>
                                <th style="width: 130px!important; min-width: 130px!important;" class="text-center">Loại giấy</th>
                                <th style="width: 90px!important; min-width: 90px!important;" class="text-center">Định lượng</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">Kế hoạch</th>
                                <th style="width: 150px!important; min-width: 150px!important;" class="text-center">Triển khai</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT xả</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">KT xả</th>
                                <th style="width: 100px!important; min-width: 100px!important;" class="text-center">Số phôi</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Tiến độ</th>
                                <th style="width: 120px!important; min-width: 120px!important;" class="text-center">Máy/Thợ</th>
                            </tr>
                        </thead>
                        <tbody id="reportTableBody">
                        </tbody>
                    </table>
                </div>
            `;
            
            tabContentContainer.appendChild(reportTabPane);
        }
        
        // Load dữ liệu báo cáo ngay khi tạo tab
        loadReportData();
    }

    /**
     * Lọc dữ liệu theo tab hiện tại
     */
    function filterDataByCurrentTab() {
        const activeTab = document.querySelector('#machineTabs .nav-link.active');
        if (!activeTab) return ordersData;
        
        const tabId = activeTab.id;
        
        // Nếu là tab "Tất cả"
        if (tabId === 'all-tab') {
            return ordersData;
        }
        
        // Lấy tên máy từ tab ID
        const machineName = tabId.replace('-tab', '').replace(/-/g, ' ');
        
        // Lọc theo máy được gán
        return ordersData.filter(order => {
            const assignedMachine = order.assigned_machine || '';
            return assignedMachine.includes(machineName);
        });
    }
    
    /**
     * Cập nhật hiển thị tab dựa trên filter máy
     */
    function updateTabBasedOnMachineFilter() {
        const machineFilter = document.getElementById('machineFilter');
        if (!machineFilter) {
            return;
        }
        if (!machineFilter.value) return;
        
        const machineValue = machineFilter.value;
        let targetTabId = 'all-tab';
        
        // Lọc các máy thuộc Stage_${STAGE_CONFIG.KEY}
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Kiểm tra máy được chọn và chuyển đến tab tương ứng
        for (const machine of MStageMachines) {
            if (machineValue.includes(machine.machine_name)) {
                const machineId = `machine-${machine.machine_name.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                targetTabId = `${machineId}-tab`;
                break;
            }
        }
        
        const targetTab = document.getElementById(targetTabId);
        if (targetTab) {
            targetTab.click();
        }
    }
    
    /**
     * Lấy danh sách tất cả máy của stage hiện tại có sẵn
     * @returns {Array} - Mảng các máy của stage hiện tại
     */
    function getAvailableStageMachines() {
        if (!machineStatusData || machineStatusData.length === 0) {
            return [];
        }
        
        return machineStatusData.filter(machine => 
            machine.stage_machine && 
            machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`) &&
            machine.machine_name
        ).map(machine => machine.machine_name);
    }

    /**
     * Lấy số lượng từ stage trước đó cho bất kỳ stage nào
     * @param {object} order - Lệnh sản xuất
     * @param {string} currentStage - Stage hiện tại (mặc định: STAGE_CONFIG.KEY)
     * @returns {number} - Số lượng từ stage trước
     */
    function getInputQuantityFromPreviousStage(order, currentStage = STAGE_CONFIG.KEY) {
        if (!order || !order.workflow_definition) {
            return 0;
        }

        // Sử dụng function getPreviousStageFromWorkflow để lấy stage trước
        const previousStage = getPreviousStageFromWorkflow(order.workflow_definition, currentStage);
        
        if (!previousStage) {
            // Stage hiện tại là stage đầu tiên hoặc không tìm thấy
            // Ưu tiên sheet_count, fallback về quantity
            return order.sheet_count || order.quantity || 0;
        }

        // Sử dụng dữ liệu đã được transform sẵn từ previous_stage_handover_quantity
        if (order.previous_stage_handover_quantity && order.previous_stage_handover_quantity > 0) {
            return order.previous_stage_handover_quantity;
        }
        
        if (order.previous_stage_good_quantity && order.previous_stage_good_quantity > 0) {
            return order.previous_stage_good_quantity;
        }

        // Fallback về cách cũ nếu dữ liệu transform chưa có
        const handoverField = `${previousStage}_handover_quantity`;
        const goodField = `${previousStage}_good_quantity`;
        
        // Lấy số lượng từ stage trước
        const handoverQty = order[handoverField] || 0;
        const goodQty = order[goodField] || 0;
        
        // Ưu tiên handover_quantity, fallback về good_quantity
        return handoverQty > 0 ? handoverQty : goodQty;
    }

    /**
     * Lấy tên máy từ trường assigned_machine cho công đoạn hiện tại
     */
    function getStageMachineFromAssigned(assignedMachine) {
        if (!assignedMachine) return '';
        
        const machines = assignedMachine.split(',').map(m => m.trim());
        
        // Lọc các máy thuộc Stage hiện tại
        const stageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Tìm máy của stage hiện tại trong danh sách máy được gán
        for (const stageMachine of stageMachines) {
            if (machines.some(machine => machine.includes(stageMachine.machine_name))) {
                return stageMachine.machine_name;
            }
        }
        
        return '';
    }
    
    /**
     * Kiểm tra xem assigned_machine có chứa máy của stage hiện tại không
     */
    function hasStageMachine(assignedMachine) {
        if (!assignedMachine) return false;
        
        const machines = assignedMachine.split(',').map(m => m.trim());
        
        // Lọc các máy thuộc Stage hiện tại
        const stageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        );
        
        // Kiểm tra xem có máy của stage hiện tại nào trong danh sách máy được gán
        return stageMachines.some(stageMachine => 
            machines.some(machine => machine.includes(stageMachine.machine_name))
        );
    }
    
    /**
     * Kiểm tra xem stage trước đã hoàn thành và sẵn sàng cho stage hiện tại chưa
     * @param {object} order - Lệnh sản xuất
     * @returns {boolean} - true nếu stage trước đã hoàn thành hoặc không có stage trước
     */
    function isPreviousStageReady(order) {
        if (!order.previous_stage) {
            return true; // Không có stage trước = sẵn sàng
        }
        
        const previousStageStatus = order.previous_stage_status;
        const currentStageStatus = getOrderField(order, 'status');
        
        // Nếu stage trước chưa hoàn thành và stage hiện tại chưa bắt đầu
        if (previousStageStatus && 
            previousStageStatus !== 'completed' && 
            previousStageStatus !== 'handed_over' && 
            currentStageStatus === 'waiting') {
            return false; // Stage trước chưa sẵn sàng
        }
        
        return true; // Stage trước đã sẵn sàng
    }
    /**
     * Tạo một dòng trong bảng cho một lệnh sản xuất
     */
    function createOrderTableRow(order, index) {
        const row = document.createElement('tr');
        row.className = 'order-row';
        row.setAttribute('data-order-id', order.id);
        
        // Tính toán trạng thái và tiến độ
        const status = getOrderField(order, 'status') || 'waiting';
        
        // Lấy máy được gán cho lệnh này
        const orderMachine = getOrderMachine(order);
        
        let isDisabled = false;
        let displayReason = '';
        
        // Kiểm tra stage trước đã sẵn sàng chưa
        const isPreviousReady = isPreviousStageReady(order);
        
        if (!orderMachine) {
            // Lệnh không được gán cho máy nào → bị mờ
            isDisabled = true;
            displayReason = `Lệnh không được gán cho máy ${STAGE_CONFIG.NAME}`;
        } else {
            // Kiểm tra số lượng cần sản xuất
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            if (inputQuantity <= 0) {
                // Không có số lượng từ stage trước → bị mờ
                isDisabled = true;
                const previousStage = order.previous_stage;
                const previousStageName = previousStage ? getStageDisplayName(previousStage) : 'Công đoạn trước';
                displayReason = `Chờ ${previousStageName} cung cấp số lượng`;
            } else {
                // Kiểm tra trạng thái máy được gán
                const machineStatus = checkMachineStatus(orderMachine);
                
                if (!machineStatus.isRunning) {
                    // Máy đang trống → có thể bắt đầu
                    isDisabled = false;
                    displayReason = `Máy ${orderMachine} đang trống`;
                } else {
                    // Máy đang chạy
                    if (machineStatus.runningOrder && machineStatus.runningOrder.current_order_id == order.id) {
                        // Máy đang chạy chính lệnh này → hiển thị bình thường
                        isDisabled = false;
                        displayReason = `Lệnh hiện tại của máy ${orderMachine}`;
                    } else {
                        // Máy đang chạy lệnh khác → bị mờ
                        isDisabled = true;
                        displayReason = `Máy ${orderMachine} đang sản xuất lệnh ${machineStatus.runningOrder ? machineStatus.runningOrder.current_order_code : 'N/A'}`;
                    }
                }
            }
        }
        
        // Thêm class tương ứng với trạng thái
        if (isDisabled) {
            row.classList.add('disabled-order');
        } else {
            // Kiểm tra xem lệnh có đang chạy không
            const orderRunningCheck = isOrderRunning(order);
            if (orderRunningCheck.isRunning) {
                // Lệnh đang chạy
                row.classList.add('running-order');
            }
        }
        const inputQty = getOrderField(order, 'input_quantity') || 0;
        const sheet_count = order.sheet_count || 0; // Sửa: lấy số tờ giấy
        const goodQty = getOrderField(order, 'good_quantity') || 0;
        const ngQty = getOrderField(order, 'ng_quantity') || 0;
        const deployedQty = order.deployed_quantity || 0;
        const progressPercent = inputQty > 0 ? Math.round((goodQty / inputQty) * 100) : 0;
        
        // Xác định icon và màu sắc theo trạng thái
        let statusIcon = 'bi-clock';
        let statusClass = 'text-warning';
        let statusText = 'Chờ xử lý';
        
        switch (status) {
            case 'in_progress':
                statusIcon = 'bi-play-circle';
                statusClass = 'text-primary';
                statusText = 'Đang xử lý';
                break;
            case 'completed':
                statusIcon = 'bi-check-circle';
                statusClass = 'text-success';
                statusText = 'Hoàn thành';
                break;
            case 'paused':
                statusIcon = 'bi-pause-circle';
                statusClass = 'text-warning';
                statusText = 'Tạm dừng';
                break;
            case 'handed_over':
                statusIcon = 'bi-arrow-right-circle';
                statusClass = 'text-info';
                statusText = 'Đã bàn giao';
                break;
        }
        
        // Tạo HTML cho dòng
        row.innerHTML = `
            <td class="text-center">
                <span class="badge bg-light text-dark">${index + 1}</span>
            </td>

            <td>
                <div class="d-flex align-items-center">
                    <i class="bi ${statusIcon} ${statusClass} me-2"></i>
                    <div>
                        <div class="fw-bold ${isDisabled ? 'text-muted' : ''}">${order.production_order}</div>
                        <small class="text-muted">${formatDate(order.deployment_date)} - ${getOrderField(order, 'shift')}</small>
                        <small class="${isDisabled ? 'text-danger' : 'text-success'} d-block">${displayReason}</small>
                    </div>
                </div>
            </td>
            
            <td class="text-center">
                <span class="fw-bold">${order.order_type || ''}</span>
            </td>
            <td>
                <div>
                    <div class="fw-bold">${order.internal_product_code}</div>
                    <small class="text-muted" title="${order.product_name}">${truncateText(order.product_name, 100)}</small>
                </div>
            </td>
            <td class="text-center">
                <span class="badge bg-secondary">${order.paper_type || 'N/A'}</span>
            </td>
            <td class="text-center">
                <span class="fw-bold">${order.paper_weight || 0} gsm</span>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(deployedQty)}</div>
                <small class="text-muted">pcs</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-primary">${formatNumber(sheet_count)}</div>
                <small class="text-muted">tờ giấy</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-success">${formatNumber(order.paper_length || 0)}</div>
                <small class="text-muted">chiều dài</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-danger">${formatNumber(order.paper_width || 0)}</div>
                <small class="text-muted">chiều rộng</small>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(order.blank_count || 0)}</div>
                <small class="text-muted">phôi</small>
            </td>
            <td class="text-center">
                <div class="progress" style="height: 20px;">
                    <div class="progress-bar ${progressPercent >= 100 ? 'bg-success' : 'bg-primary'}" 
                         style="width: ${Math.min(progressPercent, 100)}%">
                        ${progressPercent}%
                    </div>
                </div>
                <small class="text-muted">${statusText}</small>
            </td>
            <td class="text-center">
                <small class="text-muted d-block" title="${order.assigned_machine || 'Chưa gán'}">${truncateText(order.assigned_machine || 'Chưa gán', 15)}</small>
            </td>

        `;
        
        // Add data attribute for order ID
        row.setAttribute('data-order-id', order.id);
        
        // Cho phép click nếu lệnh không bị disable
        if (!isDisabled) {
            row.style.cursor = 'pointer';
            row.onclick = (e) => {
                // Ngăn chặn event bubbling để tránh đóng panel
                e.stopPropagation();
                showOrderDetails(order.id);
            };
        } else {
            row.style.cursor = 'not-allowed';
            row.onclick = (e) => {
                e.stopPropagation();
                showNotification(displayReason, 'warning');
            };
        }
        
        return row;
    }


    
    

 
    


    /**
     * Cập nhật thống kê tổng quan
     */
    function updateStatistics() {
        const totalOrders = ordersData.length;
        const totalPlan = ordersData.reduce((sum, order) => sum + (getOrderField(order, 'input_quantity') || 0), 0);
        const totalGood = ordersData.reduce((sum, order) => sum + (getOrderField(order, 'good_quantity') || 0), 0);
        const totalNg = ordersData.reduce((sum, order) => sum + (getOrderField(order, 'ng_quantity') || 0), 0);
        
        // Cập nhật các thẻ thống kê
        updateElementText('totalOrders', totalOrders);
        updateElementText('totalPlan', formatNumber(totalPlan));
        updateElementText('totalGood', formatNumber(totalGood));
        updateElementText('totalNg', formatNumber(totalNg));
    }

    /**
     * =================================================================
     * XỬ LÝ SỰ KIỆN - EVENT HANDLERS
     * =================================================================
     */


    /**
     * Setup event listeners cho wizard form
     */
    function setupWizardEventListeners() {
        // Event listeners cho các input trong wizard
        const wizardGoodQty = document.getElementById('wizardGoodQty');
        const wizardNgQty = document.getElementById('wizardNgQty');
        const wizardHandoverQty = document.getElementById('wizardHandoverQty');
        
        if (wizardGoodQty) {
            wizardGoodQty.addEventListener('input', function() {
                updateWizardHandoverQuantity();
                if (wizardCurrentStep === 3) updateWizardConfirmation();
            });
        }
        
        if (wizardNgQty) {
            wizardNgQty.addEventListener('input', function() {
                updateWizardHandoverQuantity();
                if (wizardCurrentStep === 3) updateWizardConfirmation();
            });
        }
        
        if (wizardHandoverQty) {
            wizardHandoverQty.addEventListener('input', function() {
                if (wizardCurrentStep === 3) updateWizardConfirmation();
            });
        }
    }

    /**
     * Làm mới dữ liệu
     */
    async function refreshData() {
        try {
            showLoading('Đang làm mới dữ liệu...');
            await loadOrdersData();
            renderOrdersTable();
            updateStatistics();
            // showNotification('Đã làm mới dữ liệu thành công', 'info');
        } catch (error) {

            showNotification('Lỗi làm mới dữ liệu: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }





    /**
     * Cập nhật số lượng bàn giao khi thay đổi số lượng OK
     */
    function updateHandoverQuantity() {
        const goodQty = getElementValue('completeGoodQty') || 0;
        setElementValue('handoverQty', goodQty);
    }
    
    /**
     * Alias cho updateHandoverQuantity (được gọi từ HTML)
     */
    function updateHandoverQty() {
        updateHandoverQuantity();
    }





    /**
     * =================================================================
     * WIZARD FUNCTIONS - CÁC HÀM XỬ LÝ WIZARD FORM
     * =================================================================
     */

    let wizardCurrentStep = 1;
    const wizardTotalSteps = 3;

    /**
     * Reset wizard về bước 1
     */
    function resetWizard() {
        wizardCurrentStep = 1;
        updateWizardStepDisplay();
    }

    /**
     * Cập nhật hiển thị bước wizard
     */
    function updateWizardStepDisplay() {
        // Update step indicators
        document.querySelectorAll('.step').forEach((step, index) => {
            const stepNum = index + 1;
            step.classList.remove('active', 'completed');
            
            if (stepNum < wizardCurrentStep) {
                step.classList.add('completed');
            } else if (stepNum === wizardCurrentStep) {
                step.classList.add('active');
            }
        });
        
        // Update step content
        document.querySelectorAll('.step-content').forEach((content, index) => {
            content.classList.remove('active');
            if (index + 1 === wizardCurrentStep) {
                content.classList.add('active');
            }
        });
        
        // Update buttons
        const prevBtn = document.getElementById('wizardPrevBtn');
        const nextBtn = document.getElementById('wizardNextBtn');
        const finishBtn = document.getElementById('wizardFinishBtn');
        
        prevBtn.style.display = wizardCurrentStep > 1 ? 'inline-block' : 'none';
        nextBtn.style.display = wizardCurrentStep < wizardTotalSteps ? 'inline-block' : 'none';
        finishBtn.style.display = wizardCurrentStep === wizardTotalSteps ? 'inline-block' : 'none';
        
        // Update step indicator
        document.getElementById('wizardCurrentStep').textContent = wizardCurrentStep;
        
        // Update handover quantity in step 1
        if (wizardCurrentStep === 1) {
            updateWizardHandoverQuantity();
        }
        
        // Update confirmation data in step 3
        if (wizardCurrentStep === 3) {
            updateWizardConfirmation();
        }
    }

    /**
     * Chuyển đến bước tiếp theo
     */
    function wizardNextStep() {
        if (wizardCurrentStep < wizardTotalSteps) {
            // Validate current step
            if (!validateWizardCurrentStep()) {
                return;
            }
            
            wizardCurrentStep++;
            updateWizardStepDisplay();
        }
    }

    /**
     * Quay lại bước trước
     */
    function wizardPreviousStep() {
        if (wizardCurrentStep > 1) {
            wizardCurrentStep--;
            updateWizardStepDisplay();
        }
    }

    /**
     * Validate bước hiện tại
     */
    function validateWizardCurrentStep() {
        switch (wizardCurrentStep) {
            case 1:
                const goodQty = parseInt(getElementValue('wizardGoodQty')) || 0;
                const ngQty = parseInt(getElementValue('wizardNgQty')) || 0;
                if (goodQty + ngQty === 0) {
                    showNotification('Tổng số lượng phải lớn hơn 0', 'error');
                    return false;
                }
                break;
            case 2:
                const handoverQty = parseInt(getElementValue('wizardHandoverQty')) || 0;
                if (handoverQty <= 0) {
                    showNotification('Số lượng bàn giao phải lớn hơn 0', 'error');
                    return false;
                }
                break;
        }
        return true;
    }



    /**
     * Cập nhật số lượng bàn giao trong wizard
     */
    function updateWizardHandoverQuantity() {
        const goodQty = parseInt(getElementValue('wizardGoodQty')) || 0;
        setElementValue('wizardHandoverQty', goodQty);
    }

    /**
     * Cập nhật dữ liệu xác nhận trong wizard
     */
    function updateWizardConfirmation() {
        const goodQty = parseInt(getElementValue('wizardGoodQty')) || 0;
        const ngQty = parseInt(getElementValue('wizardNgQty')) || 0;
        const handoverQty = parseInt(getElementValue('wizardHandoverQty')) || 0;
        const total = goodQty + ngQty;
        const progress = total > 0 ? Math.round((goodQty / total) * 100) : 0;
        const machine = getElementValue('wizardMachine');
        const worker = getElementValue('wizardWorker');
        const shift = getElementValue('wizardShift');
        const handoverPerson = getElementValue('wizardHandoverPerson');
        const receiverPerson = getElementValue('wizardReceiverPerson');
        const handoverNotes = getElementValue('wizardHandoverNotes');
        
        // Update confirmation data
        updateElementText('confirmOrderCode', getElementValue('wizardOrderCode'));
        updateElementText('confirmProductCode', getElementValue('wizardProductCode'));
        updateElementText('confirmProductName', getElementValue('wizardProductName'));
        updateElementText('confirmPaperType', getElementValue('wizardPaperType'));
        updateElementText('confirmPaperWeight', getElementValue('wizardPaperWeight'));
        updateElementText('confirmQuantity', getElementValue('wizardQuantity'));
        updateElementText('confirmGoodQty', goodQty.toLocaleString());
        updateElementText('confirmNgQty', ngQty.toLocaleString());
        updateElementText('confirmProgress', progress + '%');
        updateElementText('confirmMachine', machine);
        updateElementText('confirmWorker', worker || 'Chưa nhập');
        updateElementText('confirmShift', shift || 'Ca 1');
        updateElementText('confirmHandoverQty', handoverQty.toLocaleString());
        updateElementText('confirmHandoverPerson', handoverPerson || 'Chưa nhập');
        updateElementText('confirmReceiverPerson', receiverPerson || 'Chưa nhập');
        updateElementText('confirmHandoverNotes', handoverNotes || 'Không có');
    }



    /**
     * =================================================================
     * UTILITY FUNCTIONS - CÁC HÀM TIỆN ÍCH
     * =================================================================
     */

    // Hiển thị loading
    function showLoading(message = 'Đang tải...') {
        const loading = document.getElementById('loadingOverlay');
        if (loading) {
            loading.style.display = 'flex';
            const loadingText = loading.querySelector('.loading-text');
            if (loadingText) loadingText.textContent = message;
        }
    }

    // Ẩn loading  
    function hideLoading() {
        const loading = document.getElementById('loadingOverlay');
        if (loading) loading.style.display = 'none';
    }

    // Hiển thị thông báo
    function showNotification(message, type = 'success') {
        // Tạo toast notification đơn giản
        const toast = document.createElement('div');
        toast.className = `alert alert-${type === 'error' ? 'danger' : type === 'warning' ? 'warning' : 'success'} position-fixed`;
        toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px; animation: fadeIn 0.3s ease;';
        toast.innerHTML = `
            <div class="d-flex align-items-center">
                <i class="bi bi-${type === 'error' ? 'exclamation-triangle' : type === 'warning' ? 'exclamation-triangle' : 'check-circle'} me-2"></i>
                <span>${message}</span>
                <button type="button" class="btn-close ms-auto" onclick="this.parentElement.parentElement.remove()"></button>
            </div>
        `;
        document.body.appendChild(toast);
        
        // Tự động xóa sau 5 giây
        setTimeout(() => {
            if (toast.parentElement) {
                toast.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }
        }, 5000);
    }

    // Hiển thị popup lỗi số lượng không khớp ở giữa màn hình
    function showQuantityMismatchPopup(message) {
        // Xóa popup cũ nếu có
        const existingPopup = document.getElementById('quantityMismatchPopup');
        if (existingPopup) {
            existingPopup.remove();
        }

        // Tạo popup modal
        const popup = document.createElement('div');
        popup.id = 'quantityMismatchPopup';
        popup.className = 'modal fade show';
        popup.style.cssText = 'display: block; z-index: 9999;';
        popup.innerHTML = `
            <div class="modal-dialog modal-lg modal-dialog-centered">
                <div class="modal-content border-danger">
                    <div class="modal-header bg-danger text-white">
                        <h5 class="modal-title">
                            <i class="bi bi-exclamation-triangle me-2"></i>
                            Lỗi Số Lượng Không Khớp
                        </h5>
                        <button type="button" class="btn-close btn-close-white" onclick="closeQuantityMismatchPopup()"></button>
                    </div>
                    <div class="modal-body">
                        <div class="alert alert-danger">
                            <pre style="white-space: pre-wrap; font-family: inherit; margin: 0;">${message}</pre>
                        </div>
                        <div class="text-center">
                            <p class="text-muted">
                                <i class="bi bi-info-circle me-1"></i>
                                Vui lòng kiểm tra và điều chỉnh số lượng nhập cho khớp với tổng số lượng trong kệ đã chọn.
                            </p>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" onclick="closeQuantityMismatchPopup()">
                            <i class="bi bi-x-circle me-1"></i>
                            Đóng
                        </button>
                        <button type="button" class="btn btn-primary" onclick="closeQuantityMismatchPopup()">
                            <i class="bi bi-check-circle me-1"></i>
                            Đã Hiểu
                        </button>
                    </div>
                </div>
            </div>
        `;

        // Thêm backdrop
        const backdrop = document.createElement('div');
        backdrop.className = 'modal-backdrop fade show';
        backdrop.id = 'quantityMismatchBackdrop';
        backdrop.style.cssText = 'z-index: 9998;';

        // Thêm vào body
        document.body.appendChild(backdrop);
        document.body.appendChild(popup);

        // Thêm CSS cho animation
        const style = document.createElement('style');
        style.textContent = `
            .modal.show {
                animation: fadeIn 0.3s ease;
            }
            .modal-backdrop.show {
                animation: fadeIn 0.3s ease;
            }
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
        `;
        document.head.appendChild(style);
    }

    // Đóng popup lỗi số lượng
    function closeQuantityMismatchPopup() {
        const popup = document.getElementById('quantityMismatchPopup');
        const backdrop = document.getElementById('quantityMismatchBackdrop');
        
        if (popup) {
            popup.style.animation = 'fadeOut 0.3s ease';
            setTimeout(() => popup.remove(), 0);
        }
        
        if (backdrop) {
            backdrop.style.animation = 'fadeOut 0.3s ease';
            setTimeout(() => backdrop.remove(), 0);
        }
    }

    // Format số theo định dạng Việt Nam
    function formatNumber(num) {
        if (!num && num !== 0) return '';
        return new Intl.NumberFormat('vi-VN').format(num);
    }

    // Format ngày
    function formatDate(date, format = 'dd/mm/yyyy') {
        if (!date) return '';
        const d = new Date(date);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = d.getFullYear();
        
        return format
            .replace('dd', day)
            .replace('mm', month)
            .replace('yyyy', year);
    }

    // Cập nhật text của element
    function updateElementText(elementId, text) {
        const element = document.getElementById(elementId);
        if (element) element.textContent = text;
    }

    // Set giá trị cho element
    function setElementValue(elementId, value) {
        const element = document.getElementById(elementId);
        if (element) {
            if (element.type === 'checkbox') {
                element.checked = value;
            } else {
                element.value = value;
            }
        }
    }

    // Lấy giá trị từ element
    function getElementValue(elementId) {
        const element = document.getElementById(elementId);
        if (!element) return '';
        
        if (element.type === 'checkbox') {
            return element.checked;
        } else {
            return element.value;
        }
    }

    // Cắt ngắn text
    function truncateText(text, maxLength) {
        if (!text) return '';
        return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
    }

    // Chuyển đổi status thành text
    function getStatusText(status) {
        const statusMap = {
            'waiting': 'Chờ xử lý',
            'in_progress': 'Đang xử lý', 
            'completed': 'Hoàn thành',
            'paused': 'Tạm dừng',
            'handed_over': 'Đã bàn giao'
        };
        return statusMap[status] || 'Không xác định';
    }

    /**
     * =================================================================
     * SIDEBAR TOGGLE - ĐIỀU KHIỂN SIDEBAR
     * =================================================================
     * Đã được chuyển sang sidebar-generator.js
     */
    /**
     * =================================================================
     * DETAILS PANEL - PANEL CHI TIẾT
     * =================================================================
     */

    function showOrderDetails(orderId) {
        // Tìm order trong cả ordersData và originalOrdersData
        let order = ordersData.find(o => o.id == orderId); // Sử dụng == để so sánh loose
        
        if (!order) {
            order = originalOrdersData.find(o => o.id == orderId);
        }
        
        if (!order) {

            
            // Thử tìm bằng production_order nếu orderId có thể là production_order
            const orderByProductionOrder = ordersData.find(o => o.production_order == orderId);
            if (orderByProductionOrder) {
                order = orderByProductionOrder;
            } else {
                const orderByProductionOrderOriginal = originalOrdersData.find(o => o.production_order == orderId);
                if (orderByProductionOrderOriginal) {
                    order = orderByProductionOrderOriginal;
                } else {
                    return;
                }
            }
        }

        // Update current editing order
        currentEditingOrder = order;
        
        // Kiểm tra shift hiện tại để lấy start_time từ bảng production_orders_shift
        checkCurrentShiftStatus();
        
        // Chi tiết log để debug thông tin thời gian

        // Cập nhật mã lệnh trong tiêu đề
        const orderCodeBadge = document.getElementById('detailOrderCode');
        if (orderCodeBadge) {
            orderCodeBadge.textContent = order.production_order || `#${order.id}`;
        }

        // Add logging to debug start time

        // Remove previous selection
        const previousSelected = document.querySelector('.table tbody tr.selected');
        if (previousSelected) {
            previousSelected.classList.remove('selected');
        }

        // Add selection to current row
        const currentRow = document.querySelector(`[data-order-id="${orderId}"]`);
        if (currentRow) {
            currentRow.classList.add('selected');
        }

        // Show details panel
        const detailsPanel = document.getElementById('detailsPanel');
        const contentArea = document.querySelector('.content-area');
        
        detailsPanel.classList.add('show');
        contentArea.classList.add('details-open');

        // Generate dynamic HTML content for the sidebar
        detailsPanel.innerHTML = generateSidebarHTML(order);
        
        // Initialize multi-select for workers
        initializeWorkerMultiSelect(order);
        
        // Initialize quantity OK table
        initializeQuantityOKTable();
        
        // Load dữ liệu kệ từ công đoạn hiện tại
        loadCurrentStageKeData(order);

        // Active tab "Số lượng" nếu đã có thời gian bắt đầu
        if (getOrderField(order, 'start_time')) {
            setTimeout(() => {
                const quantityTab = document.querySelector('.details-panel .tab-btn[onclick*="quantity"]');
                if (quantityTab) {
                    // Remove active class from all tabs
                    document.querySelectorAll('.details-panel .tab-btn').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.details-panel .tab-panel').forEach(panel => panel.classList.remove('active'));
                    
                    // Add active class to quantity tab
                    quantityTab.classList.add('active');
                    const quantityPanel = document.getElementById('quantity-panel');
                    if (quantityPanel) {
                        quantityPanel.classList.add('active');
                    }
                }
            }, 100);
        }

        // Bắt đầu timer nếu đã có thời gian bắt đầu và chưa kết thúc
        if (window.currentShiftStartTime && !getOrderField(order, 'end_time')) {
            setTimeout(() => {
                startProductionTimer();
            }, 100);
        } else if (window.currentShiftStartTime && getOrderField(order, 'end_time')) {
            // Nếu đã kết thúc, hiển thị thời gian cố định
            setTimeout(() => {
                const statusTimeElement = document.getElementById('statusTime');
                const runningTimeInfoElement = document.getElementById('runningTimeInfo');
                
                if (statusTimeElement) {
                    const fixedTime = calculateWorkTime(window.currentShiftStartTime, getOrderField(order, 'end_time'));
                    statusTimeElement.textContent = `Thời gian: ${fixedTime}`;
                }
                
                // Thời gian chạy trong tab thông tin đã được hiển thị đúng từ HTML generation
                // Không cần cập nhật vì đã có giá trị cố định từ calculateWorkTime
            }, 100);
        }

        // Thêm event listener để tự động cập nhật số lượng chuyển giao
        setTimeout(() => {
            const goodQtyInput = document.getElementById('goodQty');
            const handoverQtyInput = document.getElementById('handoverQty');
            
            if (goodQtyInput && handoverQtyInput) {
                goodQtyInput.addEventListener('input', function() {
                    const goodQty = parseInt(this.value) || 0;
                    handoverQtyInput.value = goodQty;
                    handleUpdateTotalQuantityDisplay(); // Sử dụng wrapper function
                    updateHandoverButtonValidationSync(); // Cập nhật validation nút bàn giao
                });
            }
            
            // Thêm event listeners cho validation real-time
            const quantityInputs = ['ngQty', 'ngStartEndQty', 'returnQty'];
            quantityInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', function() {
                        handleUpdateTotalQuantityDisplay(); // Sử dụng wrapper function
                        updateHandoverButtonValidationSync();
                    });
                    input.addEventListener('blur', function() {
                        handleUpdateTotalQuantityDisplay(); // Sử dụng wrapper function
                        updateHandoverButtonValidationSync();
                    });
                    input.addEventListener('input', updateStatisticsDisplay);
                    input.addEventListener('blur', updateStatisticsDisplay);
                }
            });
            
            // Khởi tạo hiển thị tổng số lượng và thống kê
            handleUpdateTotalQuantityDisplay(); // Sử dụng wrapper function
            updateStatisticsDisplay();
            updateSelectedRackQuantityDisplaySync();
            updateHandoverButtonValidationSync();
        }, 100);
        
        // Tự động đề xuất ca làm việc hiện tại
        const shiftSelect = document.getElementById('shift');
        if (shiftSelect) {
            const currentShift = getCurrentShift();
            shiftSelect.value = currentShift;
        }
        
        // Reset form để nhập dữ liệu mới (không load từ database)
        // resetProductionForm();
        
        // Load số lượng còn lại
        loadRemainingQuantity();
        
        // Kiểm tra trạng thái shift hiện tại
        checkCurrentShiftStatus();
        
        // Initialize display values
        initializeOrderDisplay();
    }

    /**
     * Tính số lượng cần sản xuất còn lại
     * = Số lượng từ công đoạn trước - (Tổng số lượng bàn giao + NG của các ca đã làm)
     */
    async function getRemainingQuantity(order) {
        try {
            // Lấy số lượng từ công đoạn trước
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // Lấy tổng số lượng bàn giao và NG của các ca đã làm
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            let totalHandoverQuantity = 0;
            let totalNgQuantity = 0;
            if (shiftsData.shifts && Array.isArray(shiftsData.shifts)) {
                shiftsData.shifts.forEach(shift => {
                    totalHandoverQuantity += (parseInt(shift.handover_quantity) || 0);
                    totalNgQuantity += (parseInt(shift.ng_quantity) || 0);
                });
            }
            
            // Số lượng còn lại = Input từ công đoạn trước - (Bàn giao + NG của các ca trước)
            const remainingQuantity = Math.max(0, inputQuantity - totalHandoverQuantity - totalNgQuantity);

            return remainingQuantity;
        } catch (error) {
            console.error('❌ Lỗi tính số lượng còn lại:', error);
            return getInputQuantityFromPreviousStage(order); // Fallback
        }
    }

    /**
     * Generate dynamic sidebar HTML for the order
     */
    function generateSidebarHTML(order) {
        const nextStage = order.next_stage;
        const nextStageName = nextStage ? getStageDisplayName(nextStage) : 'HOÀN THÀNH';
        
        // Get status info
        let statusBadgeStyle = '';
        let statusText = '';
        
        if (getOrderField(order, 'status') === 'in_progress') {
            statusBadgeStyle = 'background: linear-gradient(135deg, var(--primary-green), #20c997);';
            statusText = 'Đang sản xuất';
        } else if (getOrderField(order, 'status') === 'completed') {
            statusBadgeStyle = 'background: linear-gradient(135deg, var(--primary-blue), #0dcaf0);';
            statusText = 'Hoàn thành';
        } else if (getOrderField(order, 'status') === 'handed_over') {
            statusBadgeStyle = 'background: linear-gradient(135deg, var(--primary-orange), #fd7e14);';
            statusText = 'Đã bàn giao';
        } else {
            statusBadgeStyle = 'background: linear-gradient(135deg, #6c757d, #adb5bd);';
            statusText = 'Chưa bắt đầu';
        }

        // Calculate statistics - không sử dụng dữ liệu từ database
        const totalProduced = 0; // Sẽ được tính từ form nhập liệu
        const inputQuantity = getInputQuantityFromPreviousStage(order);
        const efficiency = 0; // Sẽ được tính từ form nhập liệu
        const ngRate = 0; // Sẽ được tính từ form nhập liệu

        return `
            <div class="sidebar-header">
                <h5><i class="bi bi-clipboard-data me-2"></i>Báo cáo lệnh: <strong>${order.production_order || `#${order.id}`}</strong></h5>
                <button type="button" class="detail-close" onclick="closeDetailsPanel()">
                    <i class="bi bi-x-lg"></i>
                </button>
            </div>

            <div class="sidebar-content">
                <!-- Tab Navigation -->
                <div class="tab-navigation">
                    <button class="tab-btn active" onclick="switchTab('info')">
                        <div class="tab-icon"><i class="bi bi-person-fill"></i></div>
                        <div>Thông tin</div>
                    </button>
                    <button class="tab-btn" onclick="switchTab('quantity')">
                        <div class="tab-icon"><i class="bi bi-calculator-fill"></i></div>
                        <div>Số lượng</div>
                    </button>
      
                    <button class="tab-btn" onclick="switchTab('shifts')">
                        <div class="tab-icon"><i class="bi bi-clock-history"></i></div>
                        <div>Thông tin ca</div>
                    </button>
                    
                    <button class="tab-btn" onclick="switchTab('notes')">
                        <div class="tab-icon"><i class="bi bi-chat-text-fill"></i></div>
                        <div>Ghi chú</div>
                    </button>
                </div>

                <!-- Tab Content -->
                <div class="tab-content">
                    <!-- Info Tab -->
                    <div id="info-panel" class="tab-panel active">
                        <div class="form-group">
                            <div class="multi-select-container">
                                <div class="multi-select-input" id="workerMultiSelect">
                                    <div class="selected-items" id="selectedWorkers"></div>
                                    <input type="text" class="multi-select-search" id="workerSearch" placeholder="Tìm kiếm thợ...">
                                </div>
                                <div class="multi-select-dropdown" id="workerDropdown" style="display: none;">
                                    <div class="dropdown-items" id="workerOptions">
                                        <!-- Options will be populated by JavaScript -->
                                    </div>
                                </div>
                            </div>
                            <label class="form-label">
                                <i class="bi bi-person-badge"></i>
                                Tên thợ phụ trách
                            </label>
                            <input type="hidden" id="worker" value="${getOrderField(order, 'worker_name') || ''}">
                        </div>

                        <div class="form-group">
                            <select class="form-control-custom" id="shift">
                                <option value="">Chọn ca làm việc</option>
                                <option value="Ca 1" ${getOrderField(order, 'shift') === 'Ca 1' ? 'selected' : ''}>Ca 1 (6:00 - 14:00)</option>
                                <option value="Ca 2" ${getOrderField(order, 'shift') === 'Ca 2' ? 'selected' : ''}>Ca 2 (14:00 - 22:00)</option>
                                <option value="Ca 3" ${getOrderField(order, 'shift') === 'Ca 3' ? 'selected' : ''}>Ca 3 (22:00 - 6:00)</option>
                                <option value="Kíp 1" ${getOrderField(order, 'shift') === 'Kíp 1' ? 'selected' : ''}>Kíp 1 (6:00 - 18:00)</option>
                                <option value="Kíp 2" ${getOrderField(order, 'shift') === 'Kíp 2' ? 'selected' : ''}>Kíp 2 (18:00 - 6:00)</option>
                            </select>
                            <label class="form-label">
                                <i class="bi bi-clock"></i>
                                Ca làm việc
                            </label>
                        </div>

                        <div style="display: none;" class="form-group">
                            <select class="form-control-custom" id="machine">
                                <option value="">Chọn máy sản xuất</option>
                                ${getAvailableStageMachines().map(machineName => {
                                    const isSelected = getStageMachineFromAssigned(order.assigned_machine) === machineName;
                                    return `<option value="${machineName}" ${isSelected ? 'selected' : ''}>${machineName}</option>`;
                                }).join('')}
                            </select>
                            <label class="form-label">
                                <i class="bi bi-gear-fill"></i>
                                Máy sản xuất
                            </label>
                        </div>

                        <div class="info-row">
                            <span class="info-label">Thời gian bắt đầu</span>
                            <span class="info-value" id="startTimeInfo">${window.currentShiftStartTime ? formatDateTime(window.currentShiftStartTime) : '--'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Thời gian kết thúc</span>
                            <span class="info-value" id="endTimeInfo">${getOrderField(order, 'end_time') ? formatDateTime(getOrderField(order, 'end_time')) : '--'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Thời gian chạy</span>
                            <span class="info-value" id="runningTimeInfo">${window.currentShiftStartTime ?
                                (getOrderField(order, 'end_time') ? calculateWorkTime(window.currentShiftStartTime, getOrderField(order, 'end_time')) : 'Đang tính...') : '--'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Trạng thái máy</span>
                            <span class="info-value">${getOrderField(order, 'status') === 'in_progress' ? 'Hoạt động tốt' : 'Chờ'}</span>
                        </div>
                        
                        <!-- Phần chọn kệ - Áp dụng từ demo-ke-sidebar.html -->
                        <div class="ke-selection-section" style="margin-top: 25px; padding-top: 25px; border-top: 2px solid #e9ecef;">
             
                            <!-- Bulk Controls -->
                            <div class="bulk-controls">
                                <div class="form-check-ke">
                                    <input class="form-check-input" type="checkbox" id="selectAllKe" onchange="toggleSelectAllKe(this)">
                                    <label class="form-check-label-ke" for="selectAllKe">Chọn tất cả kệ</label>
                                </div>
                            </div>
                            
                            <!-- Kệ Toggle Grid -->
                            <div class="ke-toggle-grid" id="keToggleGrid">
                                <!-- Kệ toggle items will be generated here -->
                            </div>
                            
                            <!-- Summary Section -->
                            <div class="summary-section" id="summarySection" style="display: none;">
                                <h6 class="summary-title">Tóm tắt thông tin</h6>
                                
                                <div class="summary-grid">
                                    <div class="summary-card">
                                        <div class="summary-value" id="totalKe">0</div>
                                        <div class="summary-label">Tổng số kệ</div>
                                    </div>
                                    <div class="summary-card">
                                        <div class="summary-value" id="selectedKe">0</div>
                                        <div class="summary-label">Kệ đã chọn</div>
                                    </div>
                                    <div class="summary-card">
                                        <div class="summary-value" id="totalQuantity">0</div>
                                        <div class="summary-label">Tổng số lượng</div>
                                    </div>
                                    <div class="summary-card">
                                        <div class="summary-value" id="completionRate">0%</div>
                                        <div class="summary-label">Hoàn thành</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Quantity Tab -->
                    <div id="quantity-panel" class="tab-panel">
                        <!-- Quantity OK Table -->
                        <div class="quantity-table mb-3">
                            <div class="table-header">
                                <h6><i class="bi bi-list-check me-2"></i>Bảng nhập theo kệ</h6>
                                <div class="table-actions">
                                    <button class="btn-add-row" onclick="addQuantityOKRow()">
                                        <i class="bi bi-plus-circle"></i>
                                        Thêm kệ
                                    </button>
                                </div>
                            </div>
                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th style="width: 50px;">#</th>
                                            <th style="width: 150px;">Kệ</th>
                                            <th style="width: 120px;">Số lượng</th>
                                            <th style="width: 100px;">Thao tác</th>
                                        </tr>
                                    </thead>
                                    <tbody id="quantityOKTableBody">
                                        <!-- Rows will be generated here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- Summary OK Quantity -->
                        <div class="quantity-grid mb-3">
                            <div class="quantity-card success">
                                <div class="quantity-label">Tổng số lượng OK</div>
                                <input type="number" class="quantity-input" id="goodQty" value="0" readonly>
                            </div>
                            <div class="quantity-card danger">
                                <div class="quantity-label">Số lượng NG</div>
                                <input type="number" class="quantity-input" id="ngQty" value="0">
                            </div>
                        </div>

                        <div class="quantity-grid mb-3">
                            <div class="quantity-card ">
                                <div class="quantity-label">NG đầu/cuối</div>
                                <input type="number" class="quantity-input" id="ngStartEndQty" value="0">
                            </div>
                            <div class="quantity-card ">
                                <div class="quantity-label">Số lượng trả</div>
                                <input type="number" class="quantity-input" id="returnQty" value="0">
                            </div>
                        </div>
<!--
                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-arrow-right-circle"></i>
                                Số lượng chuyển giao
                            </label>
                            <input type="number" class="form-control-custom" id="handoverQty" value="0" style="font-size: 1.1rem; font-weight: 600; color: var(--primary-blue);">
                            </div>

                                                    <div class="info-row" style="background: linear-gradient(135deg, #e3f2fd, #e3f2fd); border-radius: 8px; padding: 12px; margin: 10px 0; ">
                            <span class="info-label" style="font-weight: 600; color: #1976d2;">📥 Số lượng cần sản xuất</span>
                            <span class="info-value" id="remainingQuantityDisplay" style="font-weight: 700; font-size: 1.1rem; color: #1565c0;">Đang tính...</span>
                        </div>

                        -->
                       
                        <div class="info-row" style="background: linear-gradient(135deg, #e3f2fd, #e3f2fd); border-radius: 8px; padding: 12px; margin: 10px 0; ">
                            <span class="info-label" style="font-weight: 600; color: #1976d2;">📦 Tổng số lượng trong kệ đã chọn</span>
                            <span class="info-value" id="selectedRackQuantityDisplay" style="font-weight: 700; font-size: 1.1rem; color: #1565c0;">Đang tính...</span>
                        </div>



                        <div class="info-row" style="background: linear-gradient(135deg, #fff3cd, #fff3cd); border-radius: 8px; padding: 12px; margin: 10px 0; ">
                            <span class="info-label" style="font-weight: 600; color: #856404;">📊 Tổng số lượng đã nhập</span>
                            <span class="info-value" id="totalQuantityDisplay" style="font-weight: 700; font-size: 1.1rem; color: #856404;">0 / 0</span>
                        </div>
                        <!--
                        <div class="info-row">
                            <span class="info-label">Tổng sản xuất</span>
                            <span class="info-value" id="totalProducedValue">0 sản phẩm</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Hiệu suất</span>
                            <span class="info-value" id="efficiencyValue">0%</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Tỷ lệ NG</span>
                            <span class="info-value" id="ngRateValue">0%</span>
                        </div>
                        -->
                    </div>

                 

                    

                    <!-- Shifts Tab -->
                    <div id="shifts-panel" class="tab-panel">
                
                            <div class="shifts-header">
                                <h6><i class="bi bi-clock-history me-2"></i>Lịch sử ca làm việc</h6>
                                <div class="shifts-loading" id="shiftsLoading" style="display: none;">
                                    <div class="spinner-border spinner-border-sm" role="status">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                    <span class="ms-2">Đang tải...</span>
                                </div>
                            </div>
                            
                            <div class="shifts-list" id="shiftsList">
                                <!-- Shifts will be loaded here -->
                            </div>
                        </div>
                  
                </div>

                <!-- Notes Tab -->
                    <div id="notes-panel" class="tab-panel">
                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-journal-text"></i>
                                Ghi chú sản xuất
                            </label>
                            <div class="note-area">
                                <textarea class="note-textarea" id="note" placeholder="Nhập ghi chú về quá trình sản xuất...">${getOrderField(order, 'note') || ''}</textarea>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-lightbulb"></i>
                                Đề xuất cải tiến
                            </label>
                            <div class="note-area">
                                <textarea class="note-textarea" id="improvement" placeholder="Nhập đề xuất cải tiến...">${order.improvement_suggestions || ''}</textarea>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">
                                <i class="bi bi-tag"></i>
                                Tags
                            </label>
                            <input type="text" class="form-control-custom" id="tags" value="${order.tags || ''}" placeholder="Nhập các tag, cách nhau bởi dấu phẩy">
                        </div>
                    </div>

                <!-- Production Controls -->
                <div class="production-controls">
                    <!-- Production Status -->
                    <div class="production-status ${getOrderField(order, 'status') === 'in_progress' ? 'running' : 'stopped'}" id="productionStatus">
                        <div class="status-text">
                            <i class="bi bi-${getOrderField(order, 'status') === 'in_progress' ? 'play-circle-fill text-success' : 'stop-circle-fill text-danger'}"></i>
                            <span id="productionStatusText">${statusText}</span>
                        </div>
                        <div class="status-time" id="statusTime">Thời gian: </div>
                    </div>

                    <!-- Control Buttons -->
                    <div class="control-row">
                        <button class="btn-custom btn-success-custom" id="startBtn" onclick="startProduction()">
                            <i class="bi bi-play-fill"></i>
                            Bắt đầu
                        </button>
         
                        <button class="btn-custom btn-info-custom" id="handoverShiftBtn" onclick="handoverShift()" ${getOrderField(order, 'status') === 'not_started' || getOrderField(order, 'status') === 'handed_over' ? 'disabled' : ''} style="${getOrderField(order, 'start_time') && !getOrderField(order, 'end_time') ? 'display: flex;' : 'display: none;'}">
                            <i class="bi bi-clock-history"></i>
                            Bàn giao ca
                        </button>

                          <button class="btn-custom btn-secondary-custom" id="resetBtn" onclick="resetProduction()" style="${getOrderField(order, 'start_time') && getOrderField(order, 'status') === 'in_progress' ? 'display: flex;    max-width: 100px;' : 'display: none;'}">
                            <i class="bi bi-arrow-clockwise"></i>
                            Hủy làm
                        </button>
                    </div>

          
                </div>
            </div>
        `;
    }

    // Helper functions for form manipulation
    function setElementValue(id, value) {
        const element = document.getElementById(id);
        if (element) {
            element.value = value;
        }
    }

    function getElementValue(id) {
        const element = document.getElementById(id);
        if (!element) return '';
        
        // Xử lý đặc biệt cho select elements
        if (element.tagName === 'SELECT') {
            const selectedOption = element.options[element.selectedIndex];
            return selectedOption ? selectedOption.value : '';
        }
        
        // Xử lý cho input, textarea và các element khác
        return element.value || '';
    }

    /**
     * =================================================================
     * QUANTITY OK TABLE FUNCTIONS - HÀM XỬ LÝ BẢNG NHẬP SỐ LƯỢNG OK THEO KỆ
     * =================================================================
     */
    
    // Global variables for quantity OK table
    let quantityOKRowCounter = 0;
    let keRowBaseIndex = 0; // số kệ đã có từ dữ liệu đã lưu
    
    /**
     * Initialize quantity OK table when order details are shown
     */
    async function initializeQuantityOKTable() {
        quantityOKRowCounter = 0;
        
        const tableBody = document.getElementById('quantityOKTableBody');
        if (tableBody) {
            tableBody.innerHTML = '';
            await computeKeRowBaseIndex();
            // Thêm 3 dòng mặc định bắt đầu từ kệ tiếp theo
            // for (let i = 0; i < 3; i++) {
            //     addQuantityOKRow();
            // }
        }
        
        updateTotalOKQuantity();
    }

    async function computeKeRowBaseIndex() {
        keRowBaseIndex = 0;
        try {
            if (!currentEditingOrder) return;
            const resp = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/handover_json/${STAGE_CONFIG.KEY}`);
            if (!resp.ok) return;
            const data = await resp.json();
            let raw = data && data.data ? data.data : null;
            if (!raw) return;
            if (typeof raw === 'string') {
                try { raw = JSON.parse(raw); } catch (_) { return; }
            }
            const recordsKey = `${STAGE_CONFIG.KEY}_ke_records`;
            const idKey = `${STAGE_CONFIG.KEY}_ke_id`;
            const records = raw[recordsKey] || [];
            if (!Array.isArray(records) || records.length === 0) return;
            let maxIdx = 0;
            records.forEach(rec => {
                const val = rec[idKey] || '';
                const m = typeof val === 'string' ? val.match(/(\d+)/) : null;
                const num = m ? parseInt(m[1]) : 0;
                if (!isNaN(num)) maxIdx = Math.max(maxIdx, num);
            });
            keRowBaseIndex = maxIdx;
        } catch (e) {
            keRowBaseIndex = 0;
        }
    }
    
    /**
     * Add new row to quantity OK table
     */
    function addQuantityOKRow() {
        quantityOKRowCounter++;
        const tableBody = document.getElementById('quantityOKTableBody');
        
        if (!tableBody) return;
        
        // Calculate the actual row number (1-based index)
        const actualRowNumber = tableBody.children.length + 1;
        
        const row = document.createElement('tr');
        row.id = `quantity-ok-row-${quantityOKRowCounter}`;
        
        const keNumber = keRowBaseIndex + actualRowNumber;
        const keValue = `Kệ ${keNumber}`;
        const keId = `ke_${keNumber}`;
        
        row.innerHTML = `
            <td>${keNumber}</td>
            <td>${keValue}</td>
            <td style="display: none;">${keId}</td>
            <td>
                <input type="number" 
                       class="quantity-input ok" 
                       id="qty-ok-${quantityOKRowCounter}" 
                       placeholder="0" 
                       min="0" 
                       onchange="handleUpdateTotalOKQuantity()"
                       oninput="handleUpdateTotalOKQuantity()">
            </td>
            <td>
                <button class="btn-remove-row" onclick="handleRemoveQuantityOKRow(${quantityOKRowCounter})">
                    <i class="bi bi-trash"></i>
                </button>
            </td>
        `;
        
        tableBody.appendChild(row);
    }
    
    /**
     * Remove row from quantity OK table
     */
    async function removeQuantityOKRow(rowId) {
        const row = document.getElementById(`quantity-ok-row-${rowId}`);
        if (row) {
            row.remove();
            
            // Update row numbers and ke names after removal
            updateRowNumbers();
            
            await updateTotalOKQuantity();
        }
    }
    
    /**
     * Update row numbers and ke names after row removal
     */
    function updateRowNumbers() {
        const tableBody = document.getElementById('quantityOKTableBody');
        if (!tableBody) return;
        
        const rows = tableBody.querySelectorAll('tr');
        rows.forEach((row, index) => {
            const rowNumber = index + 1;
            const keNumber = keRowBaseIndex + rowNumber;
            const keName = `Kệ ${keNumber}`;
            
            // Update the first cell (row number)
            const firstCell = row.cells[0];
            if (firstCell) {
                firstCell.textContent = keNumber;
            }
            
            // Update the second cell (ke name)
            const secondCell = row.cells[1];
            if (secondCell) {
                secondCell.textContent = keName;
            }
        });
    }
    
    /**
     * Update total OK quantity from table
     */
    async function updateTotalOKQuantity() {
        let totalOK = 0;
        
        const rows = document.querySelectorAll('#quantityOKTableBody tr');
        rows.forEach(row => {
            const rowId = row.id.replace('quantity-ok-row-', '');
            const okValue = parseInt(document.getElementById(`qty-ok-${rowId}`)?.value) || 0;
            totalOK += okValue;
        });
        
        // Update the total OK input
        const goodQtyInput = document.getElementById('goodQty');
        if (goodQtyInput) {
            goodQtyInput.value = totalOK;
        }
        
        // Update handover quantity (default to OK quantity)
        const handoverQtyInput = document.getElementById('handoverQty');
        if (handoverQtyInput) {
            handoverQtyInput.value = totalOK;
        }
        
        // Update total quantity display with await
        await updateTotalQuantityDisplay();
    }
    
    /**
     * Collect quantity OK table data
     */
    function collectQuantityOKTableData() {
        const data = [];
        const rows = document.querySelectorAll('#quantityOKTableBody tr');
        
        rows.forEach((row, index) => {
            const rowId = row.id.replace('quantity-ok-row-', '');
            const okValue = parseInt(document.getElementById(`qty-ok-${rowId}`)?.value) || 0;
            const keValue = row.cells[1].textContent;
            const keId = row.cells[2].textContent; // Lấy ke_id từ cell ẩn
            
            if (okValue > 0) {
                data.push({
                    row_id: keId.replace('ke_', ''), // Lấy số từ ke_id
                    ke: keValue,
                    ok_quantity: okValue
                });
            }
        });
        
        return data;
    }

    /**
     * Xác định ca làm việc theo thời gian hiện tại
     */
    function getCurrentShift() {
        const now = new Date();
        const currentHour = now.getHours();
        
        // Kíp 1: từ 6:00 - 18:00 (6:00 đến 17:59)
        if (currentHour >= 6 && currentHour < 18) {
            return 'Kíp 1';
        }
        // Kíp 2: từ 18:00 - 6:00 (18:00 đến 5:59)
        else {
            return 'Kíp 2';
        }
    }

    /**
     * Initialize display values when order is selected
     */
    async function initializeOrderDisplay() {
        if (!currentEditingOrder) return;
        
        try {
            // Update displays that depend on async data
            await updateSelectedRackQuantityDisplay();
            await updateHandoverButtonValidation();
            
            // Update sync displays with await
            await updateTotalQuantityDisplay();
            updateStatisticsDisplay();
            

        } catch (error) {
            console.error('❌ Error initializing order display:', error);
        }
    }

    // Export the initialization function
    window.initializeOrderDisplay = initializeOrderDisplay;

    /**
     * Wrapper functions for async event handlers to be called from inline events
     */
    window.handleUpdateTotalOKQuantity = function() {
        updateTotalOKQuantity().catch(error => {
            console.error('❌ Error in updateTotalOKQuantity:', error);
        });
    };

    window.handleRemoveQuantityOKRow = function(rowId) {
        removeQuantityOKRow(rowId).catch(error => {
            console.error('❌ Error in removeQuantityOKRow:', error);
        });
    };

    window.handleUpdateTotalQuantityDisplay = function() {
        updateTotalQuantityDisplay().catch(error => {
            console.error('❌ Error in updateTotalQuantityDisplay:', error);
        });
    };

    /**
     * Attach event listeners to quantity input fields to auto-update total display
     */
    function attachQuantityEventListeners() {
        const quantityInputIds = ['ngQty', 'ngStartEndQty', 'returnQty'];
        
        quantityInputIds.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                // Remove existing listeners to prevent duplicates
                input.removeEventListener('input', handleUpdateTotalQuantityDisplay);
                input.removeEventListener('change', handleUpdateTotalQuantityDisplay);
                
                // Add new listeners
                input.addEventListener('input', handleUpdateTotalQuantityDisplay);
                input.addEventListener('change', handleUpdateTotalQuantityDisplay);
                

            }
        });
    }
    
    // Export the function to be called after order details are shown
    window.attachQuantityEventListeners = attachQuantityEventListeners;

    /**
     * Validate tổng số lượng không vượt quá số lượng đầu vào
     */
    async function validateTotalQuantity(order, goodQty, ngQty, ngStartEndQty = 0, returnQty = 0) {
        // Tính tổng số lượng đã nhập
        const totalEntered = goodQty + ngQty + ngStartEndQty + returnQty;
        
        // Lấy số lượng từ kệ đã chọn
        const selectedRackTotalQuantity = await getTotalQuantityInSelectedRacks();
        
        // Nếu không có kệ nào được chọn, sử dụng số lượng đầu vào từ stage trước
        let inputQuantity = selectedRackTotalQuantity;
        if (inputQuantity === 0) {
            inputQuantity = getInputQuantityFromPreviousStage(order);
        }
        
        // Kiểm tra tổng số lượng không vượt quá số lượng đầu vào
        if (totalEntered > inputQuantity) {
            const quantitySource = selectedRackTotalQuantity > 0 ? 'kệ đã chọn' : 'đầu vào';
            showNotification(`⚠️ Tổng số lượng (${totalEntered}) vượt quá số lượng ${quantitySource} (${inputQuantity})!\n\nChi tiết:\n• OK: ${goodQty}\n• NG: ${ngQty}\n• NG đầu/cuối: ${ngStartEndQty}\n• Trả: ${returnQty}\n• Tổng: ${totalEntered}\n• ${quantitySource}: ${inputQuantity}`, 'error');
            return false;
        }
        
        return true;
    }

    /**
     * Cập nhật hiển thị tổng số lượng và validation real-time
     */
    async function updateTotalQuantityDisplay() {
        if (!currentEditingOrder) return;
        
        // Get total OK from table
        const okTableData = collectQuantityOKTableData();
        const goodQty = okTableData.reduce((sum, row) => sum + row.ok_quantity, 0);
        const ngQty = parseInt(getElementValue('ngQty')) || 0;
        const ngStartEndQty = parseInt(getElementValue('ngStartEndQty')) || 0;
        const returnQty = parseInt(getElementValue('returnQty')) || 0;
        
        const totalEntered = goodQty + ngQty + ngStartEndQty + returnQty;
        
        // Debug: Kiểm tra trạng thái kệ được chọn trong UI
        const selectedKeItems = document.querySelectorAll('.ke-toggle-item.selected');
        
        
        
        
        // Lấy tổng số lượng trong kệ đã chọn từ getTotalQuantityInSelectedRacks
        const selectedRackQuantity = await getTotalQuantityInSelectedRacks();
        
        
        
        // Cập nhật hiển thị tổng số lượng
        const totalDisplay = document.getElementById('totalQuantityDisplay');
        if (totalDisplay) {
            totalDisplay.textContent = `${totalEntered} / ${selectedRackQuantity}`;
            
            // Thay đổi màu sắc dựa trên validation
            if (totalEntered > selectedRackQuantity) {
                totalDisplay.style.color = '#dc3545'; // Đỏ - Vượt quá
                totalDisplay.style.fontWeight = 'bold';
                totalDisplay.title = 'Tổng số lượng nhập vượt quá tổng số lượng trong kệ đã chọn!';
            } else if (totalEntered === selectedRackQuantity && selectedRackQuantity > 0) {
                totalDisplay.style.color = '#28a745'; // Xanh lá - Hoàn hảo
                totalDisplay.style.fontWeight = 'bold';
                totalDisplay.title = 'Số lượng nhập khớp với tổng số lượng trong kệ đã chọn';
            } else if (selectedRackQuantity === 0) {
                totalDisplay.style.color = '#ffc107'; // Vàng - Chưa có kệ
                totalDisplay.style.fontWeight = 'normal';
                totalDisplay.title = 'Chưa có kệ nào sẵn sàng để xử lý';
            } else {
                totalDisplay.style.color = '#6c757d'; // Xám - Bình thường
                totalDisplay.style.fontWeight = 'normal';
                totalDisplay.title = `Còn lại ${selectedRackQuantity - totalEntered} sản phẩm chưa nhập`;
            }
        }
        
        // Cập nhật trạng thái các input field
        const inputs = ['goodQty', 'ngQty', 'ngStartEndQty', 'returnQty'];
        inputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                if (totalEntered > selectedRackQuantity && selectedRackQuantity > 0) {
                    input.style.color = '#dc3545'; // Đỏ khi vượt quá
                    input.title = 'Số lượng vượt quá tổng số lượng trong kệ đã chọn';
                } else {
                    input.style.color = '';
                    input.title = '';
                }
            }
        });
    }

    /**
     * Lấy ID của kệ được chọn đầu tiên
     * @returns {string|null} - ID của kệ được chọn hoặc null nếu không có
     */
    function getSelectedKeIds() {
        // Tìm tất cả kệ được chọn trong UI
        const selectedKeItems = document.querySelectorAll('.ke-toggle-item.selected');
        
        if (selectedKeItems.length > 0) {
            // Trả về mảng tất cả ID kệ được chọn (format: ke-${number})
            const selectedKeIds = Array.from(selectedKeItems).map(item => item.id);
            return selectedKeIds;
        }
        
        return [];
    }

    /**
     * Lấy dữ liệu từ form trong sidebar
     * @returns {object} - Dữ liệu form đã được validate, bao gồm danh sách kệ được chọn
     */
    function getFormData() {
        // Collect data from OK table
        const okTableData = collectQuantityOKTableData();
        const totalOK = okTableData.reduce((sum, row) => sum + row.ok_quantity, 0);
        
        const formData = {
            worker: getElementValue('worker') || '',
            shift: getElementValue('shift') || '',
            machine: getElementValue('machine') || '',
            goodQty: totalOK,
            ngQty: parseInt(getElementValue('ngQty')) || 0,
            ngStartEndQty: parseInt(getElementValue('ngStartEndQty')) || 0,
            returnQty: parseInt(getElementValue('returnQty')) || 0,
            handoverQty: parseInt(getElementValue('handoverQty')) || totalOK,
            qualityRating: getElementValue('qualityRating') || '',
            qualityCheck: getElementValue('qualityCheck') || '',
            note: getElementValue('note') || '',
            improvement: getElementValue('improvement') || '',
            tags: getElementValue('tags') || '',
            okTableData: okTableData,
            selectedKeIds: getSelectedKeIds() // Thêm tất cả kệ được chọn
        };

        return formData;
    }

    function closeDetailsPanel() {
        const detailsPanel = document.getElementById('detailsPanel');
        const contentArea = document.querySelector('.content-area');
        
        detailsPanel.classList.remove('show');
        contentArea.classList.remove('details-open');
        
        // Dừng timer khi đóng panel
        stopProductionTimer();
        
        // Remove selection from table row
        const selectedRow = document.querySelector('.table tbody tr.selected');
        if (selectedRow) {
            selectedRow.classList.remove('selected');
        }
    }




    function getStatusBadgeClass(status) {
        const statusMap = {
            'waiting': 'bg-warning',
            'in_progress': 'bg-primary',
            'completed': 'bg-success',
            'paused': 'bg-secondary',
            'handed_over': 'bg-info'
        };
        return statusMap[status] || 'bg-secondary';
    }

    function formatDate(dateString) {
        if (!dateString) return 'N/A';
        try {
            const date = new Date(dateString);
            return date.toLocaleDateString('vi-VN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        } catch (e) {
            return 'N/A';
        }
    }

    /**
     * Get total quantity in selected racks from input_quantity_json for racks with status 'in_progress' only
     */
    async function getTotalQuantityInSelectedRacks() {
        if (!currentEditingOrder) { return 0; }
        try {
            // Nếu stage hiện tại là stage đầu tiên trong workflow,
            // hiển thị tổng số lượng theo sheet_count (hoặc quantity nếu thiếu sheet_count)
            const hasPreviousStage = !!getPreviousStageFromWorkflow(currentEditingOrder.workflow_definition, STAGE_CONFIG.KEY);
            if (!hasPreviousStage) {
                const firstStageTotal = (currentEditingOrder.sheet_count || currentEditingOrder.quantity || 0);
                return firstStageTotal;
            }
            
            
            // Load dữ liệu từ stage input thay vì từ UI
            const response = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/input_json/${STAGE_CONFIG.KEY}`);
            
            if (!response.ok) {
                
                return 0;
            }
            
            const data = await response.json();
            
            
            if (!data) {
                
                return 0;
            }
            
            // Xử lý trường hợp data.data là string JSON
            let processedData = data;
            if (data.data && typeof data.data === 'string') {
                try {
                    processedData = JSON.parse(data.data);
                    
                } catch (parseError) {
                    
                    return 0;
                }
            }
            
            // Tìm records key (có thể là xen_ke_records, xa_ke_records, etc.)
            const currentRecordsKey = `${STAGE_CONFIG.KEY}_ke_records`;
            let records = processedData[currentRecordsKey] || [];
            
            // Nếu không có records của stage hiện tại, tìm từ các stage khác
            if (records.length === 0) {
                const availableKeys = Object.keys(processedData).filter(key => key.endsWith('_ke_records'));
                if (availableKeys.length > 0) {
                    const fallbackKey = availableKeys[0];
                    records = processedData[fallbackKey] || [];
                    
                }
            }
            
            
            
            if (records.length === 0) {
                
                return 0;
            }
            
            // Xác định prefix để lấy dữ liệu
            let dataPrefix = STAGE_CONFIG.KEY;
            if (records.length > 0 && !records[0][`${STAGE_CONFIG.KEY}_ke_id`]) {
                const firstRecord = records[0];
                const availablePrefixes = Object.keys(firstRecord).filter(key => key.endsWith('_ke_id'));
                if (availablePrefixes.length > 0) {
                    dataPrefix = availablePrefixes[0].replace('_ke_id', '');
                    
                }
            }
            
            // Tính tổng số lượng chỉ từ các kệ có xen_status in_progress
            let totalQuantity = 0;
            records.forEach((record, index) => {
                // QUAN TRỌNG: Xét xen_status thay vì xa_status
                const xenStatus = record.xen_status || '';
                const quantity = parseInt(record[`${dataPrefix}_quantity`] || record.quantity || 0);
                
                
                
                if (xenStatus === 'in_progress') {
                    totalQuantity += quantity;
                    
                }
            });
            
            
            return totalQuantity;
            
        } catch (error) {
            console.error('❌ [getTotalQuantityInSelectedRacks] Lỗi:', error);
            return 0;
        }
    }

    /**
     * Update the display of total quantity in selected racks
     */
    async function updateSelectedRackQuantityDisplay() {
        
        
        const selectedRackDisplay = document.getElementById('selectedRackQuantityDisplay');
        if (!selectedRackDisplay) {
            
            return;
        }
        
        
        const totalQuantity = await getTotalQuantityInSelectedRacks();
        
        
        if (totalQuantity > 0) {
            selectedRackDisplay.textContent = totalQuantity.toLocaleString();
            selectedRackDisplay.style.color = '#1565c0';
            
            
        } else {
            selectedRackDisplay.textContent = 'Không có kệ sẵn sàng';
            selectedRackDisplay.style.color = '#9e9e9e';
            
        }
    }
    
    /**
     * Update handover button validation based on selected rack quantities
     * Button is always enabled, but validation is handled in handover process
     */
    async function updateHandoverButtonValidation() {
        const handoverBtn = document.getElementById('handoverShiftBtn');
        if (!handoverBtn) return;
        
        // Get current form data
        const goodQty = parseInt(getElementValue('goodQty')) || 0;
        const ngQty = parseInt(getElementValue('ngQty')) || 0;
        const ngStartEndQty = parseInt(getElementValue('ngStartEndQty')) || 0;
        const returnQty = parseInt(getElementValue('returnQty')) || 0;
        
        const totalEnteredQuantity = goodQty + ngQty + ngStartEndQty + returnQty;
        
        // Get total quantity in selected racks
        const selectedRackTotalQuantity = await getTotalQuantityInSelectedRacks();
        
        // Check validation status
        const isQuantityMatch = totalEnteredQuantity === selectedRackTotalQuantity;
        const hasSelectedRacks = selectedRackTotalQuantity > 0;
        
        // Always enable button - validation is handled during handover process
        handoverBtn.disabled = false;
        handoverBtn.title = '';
        
        // Log validation status for debugging
        if (hasSelectedRacks && selectedRackTotalQuantity > 0) {
            if (isQuantityMatch) {
                
            } else {
                
            }
        } else {
            
        }
    }
    /**
     * Tự động chọn các kệ có trạng thái 'in_progress' cho stage hiện tại
     */
    async function autoSelectInProgressRacks() {
        
        if (!currentEditingOrder) {
            
            return;
        }
        
        try {
            // Reset selection state before auto-selecting
            selectedKe = 0;
            keData = {};
            
            // Clear all selected classes first
            const allKeItems = document.querySelectorAll('.ke-toggle-item');
            allKeItems.forEach(item => {
                item.classList.remove('selected');
            });
            
            // Lấy dữ liệu kệ từ input_json API (nơi lưu trạng thái in_progress)
            const response = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/input_json/${STAGE_CONFIG.KEY}`);
            
            if (!response.ok) {
                
                return;
            }
            
            const data = await response.json();
            
            let raw = data && data.data ? data.data : null;
            if (!raw) {
                
                return;
            }
            
            if (typeof raw === 'string') {
                try { 
                    raw = JSON.parse(raw); 
                    
                } catch (e) { 
                    
                    return; 
                }
            }
            
            // Tìm tất cả các key chứa "_ke_records" (ví dụ: xen_ke_records, xa_ke_records)
            const keRecordsKeys = Object.keys(raw).filter(key => key.endsWith('_ke_records'));
            
            
            if (keRecordsKeys.length === 0) {
                
                return;
            }
            
            // Tìm kệ có trạng thái 'in_progress' cho stage hiện tại
            const currentStageStatusKey = `${STAGE_CONFIG.KEY}_status`;
            
            let availableRacks = [];
            
            keRecordsKeys.forEach(keRecordsKey => {
                const records = raw[keRecordsKey];
                
                
                if (Array.isArray(records)) {
                    records.forEach((record, index) => {
                        const status = record[currentStageStatusKey];
                        
                        
                        if (status === 'in_progress') {
                            // Lấy số kệ từ ke_id - ưu tiên xa_ke_id, xen_ke_id, ke_id
                            const keId = record.xa_ke_id || record.xen_ke_id || record.ke_id || '';
                            const match = keId.match(/(\d+)/);
                            if (match) {
                                const keNumber = parseInt(match[1]);
                                availableRacks.push({ keNumber, status });
                                
                            }
                        }
                    });
                }
            });
            
            
            
            if (availableRacks.length > 0) {
                // Tự động chọn các kệ này
                availableRacks.forEach(({ keNumber, status }) => {
                    const item = document.getElementById(`ke-${keNumber}`);
                    
                    
                    
                    if (item && previousProcessData[keNumber]) {
                        item.classList.add('selected');
                        selectedKe++;
                        
                        // Lưu thông tin kệ được chọn
                        keData[keNumber] = {
                            process: previousProcessData[keNumber],
                            status: 'selected'
                        };
                        
                    }
                });
                
                // Cập nhật UI sau khi tự động chọn
                updateSummary();
                
                // // Cập nhật hiển thị tổng số lượng đã nhập
                // setTimeout(() => {
                //     updateTotalQuantityDisplay();
                // }, 100);
                
            } else {
                
            }
            
        } catch (error) {
            console.error('❌ [autoSelectInProgressRacks] Lỗi:', error);
        }
    }

    // Production control functions
    async function startProduction() {

        const order = currentEditingOrder;
        if (!order) {
            showNotification('Lỗi: Không xác định được lệnh sản xuất', 'error');
            return;
        }
        
        try {
    
            showLoading('Đang bắt đầu ca làm việc...');
            
            // Lấy thông tin từ form trong sidebar
            const formData = getFormData();
            
            // Kiểm tra đã chọn ca làm việc chưa
            if (!formData.shift) {
                showNotification('⚠️ Vui lòng chọn ca làm việc', 'warning');
                return;
            }
            
            // Lấy máy được gán thực tế cho lệnh này
            const assignedMachine = getOrderMachine(order);
            if (!assignedMachine) {
                showNotification(`⚠️ Lệnh này không được gán cho máy ${STAGE_CONFIG.NAME} nào`, 'warning');
                return;
            }
            
            // Validation cơ bản
            if (!formData.worker || !formData.worker.trim()) {
                showNotification('⚠️ Vui lòng nhập tên thợ phụ trách trong phần "Thông tin sản xuất"', 'warning');
                return;
            }
            
            // Bắt buộc chọn ít nhất một kệ trước khi bắt đầu
            const selectedKeIds = Array.isArray(formData.selectedKeIds) ? formData.selectedKeIds : [];
            if (selectedKeIds.length === 0) {
                hideLoading();
                showNotification('⚠️ Vui lòng chọn kệ trước khi bắt đầu', 'warning');
                return;
            }
            
            // Lấy số ca tiếp theo
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            const nextShiftNumber = shiftsData.shifts && shiftsData.shifts.length > 0
                ? Math.max(...shiftsData.shifts.map(s => s.shift_number)) + 1
                : 1;
            
            const now = new Date();
            const shiftDate = now.toISOString().split('T')[0];
            
            const mysqlDateTime = formatDateTimeForMySQL(now);
            
            // Tạo ca làm việc mới với status 'in_progress'
            const createShiftData = {
                production_order_id: order.id,
                production_order: order.production_order,
                stage: STAGE_CONFIG.KEY,
                shift_number: nextShiftNumber,
                shift_name: formData.shift,
                shift_date: shiftDate,
                worker_name: formData.worker,
                machine_name: assignedMachine,
                start_time: mysqlDateTime,
                end_time: null,
                work_duration_minutes: 0,
                good_quantity: 0,
                ng_quantity: 0,
                ng_start_end_quantity: 0,
                return_quantity: 0,
                output_quantity: 0,
                handover_quantity: 0,
                efficiency_percent: 0,
                quality_score: 0,
                handover_person: '',
                receiver_person: '',
                ng_reason: '',
                quality_notes: '',
                is_overtime: 0,
                overtime_hours: 0,
                is_night_shift: 0,
                break_duration_minutes: 0,
                status: 'in_progress',
                notes: formData.note || `Bắt đầu ca làm việc ${formData.shift}`
            };
            
            // Tạo shift mới
            const response = await fetch(`${API_BASE_URL}/data/production_orders_shift`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(createShiftData)
            });
            
            const result = await response.json();
            
            if (response.ok) {
    
                showNotification('✅ Đã bắt đầu ca làm việc thành công!', 'success');
                
                // Lưu ID và thời gian bắt đầu của shift hiện tại để sử dụng khi bàn giao
                window.currentShiftId = result.shift_id;
                window.currentShiftStartTime = mysqlDateTime;

                
                // CẬP NHẬT TRẠNG THÁI TRONG {STAGE}_INPUT_QUANTITY_JSON
                try {
                    // 1. Lấy dữ liệu JSON hiện tại
                    let existingInputData = null;
                    try {
                        const existingResp = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`);
                        if (existingResp.ok) {
                            const data = await existingResp.json();
                            let raw = data && data.data ? data.data : null;
                            if (raw && typeof raw === 'string') {
                                try { 
                                    raw = JSON.parse(raw); 
                                    existingInputData = raw;
                                } catch (e) { 
                                    
                                }
                            } else if (raw && typeof raw === 'object') {
                                existingInputData = raw;
                            }
                        }
                    } catch (e) {
                        
                    }
                    
                    // 2. Cập nhật trạng thái từ waiting thành in_progress cho stage xen
                    if (existingInputData) {
                        // Tìm tất cả các key chứa "_ke_records" (ví dụ: xen_ke_records, xa_ke_records)
                        const keRecordsKeys = Object.keys(existingInputData).filter(key => key.endsWith('_ke_records'));
                        
                        // Kiểm tra xem có kệ nào được chọn cụ thể không
                        const selectedKeIds = formData.selectedKeIds || []; // Mảng ID có dạng ["ke-1", "ke-2", ...]
                        
                        keRecordsKeys.forEach(keRecordsKey => {
                            const records = existingInputData[keRecordsKey];
                            if (Array.isArray(records)) {
                                // Cập nhật trạng thái của các kệ
                                existingInputData[keRecordsKey] = records.map(record => {
                                    // Tạo bản sao của record để tránh thay đổi dữ liệu gốc
                                    const updatedRecord = { ...record };
                                    
                                    // Tìm trường status của stage hiện tại (xen_status)
                                    const currentStageStatusKey = `${STAGE_CONFIG.KEY}_status`;
                                    
                                    // Nếu có chọn kệ cụ thể
                                                                         if (selectedKeIds.length > 0) {
                                         // Cập nhật tất cả kệ được chọn
                                         // Tìm ke_id từ các trường có thể có (xa_ke_id, xen_ke_id, ke_id)
                                         const recordKeId = record.xa_ke_id || record.xen_ke_id || record.ke_id || '';
                                         
                                         
                                         // Kiểm tra xem kệ này có trong danh sách được chọn không
                                         const isSelected = selectedKeIds.some(selectedId => {
                                             // selectedId có dạng "ke-1" -> chuyển thành "ke_1" để match với database
                                             const targetKeId = selectedId.replace('-', '_');
                                             const matches = recordKeId === targetKeId;
                                             
                                             return matches;
                                         });
                                         
                                         if (isSelected && updatedRecord[currentStageStatusKey] === 'waiting') {
                                             updatedRecord[currentStageStatusKey] = 'in_progress';
                                             
                                         }
                                    } else {
                                        // Nếu không chọn kệ cụ thể, chỉ cập nhật kệ đầu tiên có trạng thái waiting
                                        if (updatedRecord[currentStageStatusKey] === 'waiting') {
                                            // Kiểm tra xem đã có kệ nào được cập nhật chưa
                                            const alreadyUpdated = records.some(r => r[currentStageStatusKey] === 'in_progress');
                                            if (!alreadyUpdated) {
                                                updatedRecord[currentStageStatusKey] = 'in_progress';
                                                
                                            }
                                        }
                                    }
                                    
                                    return updatedRecord;
                                });
                            }
                        });
                        
                        // Cập nhật metadata nếu có
                        const metadataKeys = Object.keys(existingInputData).filter(key => key.endsWith('_metadata'));
                        metadataKeys.forEach(metadataKey => {
                            if (existingInputData[metadataKey]) {
                                existingInputData[metadataKey] = {
                                    ...existingInputData[metadataKey],
                                    updated_at: new Date().toISOString(),
                                    last_action: 'start_production',
                                    last_updated_by: formData.worker,
                                    last_updated_stage: STAGE_CONFIG.KEY
                                };
                            }
                        });
                        
                        
                        
                        // 3. Lưu dữ liệu JSON đã cập nhật
                        
                        const saveInputResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                ke_data_json: existingInputData
                            })
                        });
                        
                                                        if (saveInputResponse.ok) {
                                    

                                    // Refresh lại UI để hiển thị trạng thái mới
                                    // loadCurrentStageKeData sẽ tự động gọi updateKeToggleGrid, updateSummary, và updateTotalQuantityDisplay
                                    await loadCurrentStageKeData(currentEditingOrder);
                                } else {
                            const saveError = await saveInputResponse.json();
                            console.warn('⚠️ [startProduction] Lỗi cập nhật input JSON:', saveError);
                        }
                    } else {
                        
                    }
                } catch (inputJsonError) {
                    console.warn('⚠️ [startProduction] Lỗi khi xử lý input JSON:', inputJsonError);
                }
                
                // Cập nhật trạng thái production_orders với stage_status = 'in_progress'
                try {
                    const orderUpdateData = {
                        status: 'in_progress',
                        [`${STAGE_CONFIG.KEY}_status`]: 'in_progress',
                        [`${STAGE_CONFIG.KEY}_worker_name`]: formData.worker,
                        [`${STAGE_CONFIG.KEY}_machine_name`]: assignedMachine,
                        [`${STAGE_CONFIG.KEY}_start_time`]: mysqlDateTime
                    };
                    

                    
                    const updateOrderResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(orderUpdateData)
                    });
                    
                    if (updateOrderResponse.ok) {
                        
                    } else {
                        const updateError = await updateOrderResponse.json();
                        console.warn('⚠️ Failed to update production order status:', updateError);
                    }
                } catch (updateError) {
                    console.warn('⚠️ Error updating production order status:', updateError);
                    // Không throw error vì đây không phải lỗi nghiêm trọng
                }
                
                // Cập nhật UI để hiển thị thời gian bắt đầu
                const startTimeElement = document.querySelector('.detail-section .alert .row .col-6:first-child span');
                if (startTimeElement) {
                    startTimeElement.textContent = formatDateTime(new Date(mysqlDateTime));
                    startTimeElement.classList.add('text-primary');
                }
                
                // Cập nhật thời gian bắt đầu trong sidebar
                const startTimeInfo = document.getElementById('startTimeInfo');
                if (startTimeInfo) {
                    // Hiển thị thời gian đã được định dạng
                    startTimeInfo.textContent = formatDateTime(mysqlDateTime);

                }
                
                // Hiển thị đồng hồ thời gian
                const timeDisplayContainer = document.querySelector('.detail-section .alert');
                if (timeDisplayContainer) {
                    // Kiểm tra xem đã có phần hiển thị thời gian chạy chưa
                    let timerSection = timeDisplayContainer.querySelector('.text-center');
                    
                    if (!timerSection) {
                        // Tạo phần hiển thị thời gian chạy nếu chưa có
                        const timerHtml = `
                            <hr class="my-2">
                            <div class="text-center">
                                <strong>Thời gian đang chạy:</strong><br>
                                <span class="text-warning" id="productionRunningTime">Đang tính...</span>
                            </div>
                        `;
                        timeDisplayContainer.insertAdjacentHTML('beforeend', timerHtml);
                    }
                    
                    // Bắt đầu timer ngay lập tức
                    startProductionTimer();
                }
                
                // Cập nhật trạng thái nút
                const startBtn = document.getElementById('startBtn');
                const handoverBtn = document.getElementById('handoverShiftBtn');
                const stopAndHandoverBtn = document.getElementById('stopAndHandoverBtn');
                const resetBtn = document.getElementById('resetBtn');
                
                // Ẩn nút bắt đầu, hiển thị các nút khác
                if (startBtn) {
                    startBtn.style.display = 'none';
                    startBtn.disabled = true;
                }
                
                if (handoverBtn) {
                    handoverBtn.style.display = 'flex';
                    handoverBtn.disabled = false;
                }
                
                if (stopAndHandoverBtn) {
                    stopAndHandoverBtn.style.display = 'flex';
                    stopAndHandoverBtn.disabled = false;
                }
                
                if (resetBtn) {
                    resetBtn.style.display = 'flex';
                    resetBtn.disabled = false;
                }
                
                // Refresh dữ liệu từ API
                await refreshData();
                
                // Refresh sidebar content
                showOrderDetails(order.id);
            } else {
                throw new Error(`API error: ${response.status} - ${result.message || result.error || 'Unknown error'}`);
            }
            
        } catch (error) {
            console.error('❌ Lỗi trong startProduction:', error);
            console.error('❌ Error stack:', error.stack);
            showNotification('Lỗi khi bắt đầu sản xuất: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }
 /**
     * Reset lệnh sản xuất về trạng thái chưa bắt đầu
     */
     async function resetProduction() {
        const order = currentEditingOrder;
        
        if (!order) {
            showNotification('Lỗi: Không xác định được lệnh sản xuất', 'error');
            return;
        }
        
        // Hiển thị dialog xác nhận
        const confirmed = confirm('⚠️ Bạn có chắc chắn muốn reset lệnh sản xuất này về trạng thái chưa bắt đầu?\n\nĐiều này sẽ:\n• Xóa thời gian bắt đầu và kết thúc\n• Reset trạng thái về "chưa bắt đầu"\n• Xóa dữ liệu sản xuất (số lượng, ghi chú, v.v.)\n\nHành động này không thể hoàn tác!');
        
        if (!confirmed) {
            return;
        }
        
        try {
            showLoading('Đang reset lệnh sản xuất...');
            
            // Chuẩn bị dữ liệu reset
            const resetData = {
                stage: STAGE_CONFIG.KEY,
                reset_to_not_started: true
            };
            
            // Gửi request đến API để reset
            const response = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/reset_production`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(resetData)
            });
            
            const result = await response.json();
            
            if (response.ok) {
                // Dừng timer nếu đang chạy
                stopProductionTimer();
                
                showNotification('✅ Đã reset lệnh sản xuất thành công!', 'success');
                
                // Xóa ca làm việc hiện tại trong production_orders_shift (nếu có)
                try {
                    if (window.currentShiftId) {
                        const deleteResp = await fetch(`${API_BASE_URL}/data/production_orders_shift/${window.currentShiftId}`, {
                            method: 'DELETE'
                        });
                        if (!deleteResp.ok) {
                            console.warn('⚠️ [resetProduction] Xóa shift không thành công (DELETE không ok)');
                        }
                        // Xóa state shift hiện tại trong bộ nhớ
                        window.currentShiftId = null;
                        window.currentShiftStartTime = null;
                    }
                } catch (shiftDeleteError) {
                    console.warn('⚠️ [resetProduction] Lỗi khi xóa/cập nhật shift:', shiftDeleteError);
                }

                // Rollback trạng thái kệ: in_progress -> waiting (chỉ kệ chưa completed)
                try {
                    let existingInputData = null;
                    try {
                        const existingResp = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`);
                        if (existingResp.ok) {
                            const data = await existingResp.json();
                            let raw = data && data.data ? data.data : null;
                            if (raw && typeof raw === 'string') {
                                try { raw = JSON.parse(raw); existingInputData = raw; } catch (e) {}
                            } else if (raw && typeof raw === 'object') {
                                existingInputData = raw;
                            }
                        }
                    } catch (e) {}

                    if (existingInputData) {
                        const keRecordsKeys = Object.keys(existingInputData).filter(key => key.endsWith('_ke_records'));
                        const currentStageStatusKey = `${STAGE_CONFIG.KEY}_status`;
                        keRecordsKeys.forEach(keRecordsKey => {
                            const records = existingInputData[keRecordsKey];
                            if (Array.isArray(records)) {
                                existingInputData[keRecordsKey] = records.map(record => {
                                    const updatedRecord = { ...record };
                                    const status = updatedRecord[currentStageStatusKey];
                                    if (status === 'in_progress') {
                                        updatedRecord[currentStageStatusKey] = 'waiting';
                                        updatedRecord[`${STAGE_CONFIG.KEY}_completed_time`] = null;
                                        updatedRecord[`${STAGE_CONFIG.KEY}_completed_by`] = null;
                                    }
                                    return updatedRecord;
                                });
                            }
                        });

                        // Cập nhật metadata
                        const metadataKeys = Object.keys(existingInputData).filter(key => key.endsWith('_metadata'));
                        metadataKeys.forEach(metadataKey => {
                            if (existingInputData[metadataKey]) {
                                existingInputData[metadataKey] = {
                                    ...existingInputData[metadataKey],
                                    updated_at: new Date().toISOString(),
                                    last_action: 'reset_production',
                                    last_updated_stage: STAGE_CONFIG.KEY
                                };
                            }
                        });

                        // Lưu dữ liệu rollback
                        const saveInputResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ ke_data_json: existingInputData })
                        });
                        if (!saveInputResponse.ok) {
                            try { const saveErr = await saveInputResponse.json(); console.warn('⚠️ [resetProduction] Lỗi lưu rollback kệ:', saveErr); } catch (_) {}
                        }
                    }
                } catch (rollbackError) {
                    console.warn('⚠️ [resetProduction] Lỗi rollback trạng thái kệ:', rollbackError);
                }

                // Cập nhật dữ liệu local
                if (currentEditingOrder) {
                    setOrderField(currentEditingOrder, 'status', 'waiting');
                    setOrderField(currentEditingOrder, 'start_time', null);
                    setOrderField(currentEditingOrder, 'end_time', null);
                    setOrderField(currentEditingOrder, 'worker', '');
                    setOrderField(currentEditingOrder, 'shift', '');
                    setOrderField(currentEditingOrder, 'good_quantity', 0);
                    setOrderField(currentEditingOrder, 'ng_quantity', 0);
                    setOrderField(currentEditingOrder, 'handover_quantity', 0);
                    setOrderField(currentEditingOrder, 'note', '');
                }
                
                // Làm sạch trạng thái chọn kệ trong UI
                try { if (typeof resetAllKe === 'function') resetAllKe(); } catch (_) {}
                try { if (typeof updateSelectedRackQuantityDisplaySync === 'function') updateSelectedRackQuantityDisplaySync(); } catch (_) {}
                try { if (typeof updateHandoverButtonValidationSync === 'function') updateHandoverButtonValidationSync(); } catch (_) {}

                await refreshData();
                showOrderDetails(order.id);
                
            } else {
                throw new Error(`API error: ${response.status} - ${result.message || result.error || 'Unknown error'}`);
            }
            
        } catch (error) {
            console.error('Reset production error:', error);
            
            // Fallback: Nếu API không hỗ trợ reset, thực hiện reset local
            if (error.message.includes('404') || error.message.includes('not found')) {
                showNotification('⚠️ API reset không khả dụng, thực hiện reset local...', 'warning');
                
                // Reset local data
                if (currentEditingOrder) {
                    setOrderField(currentEditingOrder, 'status', 'waiting');
                    setOrderField(currentEditingOrder, 'start_time', null);
                    setOrderField(currentEditingOrder, 'end_time', null);
                    setOrderField(currentEditingOrder, 'worker', '');
                    setOrderField(currentEditingOrder, 'shift', '');
                    setOrderField(currentEditingOrder, 'good_quantity', 0);
                    setOrderField(currentEditingOrder, 'ng_quantity', 0);
                    setOrderField(currentEditingOrder, 'handover_quantity', 0);
                    setOrderField(currentEditingOrder, 'note', '');
                }
                
                // Dừng timer
                stopProductionTimer();
                
                // Refresh UI
                await refreshData();
                showOrderDetails(order.id);
                
                showNotification('✅ Đã reset lệnh sản xuất (local)!', 'success');
            } else {
                showNotification('Lỗi khi reset lệnh sản xuất: ' + error.message, 'error');
            }
        } finally {
            hideLoading();
        }
    }



    // Utility functions for time display
    function formatDateTime(dateString) {
        if (!dateString) return 'N/A';
    
    try {
        // Xóa Z để JS không coi là UTC
        const localDateString = dateString.replace('Z', '');
        const date = new Date(localDateString);

        return date.toLocaleString('vi-VN', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            day: '2-digit',
            month: '2-digit',
            year: 'numeric'
        });
    } catch (error) {
        console.error('Error formatting date:', error);
        return 'Error';
    }
    }
    
 
    
    function formatDateTimeForInput(dateString) {
        if (!dateString) return '';
        
        try {
            const date = new Date(dateString);
            
            // Kiểm tra date có hợp lệ không
            if (isNaN(date.getTime())) {
                console.error('Invalid date in formatDateTimeForInput:', dateString);
                return '';
            }
            
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        } catch (error) {
            console.error('Error in formatDateTimeForInput:', error);
            return '';
        }
    }
    
    function calculateWorkTime(startTime, endTime) {
        if (!startTime || !endTime) return 'N/A';
        
        try {
            const start = new Date(startTime);
            const end = new Date(endTime);
            
            // Kiểm tra nếu date không hợp lệ
            if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                console.error('Invalid date in calculateWorkTime:', { startTime, endTime });
                return 'Invalid date';
            }
            
            const diffMs = end - start;
            
            // Xử lý trường hợp thời gian âm
            if (diffMs < 0) {
                console.warn('Negative time difference in calculateWorkTime:', { startTime, endTime, diffMs });
                return '00:00:00';
            }

            const hours = Math.floor(diffMs / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        } catch (error) {
            console.error('Error calculating work time:', error);
            return 'Error';
        }
    }

    // Format datetime cho MySQL (YYYY-MM-DD HH:mm:ss)
    function formatDateTimeForMySQL(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    // Biến để lưu trữ ID của timer
    let productionTimerId = null;

    /**
     * =================================================================
     * TAB SWITCHING FUNCTIONS - HÀM CHUYỂN ĐỔI TAB
     * =================================================================
     */

    /**
     * Switch between tabs in the sidebar
     */
    function switchTab(tabName) {

        
        // Remove active class from all tabs and panels in sidebar only
        document.querySelectorAll('.details-panel .tab-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.details-panel .tab-panel').forEach(panel => panel.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding panel
        const clickedTab = event.target.closest('.tab-btn');
        if (clickedTab) {
            clickedTab.classList.add('active');
        }
        
        const targetPanel = document.getElementById(tabName + '-panel');
        if (targetPanel) {
            targetPanel.classList.add('active');
    
        } else {
            console.error('❌ Panel not found:', tabName + '-panel');
        }
        
        // Load shifts data if switching to shifts tab
        if (tabName === 'shifts' && currentEditingOrder) {
            loadShiftsData(currentEditingOrder.id);
        }
    }

    /**
     * Load shifts data for an order
     */
    async function loadShiftsData(orderId) {
        const shiftsList = document.getElementById('shiftsList');
        const shiftsLoading = document.getElementById('shiftsLoading');
        
        if (!shiftsList || !shiftsLoading) {
            console.error('Shifts elements not found');
            return;
        }
        

        
        try {
            // Show loading
            shiftsLoading.style.display = 'flex';
            shiftsList.innerHTML = '';
            
            const apiUrl = `${API_BASE_URL}/data/production_orders/${orderId}/shifts?stage=${STAGE_CONFIG.KEY}`;

            
            // Fetch shifts data
            const response = await fetch(apiUrl);

            
            const data = await response.json();
                        if (response.ok) {
                
                renderShiftsList(data.shifts);
            } else {
                console.error('❌ API error:', response.status, data);
                throw new Error(data.error || 'Failed to load shifts data');
            }
        } catch (error) {
            console.error('💥 Error loading shifts data:', error);
            console.error('💥 Error stack:', error.stack);
            shiftsList.innerHTML = `
                <div class="empty-state">
                    <i class="bi bi-exclamation-triangle"></i>
                    <h5>Không thể tải dữ liệu ca làm việc</h5>
                    <p>${error.message}</p>
                </div>
            `;
        } finally {
            shiftsLoading.style.display = 'none';
        }
    }
    
    /**
     * Render shifts list
     */
    function renderShiftsList(shifts) {
        const shiftsList = document.getElementById('shiftsList');
        
        if (!shiftsList) {
            console.error('❌ Shifts list element not found!');
            return;
        }
        
        if (!shifts || shifts.length === 0) {
            shiftsList.innerHTML = `
                <div class="empty-state">
                    <i class="bi bi-clock-history"></i>
                    <h5>Chưa có ca làm việc nào</h5>
                    <p>Ca làm việc sẽ được tạo khi bắt đầu sản xuất</p>
                </div>
            `;
            return;
        }

        // Tính toán thống kê
        const completedShifts = shifts.filter(s => s.status === 'completed').length;
        const inProgressShifts = shifts.filter(s => s.status === 'in_progress').length;
        const pendingShifts = shifts.filter(s => s.status === 'pending').length;
        const totalQuantity = shifts.reduce((sum, s) => sum + (parseInt(s.handover_quantity) || 0), 0);

        // Tạo HTML cho thống kê
        const statsHtml = `
            <div class="shifts-stats">
                <div class="stat-card">
                    <div class="stat-number">${completedShifts}</div>
                    <div class="stat-label">Đã hoàn thành</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${inProgressShifts}</div>
                    <div class="stat-label">Đang chạy</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${pendingShifts}</div>
                    <div class="stat-label">Chờ bắt đầu</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${totalQuantity.toLocaleString()}</div>
                    <div class="stat-label">Tổng sản lượng</div>
                </div>
            </div>
        `;
        
        const shiftsHtml = shifts.map(shift => {
            const statusClass = getShiftStatusClass(shift.status);
            const statusText = getShiftStatusText(shift.status);
            const startTime = shift.start_time ? formatDateTime(shift.start_time) : '--';
            const endTime = shift.end_time ? formatDateTime(shift.end_time) : '--';
            const workDuration = shift.work_duration_minutes ? `${shift.work_duration_minutes} phút` : '--';
            const efficiency = shift.efficiency_percent && !isNaN(shift.efficiency_percent) ? 
                `${parseFloat(shift.efficiency_percent).toFixed(1)}%` : '--';
            
            // Tính toán progress cho ca đang chạy
            let progressHtml = '';
            if (shift.status === 'in_progress' && shift.start_time) {
                const start = new Date(shift.start_time);
                const now = new Date();
                const totalDuration = 8 * 60; // 8 giờ = 480 phút
                const elapsed = Math.floor((now - start) / (1000 * 60));
                const progress = Math.min(100, Math.max(0, (elapsed / totalDuration) * 100));
                const remaining = Math.max(0, totalDuration - elapsed);
                const remainingHours = Math.floor(remaining / 60);
                const remainingMinutes = remaining % 60;
                
                progressHtml = `
                    <div class="shift-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <div class="progress-text">${progress.toFixed(0)}% hoàn thành - Còn ${remainingHours} giờ ${remainingMinutes} phút</div>
                    </div>
                `;
            }
            
            return `
                <div class="shift-item">
                    <div class="shift-header">
                        <div class="shift-title">
                            <i class="bi bi-clock"></i>
                            ${shift.shift_name || `Ca ${shift.shift_number}`}
                        </div>
                        <span class="shift-status ${statusClass}">${statusText}</span>
                    </div>
                    
                    <div class="shift-details">
                        <div class="shift-detail">
                            <div class="shift-detail-label">Thợ phụ trách</div>
                            <div class="shift-detail-value">${shift.worker_name || '--'}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">Máy sản xuất</div>
                            <div class="shift-detail-value">${shift.machine_name || '--'}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">Số lượng OK</div>
                            <div class="shift-detail-value">${shift.handover_quantity || 0}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">Số lượng NG</div>
                            <div class="shift-detail-value">${(parseInt(shift.ng_quantity) || 0) + (parseInt(shift.ng_start_end_quantity) || 0)}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">Hiệu suất</div>
                            <div class="shift-detail-value">${efficiency}</div>
                        </div>
                        <div class="shift-detail">
                            <div class="shift-detail-label">Thời gian làm việc</div>
                            <div class="shift-detail-value">${workDuration}</div>
                        </div>
                    </div>

                    ${progressHtml}
                    
                    <div class="shift-times">
                        <span><i class="bi bi-play-circle"></i>Bắt đầu: ${startTime}</span>
                        <span><i class="bi bi-stop-circle"></i>Kết thúc: ${endTime}</span>
                    </div>

                    <div class="shift-actions">
                        <a href="#" class="btn-action btn-view" onclick="viewShiftDetails('${shift.id}')">
                            <i class="bi bi-eye"></i>Xem chi tiết
                        </a>
                        ${shift.status === 'in_progress' ? `
                            <a href="#" class="btn-action btn-edit" onclick="editShift('${shift.id}')">
                                <i class="bi bi-pencil"></i>Chỉnh sửa
                            </a>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join('');
        
        shiftsList.innerHTML = statsHtml + shiftsHtml;
    }
    

    
    /**
     * Get shift status class for CSS
     */
    function getShiftStatusClass(status) {
        switch (status) {
            case 'completed': return 'completed';
            case 'in_progress': return 'in_progress';
            case 'waiting': return 'waiting';
            case 'paused': return 'paused';
            case 'handed_over': return 'handed_over';
            default: return 'waiting';
        }
    }
    
    /**
     * Get shift status text
     */
    function getShiftStatusText(status) {
        switch (status) {
            case 'completed': return 'Hoàn thành';
            case 'in_progress': return 'Đang làm';
            case 'waiting': return 'Chờ';
            case 'paused': return 'Tạm dừng';
            case 'handed_over': return 'Đã bàn giao';
            default: return 'Chờ';
        }
    }

    /**
     * View shift details
     */
    function viewShiftDetails(shiftId) {
        
        // TODO: Implement shift details view
        showNotification('Tính năng xem chi tiết ca làm việc đang được phát triển', 'info');
    }

    /**
     * Edit shift
     */
    function editShift(shiftId) {
        
        // TODO: Implement shift editing
        showNotification('Tính năng chỉnh sửa ca làm việc đang được phát triển', 'info');
    }
    /**
     * Bàn giao ca làm việc
     */
    async function handoverShift() {
        const order = currentEditingOrder;
        
        if (!order) {
            showNotification('Lỗi: Không xác định được lệnh sản xuất', 'error');
            return;
        }
        
        // Kiểm tra có shift đang chạy không
        if (!window.currentShiftId) {
            showNotification('⚠️ Không có ca làm việc nào đang chạy. Vui lòng bắt đầu ca trước khi bàn giao.', 'warning');
            return;
        }
        
        // Lấy thông tin từ form trong sidebar
        const formData = getFormData();
        const goodQuantity = formData.goodQty;
        const ngQuantity = formData.ngQty;
        const ngStartEndQuantity = formData.ngStartEndQty;
        const returnQuantity = formData.returnQty;
        const handoverQuantity = formData.handoverQty;
        const workerName = formData.worker;
        const shift = formData.shift || getCurrentShift();
        const notes = formData.note;
        
        // Lấy máy được gán thực tế cho lệnh này
        const assignedMachine = getOrderMachine(order);
        if (!assignedMachine) {
            showNotification(`⚠️ Lệnh này không được gán cho máy ${STAGE_CONFIG.NAME} nào`, 'warning');
            return;
        }
        
        // Validation cơ bản
        if (!workerName || !workerName.trim()) {
            showNotification('⚠️ Vui lòng nhập tên thợ phụ trách trong phần "Thông tin sản xuất"', 'warning');
            return;
        }
        
        // Lấy tổng số lượng trong kệ đã chọn (chỉ kệ có status 'in_progress')
        const selectedRackTotalQuantity = await getTotalQuantityInSelectedRacks();
        
        
        // Kiểm tra có kệ sẵn sàng để bàn giao chưa
        if (selectedRackTotalQuantity <= 0) {
            showNotification('⚠️ Không tìm thấy kệ nào đang xử lý (in_progress) để bàn giao. Vui lòng kiểm tra lại trạng thái kệ.', 'warning');
            return;
        }
        
        // Tính tổng số lượng đã nhập
        const totalEnteredQuantity = goodQuantity + ngQuantity + ngStartEndQuantity + returnQuantity;
        
        
        // Kiểm tra logic: Tổng số lượng nhập phải bằng tổng số lượng trong kệ đã chọn
        if (totalEnteredQuantity !== selectedRackTotalQuantity) {
            const errorMessage = `❌ Số lượng không khớp!\n\n` +
                `📥 Tổng số lượng đã nhập: ${totalEnteredQuantity}\n` +
                `📦 Tổng số lượng trong kệ đã chọn: ${selectedRackTotalQuantity}\n\n` +
                `Chi tiết số lượng nhập:\n` +
                `• OK: ${goodQuantity}\n` +
                `• NG: ${ngQuantity}\n` +
                `• NG đầu/cuối: ${ngStartEndQuantity}\n` +
                `• Trả: ${returnQuantity}\n\n` +
                `Vui lòng điều chỉnh số lượng nhập cho khớp với tổng số lượng trong kệ đã chọn.`;
            
            showQuantityMismatchPopup(errorMessage);
            return;
        }
        
        // Kiểm tra phải có ít nhất một loại sản phẩm được nhập
        if (totalEnteredQuantity <= 0) {
            showNotification('⚠️ Vui lòng nhập ít nhất một loại số lượng (OK, NG, NG đầu/cuối, hoặc Trả)', 'warning');
            return;
        }
        
        // Kiểm tra số lượng bàn giao không vượt quá số lượng OK
        if (handoverQuantity > goodQuantity) {
            showNotification(`⚠️ Số lượng bàn giao (${handoverQuantity}) không thể lớn hơn số lượng OK (${goodQuantity})`, 'error');
            return;
        }
        
        // Kiểm tra số lượng bàn giao phải > 0 nếu có số lượng OK
        if (goodQuantity > 0 && handoverQuantity <= 0) {
            showNotification('⚠️ Vui lòng nhập số lượng bàn giao khi có sản phẩm OK', 'warning');
            return;
        }
        
        // Validate tổng số lượng không vượt quá số lượng đầu vào (nếu cần)
        if (!(await validateTotalQuantity(order, goodQuantity, ngQuantity, ngStartEndQuantity, returnQuantity))) {
            return;
        }
        
        // Hiển thị dialog xác nhận với thông tin đã được validation
        const confirmationMessage = `📋 Xác nhận bàn giao ca làm việc?\n\n` +
            `Lệnh sản xuất: ${order.production_order}\n` +
            `Thợ phụ trách: ${workerName}\n` +
            `Ca làm việc: ${shift}\n\n` +
            `📊 Số lượng:\n` +
            `• OK: ${goodQuantity.toLocaleString()}\n` +
            `• NG: ${ngQuantity.toLocaleString()}\n` +
            `• NG đầu/cuối: ${ngStartEndQuantity.toLocaleString()}\n` +
            `• Trả: ${returnQuantity.toLocaleString()}\n` +
            `• Tổng nhập: ${totalEnteredQuantity.toLocaleString()}\n` +
            `• Bàn giao: ${handoverQuantity.toLocaleString()}\n\n` +
            `📦 Tổng kệ đã chọn: ${selectedRackTotalQuantity.toLocaleString()}\n\n` +
            `✅ Số lượng đã được xác thực khớp!\n\n` +
            `Thông tin này sẽ được lưu vào lịch sử ca làm việc.`;
        
        if (!confirm(confirmationMessage)) {
            return;
        }
        
        try {
            showLoading('Đang bàn giao ca làm việc...');
            
            const now = new Date();
            const outputQuantity = goodQuantity + ngQuantity + ngStartEndQuantity + returnQuantity;
            const efficiencyPercent = outputQuantity > 0 ? (goodQuantity / outputQuantity) * 100 : 0;
            
            const mysqlDateTime = formatDateTimeForMySQL(now);
            

            
            // Tính thời gian làm việc (work_duration_minutes)
            let workDurationMinutes = 0;
            if (window.currentShiftStartTime) {
                const startTime = new Date(window.currentShiftStartTime);
                const endTime = new Date(mysqlDateTime);
                workDurationMinutes = Math.round((endTime - startTime) / (1000 * 60));
            }
            
            // Cập nhật shift hiện tại với thông tin bàn giao
            const updateData = {
                end_time: mysqlDateTime,
                work_duration_minutes: workDurationMinutes,
                good_quantity: goodQuantity,
                ng_quantity: ngQuantity,
                ng_start_end_quantity: ngStartEndQuantity,
                return_quantity: returnQuantity,
                output_quantity: outputQuantity,
                handover_quantity: handoverQuantity,
                efficiency_percent: efficiencyPercent,
                handover_person: workerName,
                machine_name: assignedMachine,
                status: 'completed',
                notes: notes
            };
            
        
            const updateResponse = await fetch(`${API_BASE_URL}/data/production_orders_shift/${window.currentShiftId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(updateData)
            });
            
            const updateResult = await updateResponse.json();
            
            if (updateResponse.ok) {
                
                // CẬP NHẬT TRẠNG THÁI KỆ TỪ IN_PROGRESS SANG COMPLETED TRONG INPUT JSON
                try {
                    // 1. Lấy dữ liệu input JSON hiện tại
                    let existingInputData = null;
                    try {
                        const existingResp = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`);
                        if (existingResp.ok) {
                            const data = await existingResp.json();
                            let raw = data && data.data ? data.data : null;
                            if (raw && typeof raw === 'string') {
                                try { 
                                    raw = JSON.parse(raw); 
                                    existingInputData = raw;
                                } catch (e) { 
                                    
                                }
                            } else if (raw && typeof raw === 'object') {
                                existingInputData = raw;
                            }
                        }
                    } catch (e) {
                        
                    }
                    
                    // 2. Cập nhật trạng thái từ in_progress thành completed
                    if (existingInputData) {
                        // Tìm tất cả các key chứa "_ke_records"
                        const keRecordsKeys = Object.keys(existingInputData).filter(key => key.endsWith('_ke_records'));
                        
                        // Lấy danh sách kệ được chọn
                        const selectedKeIds = formData.selectedKeIds || [];
                        console.log('🔍 [handoverShift] selectedKeIds:', selectedKeIds);
                        
                        keRecordsKeys.forEach(keRecordsKey => {
                            const records = existingInputData[keRecordsKey];
                            if (Array.isArray(records)) {
                                // Cập nhật trạng thái của các kệ
                                existingInputData[keRecordsKey] = records.map(record => {
                                    // Tạo bản sao của record để tránh thay đổi dữ liệu gốc
                                    const updatedRecord = { ...record };
                                    
                                    // Tìm trường status của stage hiện tại
                                    const currentStageStatusKey = `${STAGE_CONFIG.KEY}_status`;
                                    
                                    // Lấy ke_id của record hiện tại
                                    const recordKeId = record.ke_id || record.xa_ke_id || record.xen_ke_id || '';
                                    console.log(`🔍 [handoverShift] Checking record: ${recordKeId}, current status: ${updatedRecord[currentStageStatusKey]}`);
                                    
                                    // Kiểm tra xem kệ này có trong danh sách được chọn không
                                    const isSelected = selectedKeIds.some(selectedId => {
                                        const targetKeId = selectedId.replace('-', '_');
                                        return recordKeId === targetKeId;
                                    });
                                    
                                    // Cập nhật trạng thái từ in_progress -> completed cho tất cả kệ được chọn
                                    if (isSelected && updatedRecord[currentStageStatusKey] === 'in_progress') {
                                        console.log(`✅ [handoverShift] Updating ${recordKeId} from in_progress to completed`);
                                        updatedRecord[currentStageStatusKey] = 'completed';
                                        updatedRecord[`${STAGE_CONFIG.KEY}_completed_time`] = new Date().toISOString();
                                        updatedRecord[`${STAGE_CONFIG.KEY}_completed_by`] = formData.worker;
                                    }
                                    
                                    return updatedRecord;
                                });
                            }
                        });
                        
                        // Cập nhật metadata
                        const metadataKeys = Object.keys(existingInputData).filter(key => key.endsWith('_metadata'));
                        metadataKeys.forEach(metadataKey => {
                            if (existingInputData[metadataKey]) {
                                existingInputData[metadataKey] = {
                                    ...existingInputData[metadataKey],
                                    updated_at: new Date().toISOString(),
                                    last_action: 'handover_shift',
                                    last_updated_by: formData.worker,
                                    last_updated_stage: STAGE_CONFIG.KEY
                                };
                            }
                        });
                        
                        
                        
                        // 3. Lưu dữ liệu JSON đã cập nhật
                        const saveInputResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                ke_data_json: existingInputData
                            })
                        });
                        
                        if (saveInputResponse.ok) {
                            
                        } else {
                            const saveError = await saveInputResponse.json();
                            console.warn('⚠️ [handoverShift] Lỗi cập nhật input JSON:', saveError);
                        }
                    } else {
                        
                    }
                } catch (inputJsonError) {
                    console.warn('⚠️ [handoverShift] Lỗi khi xử lý input JSON:', inputJsonError);
                }
                
                // LƯU DỮ LIỆU JSON KỆ VÀO DATABASE
                try {
                    // Thu thập dữ liệu từ bảng kệ
                    const keTableData = collectQuantityOKTableData();
                    
                    if (keTableData.length > 0) {
                        // Lấy dữ liệu kệ cũ từ database
                        let existingKeData = null;
                        try {
                            const existingResp = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/handover_json/${STAGE_CONFIG.KEY}`);
                            if (existingResp.ok) {
                                const existingData = await existingResp.json();
                                let raw = existingData && existingData.data ? existingData.data : null;
                                if (raw && typeof raw === 'string') {
                                    try { raw = JSON.parse(raw); } catch (_) { }
                                }
                                if (raw) {
                                    existingKeData = raw;
                                }
                            }
                        } catch (e) {
                            
                        }
                        
                        // Tạo cấu trúc JSON kệ với key được prefix bởi {stage}
                        const stagePrefix = STAGE_CONFIG.KEY + '_';
                        const keRecordsKey = stagePrefix + 'ke_records';
                        const metadataKey = stagePrefix + 'metadata';
                        const nextStage = (order && (order.next_stage || getNextStageFromWorkflow(order.workflow_definition, STAGE_CONFIG.KEY))) || '';
                        const nextstagePrefix = nextStage ? (nextStage + '_') : 'next_';
                        
                        // Gộp dữ liệu kệ cũ và mới
                        let allKeRecords = [];
                        
                        // Thêm dữ liệu kệ cũ nếu có
                        if (existingKeData && existingKeData[keRecordsKey]) {
                            allKeRecords = [...existingKeData[keRecordsKey]];
                        }
                        
                        // Thêm dữ liệu kệ mới
                        const newKeRecords = keTableData.map(row => ({
                            [stagePrefix + 'ke_id']: `ke_${row.row_id}`,
                            [stagePrefix + 'ke_name']: row.ke,
                            [stagePrefix + 'status']: 'completed',
                            [stagePrefix + 'quantity']: row.ok_quantity,
                            [stagePrefix + 'shift']: shift,
                            [stagePrefix + 'operator']: workerName,
                            [stagePrefix + 'handover_time']: new Date().toISOString(),
                            [stagePrefix + 'notes']: `Bàn giao từ ca ${shift} - ${workerName}`,
                            [nextstagePrefix + 'status']: 'waiting'
                        }));
                        
                        allKeRecords = [...allKeRecords, ...newKeRecords];
                        
                        const keDataJSON = {
                            [keRecordsKey]: allKeRecords,
                            [metadataKey]: {
                                [stagePrefix + 'total_ke']: allKeRecords.length,
                                [stagePrefix + 'total_quantity']: allKeRecords.reduce((s, r) => s + (r[stagePrefix + 'quantity'] || 0), 0),
                                [stagePrefix + 'handover_quantity']: allKeRecords.reduce((s, r) => s + (r[stagePrefix + 'quantity'] || 0), 0),
                                [stagePrefix + 'last_updated']: new Date().toISOString()
                            }
                        };
                        
                        
                        
                        // Lưu vào cột {stage}_handover_quantity_json của production_orders
                        const saveKeResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/save_ke_json`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                stage: STAGE_CONFIG.KEY,
                                ke_data_json: keDataJSON,
                                production_order: order.production_order
                            })
                        });
                        
                        if (saveKeResponse.ok) {
                            const saveKeResult = await saveKeResponse.json();
                            
                            
                            // Không cần gọi endpoint cập nhật riêng nữa (đã lưu trực tiếp bằng save_ke_json)
                        } else {
                            const saveKeError = await saveKeResponse.json();
                            console.warn('⚠️ [handoverShift] Lỗi khi lưu JSON kệ:', saveKeError);
                        }
                    } else {
                        
                    }
                } catch (keError) {
                    console.warn('⚠️ [handoverShift] Lỗi khi xử lý JSON kệ:', keError);
                }
                
                // Kiểm tra logic status: nếu tổng số lượng nhập bằng số lượng còn sản xuất còn lại thì status=handed_over
                try {
        
                    
                    const inputQuantity = getInputQuantityFromPreviousStage(order);
                    const remainingQuantity = await getRemainingQuantity(order);
              
                    
                    // Nếu số lượng còn lại sau ca này = 0, thì status = 'handed_over'
                    const newStatus = remainingQuantity <= 0 ? 'handed_over' : 'waiting';
                    
                    // Xác định công đoạn tiếp theo
                    const nextStage = order.next_stage;
                    
                    const orderUpdateData = {
                        status: remainingQuantity <= 0 ? 'Hoàn thành' : 'Đang sản xuất',
                        [`${STAGE_CONFIG.KEY}_status`]: newStatus
                    };
                    
                    
                    
                    // Nếu có công đoạn tiếp theo và có số lượng bàn giao, cập nhật trạng thái công đoạn tiếp theo thành 'waiting'
                    if (nextStage && handoverQuantity > 0) {
                        orderUpdateData[`${nextStage}_status`] = 'waiting';
                        
                    }
                    
                    
                    
                    const updateOrderResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(orderUpdateData)
                    });
                    
                    if (updateOrderResponse.ok) {
                        const updateResult = await updateOrderResponse.json();

                        
                        // Kiểm tra xem có cập nhật trạng thái công đoạn tiếp theo không
                        if (nextStage && updateResult.updated_fields) {
                            const nextStageField = `${nextStage}_status`;
                            const hasNextStageUpdate = updateResult.updated_fields.includes(nextStageField);
                           
                        }
                    } else {
                        const updateError = await updateOrderResponse.json();
                        console.warn('⚠️ [handoverShift] Failed to update production order status after handover:', updateError);
                    }
                } catch (updateError) {
                    console.warn('⚠️ Error updating production order status after handover:', updateError);
                    // Không throw error vì đây không phải lỗi nghiêm trọng
                }
                
                showNotification('✅ Đã bàn giao ca làm việc thành công!', 'success');
            } else {
                console.error('❌ Update shift failed:', updateResult);
                throw new Error(`Cập nhật ca: ${updateResult.error || 'Unknown error'}`);
            }
            
            // Reset form số lượng
            setElementValue('goodQty', '0');
            setElementValue('ngQty', '0');
            setElementValue('ngStartEndQty', '0');
            setElementValue('returnQty', '0');
            setElementValue('handoverQty', '0');
            
            // Enable nút "Bắt đầu", disable nút "Bàn giao ca"
            const startBtn = document.querySelector('button[onclick="startProduction()"]');
            const handoverBtn = document.querySelector('button[onclick="handoverShift()"]');
            if (startBtn) startBtn.disabled = false;
            if (handoverBtn) handoverBtn.disabled = true;
            
            // Dừng timer
            stopProductionTimer();
            
            // Cập nhật dữ liệu local
            await refreshData();
            
            // Refresh sidebar content
            showOrderDetails(order.id);
            
            // Chuyển sang tab "Thông tin ca" để xem kết quả
            setTimeout(() => {
                const shiftsTab = document.querySelector('.details-panel .tab-btn[onclick*="shifts"]');
                if (shiftsTab) {
                    shiftsTab.click();
                }
            }, 500);
            
                        } catch (error) {
                    console.error('💥 Error in handoverShift:', error);
                    console.error('💥 Error stack:', error.stack);
                    console.error('💥 Error message:', error.message);
                    showNotification('Lỗi khi bàn giao ca làm việc: ' + error.message, 'error');
                } finally {
            hideLoading();
        }
    }

    /**
     * Reset form fields in the sidebar
     */
    function resetForm() {
        // Reset all input fields
        document.querySelectorAll('#detailsPanel input, #detailsPanel select, #detailsPanel textarea').forEach(field => {
            if (field.type === 'checkbox') {
                field.checked = false;
            } else {
                field.value = '';
            }
        });
        
        // Reset quantity inputs to 0
        document.querySelectorAll('.quantity-input').forEach(input => {
            input.value = '0';
        });
        
        showNotification('Đã reset form thành công!', 'success');
    }


    
    // Hàm tính thời gian đang chạy (từ thời điểm bắt đầu đến hiện tại)
    function calculateRunningTime(startTime, endTime) {

        
        try {
            // Parse thời gian bắt đầu
            const start = new Date(startTime);
            // Sử dụng thời gian hiện tại và chuyển về múi giờ local
            const end = endTime ? new Date(endTime) : new Date();
            
            // Thêm 7 giờ vào end time để chuyển về múi giờ Việt Nam
            const endLocal = new Date(end.getTime() + (7 * 60 * 60 * 1000));
          
            
            // Kiểm tra nếu date không hợp lệ
            if (isNaN(start.getTime()) || isNaN(endLocal.getTime())) {
                console.error('❌ Invalid date in calculateRunningTime:', { startTime, endTime });
                return 'Invalid date';
            }
            
            const diffMs = endLocal.getTime() - start.getTime();
            
            const hours = Math.floor(diffMs / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
            
            const result = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            return result;
        } catch (error) {
            return 'Error';
        }
    }
    
    // Hàm cập nhật thời gian chạy trong giao diện
    function updateRunningTimer() {
        // Tìm element timer trong sidebar mới
        const statusTimeElement = document.getElementById('statusTime');
        const runningTimeInfoElement = document.getElementById('runningTimeInfo');
        const endTimeInfoElement = document.getElementById('endTimeInfo');
        // Fallback cho element cũ nếu còn tồn tại
        const timerElement = document.getElementById('productionRunningTime');
        
        if (window.currentShiftStartTime) {
            // Tính thời gian chạy từ thời điểm bắt đầu đến hiện tại (hoặc thời điểm kết thúc nếu có)
            const endTime = getOrderField(currentEditingOrder, 'end_time');
            const time = calculateRunningTime(window.currentShiftStartTime, endTime);
            
  
            
            // Cập nhật timer trong sidebar mới (production status)
            if (statusTimeElement) {
                statusTimeElement.textContent = `Thời gian: ${time}`;
            }
            
            // Cập nhật thời gian chạy trong tab thông tin
            if (runningTimeInfoElement) {
                // Luôn cập nhật, không quan tâm có end_time hay không
                runningTimeInfoElement.textContent = time;
            }
            
            // Cập nhật thời gian kết thúc nếu đã kết thúc
            if (endTimeInfoElement && getOrderField(currentEditingOrder, 'end_time')) {
                endTimeInfoElement.textContent = formatDateTime(getOrderField(currentEditingOrder, 'end_time'));
            }
            
            // Cập nhật timer cũ nếu còn tồn tại (fallback)
            if (timerElement) {
                timerElement.textContent = time;
            }
        } else {
            console.warn('⚠️ Không có thời gian bắt đầu (window.currentShiftStartTime)');
            
            // Nếu chưa bắt đầu hoặc không có thời gian
            if (statusTimeElement) {
                statusTimeElement.textContent = 'Thời gian: 00:00:00';
            }
            if (runningTimeInfoElement) {
                runningTimeInfoElement.textContent = '--';
            }
            if (endTimeInfoElement) {
                endTimeInfoElement.textContent = '--';
            }
        }
    }
    
    // Hàm bắt đầu timer
    function startProductionTimer() {
        // Xóa timer cũ nếu có
        stopProductionTimer();
        
        // Log order information for debugging
        if (currentEditingOrder) {
            
        }
        
        // Bắt đầu timer mới, cập nhật mỗi giây
        updateRunningTimer();
        productionTimerId = setInterval(updateRunningTimer, 1000);

    }
    
    // Hàm dừng timer
    function stopProductionTimer() {
        if (productionTimerId) {
            clearInterval(productionTimerId);
            productionTimerId = null;
        }
    }

    // Export functions for global access
    window.refreshData = refreshData;
    window.showReportTab = showReportTab;

    

    window.updateHandoverQuantity = updateHandoverQuantity;
    
    // Filter functions
    window.applyFilters = applyFilters;
    window.clearFilters = clearFilters;
    
    // Wizard functions
    window.wizardNextStep = wizardNextStep;
    window.wizardPreviousStep = wizardPreviousStep;

    window.updateWizardHandoverQuantity = updateWizardHandoverQuantity;
    
    // Details panel functions
    window.showOrderDetails = showOrderDetails;
    window.closeDetailsPanel = closeDetailsPanel;

    // Rack selection and validation functions
    window.getTotalQuantityInSelectedRacks = getTotalQuantityInSelectedRacks;
    window.updateSelectedRackQuantityDisplay = updateSelectedRackQuantityDisplay;
    window.updateHandoverButtonValidation = updateHandoverButtonValidation;
    window.autoSelectInProgressRacks = autoSelectInProgressRacks;
    
    // Sync wrapper functions
    window.updateSelectedRackQuantityDisplaySync = updateSelectedRackQuantityDisplaySync;
    window.updateHandoverButtonValidationSync = updateHandoverButtonValidationSync;

    // Wrapper functions for async calls from event listeners
    function updateSelectedRackQuantityDisplaySync() {
        
        updateSelectedRackQuantityDisplay().catch(error => {
            console.error('❌ [updateSelectedRackQuantityDisplaySync] Lỗi:', error);
        });
    }

    function updateHandoverButtonValidationSync() {
        
        updateHandoverButtonValidation().catch(error => {
            console.error('❌ [updateHandoverButtonValidationSync] Lỗi:', error);
        });
    }

    window.startProduction = startProduction;
    // window.endProduction = endProduction;

    // Tab switching functions
    window.switchTab = switchTab;
    window.resetForm = resetForm;
    // window.pauseProduction = pauseProduction;
    
    // Quantity OK table functions
    window.addQuantityOKRow = addQuantityOKRow;
    window.removeQuantityOKRow = removeQuantityOKRow;

    // Popup functions
    window.showQuantityMismatchPopup = showQuantityMismatchPopup;
    window.closeQuantityMismatchPopup = closeQuantityMismatchPopup;

    




    /**
     * =================================================================
     * REPORT FUNCTIONS - HÀM XỬ LÝ BÁO CÁO
     * =================================================================
     */

    /**
     * Hiển thị tab báo cáo
     */
    function showReportTab() {
        
        // Chuyển sang tab báo cáo
        const reportTab = document.getElementById('report-tab');
        
        if (reportTab) {
            reportTab.click();
        } else {
            console.error('Report tab not found!');
        }
        
        // Load dữ liệu báo cáo
        loadReportData();
    }

    /**
     * Load dữ liệu báo cáo - các lệnh đã bàn giao
     */
    async function loadReportData() {
      
        
        try {
            showLoading('Đang tải dữ liệu báo cáo...');
            
                    // Lọc các lệnh đã hoàn thành (số lượng cần sản xuất = 0) và đã được bàn giao từ công đoạn trước
        const handedOverOrders = ordersData.filter(order => {
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // Tính tổng số lượng bàn giao và input
            const previousStageHandover = order.previous_stage_handover_quantity || 0;
            const currentStageHandover = getOrderField(order, 'handover_quantity') || 0;
            const currentStageInput = getOrderField(order, 'input_quantity') || 0;
            
  
            return inputQuantity <= 0 && previousStageHandover > 0;
        });  
        
            
            // Render bảng báo cáo
            renderReportTable(handedOverOrders);
            
            // Cập nhật số lượng
            updateReportCount(handedOverOrders.length);
            
        } catch (error) {
            console.error('Error in loadReportData:', error);
            showNotification('Lỗi khi tải dữ liệu báo cáo: ' + error.message, 'error');
        } finally {
            hideLoading();
        }
    }

    /**
     * Render bảng báo cáo
     */
    function renderReportTable(orders) {
        const tableBody = document.getElementById('reportTableBody');
        if (!tableBody) {
            console.error('reportTableBody not found!');
            return;
        }
        
        // Xóa dữ liệu cũ
        tableBody.innerHTML = '';
        
        // Kiểm tra có dữ liệu không
        if (orders.length === 0) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="13" class="text-center text-muted py-4">
                        <i class="bi bi-file-earmark-text fs-1 mb-2 d-block"></i>
                        Chưa có lệnh nào được bàn giao
                    </td>
                </tr>
            `;
            return;
        }

        // Sắp xếp theo thời gian bàn giao (mới nhất lên đầu)
        const sortedOrders = [...orders].sort((a, b) => {
            const aTime = getOrderField(a, 'handover_date') ? new Date(getOrderField(a, 'handover_date')).getTime() : 0;
            const bTime = getOrderField(b, 'handover_date') ? new Date(getOrderField(b, 'handover_date')).getTime() : 0;
            return bTime - aTime;
        });

        // Render từng dòng
        sortedOrders.forEach((order, index) => {
            const row = createReportTableRow(order, index);
            tableBody.appendChild(row);
        });
    }
    /**
     * Tạo dòng báo cáo
     */
    function createReportTableRow(order, index) {
        const row = document.createElement('tr');
        row.className = 'order-row';
        row.setAttribute('data-order-id', order.id);
        
        // Tính toán tiến độ
        const inputQty = getOrderField(order, 'input_quantity') || 0;
        const sheet_count = order.sheet_count || 0;
        const goodQty = getOrderField(order, 'good_quantity') || 0;
        const ngQty = getOrderField(order, 'ng_quantity') || 0;
        const deployedQty = order.deployed_quantity || 0;
        const progressPercent = inputQty > 0 ? Math.round((goodQty / inputQty) * 100) : 0;
        
        // Lấy thông tin bàn giao
        const handoverDate = getOrderField(order, 'handover_date') ? formatDateTime(getOrderField(order, 'handover_date')) : 'N/A';
        const handoverQuantity = getOrderField(order, 'handover_quantity') || 0;
        
        // Xác định icon và màu sắc cho trạng thái đã bàn giao
        const statusIcon = 'bi-arrow-right-circle';
        const statusClass = 'text-info';
        const statusText = 'Đã bàn giao';
        
        row.innerHTML = `
            <td class="text-center">
                <span class="badge bg-light text-dark">${index + 1}</span>
            </td>
            <td>
                <div class="d-flex align-items-center">
                    <i class="bi ${statusIcon} ${statusClass} me-2"></i>
                    <div>
                        <div class="fw-bold">${order.production_order}</div>
                        <small class="text-muted">${formatDate(order.deployment_date)} - ${getOrderField(order, 'shift')}</small>
                        <small class="text-info d-block">${statusText}</small>
                    </div>
                </div>
            </td>
            <td class="text-center">
                <span class="fw-bold">${order.order_type || ''}</span>
            </td>
            <td>
                <div>
                    <div class="fw-bold">${order.internal_product_code}</div>
                    <small class="text-muted" title="${order.product_name}">${truncateText(order.product_name, 100)}</small>
                </div>
            </td>
            <td class="text-center">
                <span class="badge bg-secondary">${order.paper_type || 'N/A'}</span>
            </td>
            <td class="text-center">
                <span class="fw-bold">${order.paper_weight || 0} gsm</span>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(deployedQty)}</div>
                <small class="text-muted">pcs</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-primary">${formatNumber(sheet_count)}</div>
                <small class="text-muted">tờ giấy</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-success">${formatNumber(order.paper_length || 0)}</div>
                <small class="text-muted">KT</small>
            </td>
            <td class="text-center">
                <div class="fw-bold text-danger">${formatNumber(order.paper_width || 0)}</div>
                <small class="text-muted">chiều rộng</small>
            </td>
            <td class="text-center">
                <div class="fw-bold">${formatNumber(order.blank_count || 0)}</div>
                <small class="text-muted">phôi</small>
            </td>
            <td class="text-center">
                <div class="progress" style="height: 20px;">
                    <div class="progress-bar bg-success" style="width: ${Math.min(progressPercent, 100)}%">
                        ${progressPercent}%
                    </div>
                </div>
                <small class="text-muted">${statusText}</small>
            </td>
            <td class="text-center">
                <small class="text-muted d-block" title="${order.assigned_machine || 'N/A'}">${truncateText(order.assigned_machine || 'N/A', 15)}</small>
            </td>
        `;
        
        // Thêm click event để xem chi tiết
        row.style.cursor = 'pointer';
        row.addEventListener('click', () => {
            showOrderDetails(order.id);
        });
        
        return row;
    }

    /**
     * Cập nhật số lượng báo cáo
     */
    function updateReportCount(count) {
        const reportCountElement = document.getElementById('report-count');
        if (reportCountElement) {
            reportCountElement.textContent = count;
        } else {
            console.error('report-count element not found!');
        }
    }

    /**
     * =================================================================
     * FILTER FUNCTIONS - HÀM LỌC DỮ LIỆU
     * =================================================================
     */

    // Biến lưu trữ dữ liệu gốc và dữ liệu đã lọc
    let originalOrdersData = [];
    let filteredOrdersData = [];

    /**
     * Áp dụng các bộ lọc
     */
    function applyFilters() {
        const fromDateFilter = document.getElementById('fromDateFilter')?.value || '';
        const toDateFilter = document.getElementById('toDateFilter')?.value || '';
        const searchInput = document.getElementById('searchInput')?.value?.toLowerCase() || '';

        // Lọc dữ liệu
        let filteredCount = 0;
        filteredOrdersData = originalOrdersData.filter(order => {
            // Lọc theo khoảng ngày sản xuất
            if (fromDateFilter && toDateFilter) {
                const orderDate = order.deployment_date || order.created_at;
                if (!orderDate || orderDate < fromDateFilter || orderDate > toDateFilter) {
                    return false;
                }
            } else if (fromDateFilter) {
                const orderDate = order.deployment_date || order.created_at;
                if (!orderDate || orderDate < fromDateFilter) {
                    return false;
                }
            } else if (toDateFilter) {
                const orderDate = order.deployment_date || order.created_at;
                if (!orderDate || orderDate > toDateFilter) {
                    return false;
                }
            }



            // Lọc theo tìm kiếm
            if (searchInput) {
                const searchFields = [
                    order.order_type,
                    order.production_order,
                    order.internal_product_code,
                    order.paper_type,
                    order.assigned_machine,
                    getOrderField(order, 'worker_name')
                ].map(field => (field || '').toLowerCase());

                const hasMatch = searchFields.some(field => field.includes(searchInput));
                if (!hasMatch) {
                    return false;
                }
            }



            filteredCount++;
            return true;
        });



        // Cập nhật dữ liệu hiển thị
        ordersData = filteredOrdersData;
        
        // Render lại bảng
        renderOrdersTable();
        updateStatistics();
        
        // Hiển thị thông báo
        if (filteredOrdersData.length === 0) {
            showNotification('Không tìm thấy dữ liệu phù hợp với bộ lọc', 'warning');
        } else {
            showNotification(`Đã lọc: ${filteredOrdersData.length} lệnh sản xuất`, 'info');
        }
    }

    /**
     * Xóa tất cả bộ lọc
     */
    function clearFilters() {
        const fromDateFilter = document.getElementById('fromDateFilter');
        const toDateFilter = document.getElementById('toDateFilter');
        const searchInput = document.getElementById('searchInput');
        
        if (fromDateFilter) fromDateFilter.value = '';
        if (toDateFilter) toDateFilter.value = '';
        if (searchInput) searchInput.value = '';

        // Xóa cache filter ngày khi clear
        localStorage.removeItem(DATE_FILTER_CACHE_KEY);

        // Khôi phục dữ liệu gốc
        ordersData = [...originalOrdersData];
        
        // Chuyển về tab "Tất cả" khi xóa filter
        const allTab = document.getElementById('all-tab');
        if (allTab) {
            allTab.click();
        }
        
        // Render lại bảng
        renderOrdersTable();
        updateStatistics();
        
        showNotification('Đã xóa tất cả bộ lọc', 'info');
    }

    /**
     * Tự động lọc khi nhập tìm kiếm (debounce)
     */
    let searchTimeout;
    function setupSearchDebounce() {
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    applyFilters();
                }, 300); // Delay 300ms
            });
        }
    }

    /**
     * Tự động lọc khi thay đổi bộ lọc
     */
    function setupFilterChangeListeners() {
        // Chỉ setup listener cho các element thực sự tồn tại
        const fromDateFilter = document.getElementById('fromDateFilter');
        const toDateFilter = document.getElementById('toDateFilter');

        if (fromDateFilter) {
            fromDateFilter.addEventListener('change', applyFilters);
        }
        if (toDateFilter) {
            toDateFilter.addEventListener('change', applyFilters);
        }
    }

    /**
     * Cập nhật danh sách máy từ dữ liệu thực tế
     */
    function updateMachineFilterOptions() {
        const machineFilter = document.getElementById('machineFilter');
        if (!machineFilter) {
            return;
        }

        // Lọc các máy thuộc Stage_${STAGE_CONFIG.KEY} từ dữ liệu máy
        const MStageMachines = machineStatusData.filter(machine => 
            machine.stage_machine && machine.stage_machine.includes(`Stage_${STAGE_CONFIG.KEY}`)
        ).map(machine => machine.machine_name);

        // Xóa options cũ (giữ lại option "Tất cả")
        machineFilter.innerHTML = '<option value="">Tất cả</option>';

        // Thêm options mới
        MStageMachines.sort().forEach(machine => {
            const option = document.createElement('option');
            option.value = machine;
            option.textContent = machine;
            machineFilter.appendChild(option);
        });
    }


    /**
     * Tính số lượng cần sản xuất còn lại
     * = Số lượng từ công đoạn trước - (Tổng số lượng bàn giao + NG của các ca đã làm)
     */
    async function getRemainingQuantity(order) {
        try {
            // Lấy số lượng từ công đoạn trước
            const inputQuantity = getInputQuantityFromPreviousStage(order);
            
            // Lấy tổng số lượng bàn giao của các ca đã làm
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${order.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            let totalHandoverQuantity = 0;
            let totalNgQuantity = 0;
            if (shiftsData.shifts && Array.isArray(shiftsData.shifts)) {
                shiftsData.shifts.forEach(shift => {
                    totalHandoverQuantity += (parseInt(shift.handover_quantity) || 0);
                    totalNgQuantity += (parseInt(shift.ng_quantity) || 0);
                });
            }
            
            const remainingQuantity = Math.max(0, inputQuantity - totalHandoverQuantity - totalNgQuantity);
            
            return remainingQuantity;
        } catch (error) {
            console.error('❌ Lỗi tính số lượng còn lại:', error);
            return getInputQuantityFromPreviousStage(order); // Fallback
        }
    }

    /**
     * Load và hiển thị số lượng còn lại
     */
    async function loadRemainingQuantity() {
        if (!currentEditingOrder) return;
        
        try {
            const remainingQuantity = await getRemainingQuantity(currentEditingOrder);
            
            // Cập nhật hiển thị số lượng còn lại
            const remainingQuantityDisplay = document.getElementById('remainingQuantityDisplay');
            if (remainingQuantityDisplay) {
                remainingQuantityDisplay.textContent = `${remainingQuantity} tờ giấy`;
            }
            
            // Cập nhật hiển thị tổng số lượng đã nhập
            const totalQuantityDisplay = document.getElementById('totalQuantityDisplay');
            if (totalQuantityDisplay) {
                const currentTotal = parseInt(getElementValue('goodQty') || 0) + 
                                   parseInt(getElementValue('ngQty') || 0) + 
                                   parseInt(getElementValue('ngStartEndQty') || 0) + 
                                   parseInt(getElementValue('returnQty') || 0);
                
                // Lấy tổng số lượng trong kệ đã chọn
                const selectedRackTotalQuantity = await getTotalQuantityInSelectedRacks();
                totalQuantityDisplay.textContent = `${currentTotal} / ${selectedRackTotalQuantity}`;
                
                // Thay đổi màu sắc dựa trên validation
                if (currentTotal > selectedRackTotalQuantity) {
                    totalQuantityDisplay.style.color = '#dc3545'; // Đỏ - vượt quá
                    totalQuantityDisplay.style.fontWeight = 'bold';
                } else if (currentTotal === selectedRackTotalQuantity) {
                    totalQuantityDisplay.style.color = '#28a745'; // Xanh lá - khớp chính xác
                    totalQuantityDisplay.style.fontWeight = 'bold';
                } else {
                    totalQuantityDisplay.style.color = '#6c757d'; // Xám - chưa đủ
                    totalQuantityDisplay.style.fontWeight = 'normal';
                }
            }
            
        } catch (error) {
            console.error('❌ Lỗi load số lượng còn lại:', error);
        }
    }

    /**
     * Cập nhật hiển thị thống kê real-time
     */
    function updateStatisticsDisplay() {
        const goodQty = parseInt(getElementValue('goodQty')) || 0;
        const ngQty = parseInt(getElementValue('ngQty')) || 0;
        const ngStartEndQty = parseInt(getElementValue('ngStartEndQty')) || 0;
        const returnQty = parseInt(getElementValue('returnQty')) || 0;
        
        const totalProduced = goodQty + ngQty + ngStartEndQty + returnQty;
        const inputQuantity = getInputQuantityFromPreviousStage(currentEditingOrder);
        const efficiency = inputQuantity > 0 ? Math.round((totalProduced / inputQuantity) * 100) : 0;
        const ngRate = totalProduced > 0 ? Math.round(((ngQty + ngStartEndQty) / totalProduced) * 100) : 0;
        
        // Cập nhật hiển thị thống kê
        const totalProducedElement = document.getElementById('totalProducedValue');
        const efficiencyElement = document.getElementById('efficiencyValue');
        const ngRateElement = document.getElementById('ngRateValue');
        
        if (totalProducedElement) {
            totalProducedElement.textContent = `${totalProduced} sản phẩm`;
        }
        if (efficiencyElement) {
            efficiencyElement.textContent = `${efficiency}%`;
        }
        if (ngRateElement) {
            ngRateElement.textContent = `${ngRate}%`;
        }
        
        // Cập nhật hiển thị tổng số lượng đã nhập
        handleUpdateTotalQuantityDisplay();
    }

    /**
     * Load và hiển thị số lượng còn lại
     */
    async function loadRemainingQuantity() {
        if (!currentEditingOrder) return;
        
        try {
            const remainingQuantity = await getRemainingQuantity(currentEditingOrder);
            
            // Cập nhật hiển thị số lượng còn lại
            const remainingQuantityDisplay = document.getElementById('remainingQuantityDisplay');
            if (remainingQuantityDisplay) {
                remainingQuantityDisplay.textContent = `${remainingQuantity} tờ giấy`;
            }
            
            // Cập nhật hiển thị tổng số lượng đã nhập
            const totalQuantityDisplay = document.getElementById('totalQuantityDisplay');
            if (totalQuantityDisplay) {
                const currentTotal = parseInt(getElementValue('goodQty') || 0) + 
                                   parseInt(getElementValue('ngQty') || 0) + 
                                   parseInt(getElementValue('ngStartEndQty') || 0) + 
                                   parseInt(getElementValue('returnQty') || 0);
                totalQuantityDisplay.textContent = `${currentTotal} / ${remainingQuantity}`;
            }
            
        } catch (error) {
            console.error('❌ Lỗi load số lượng còn lại:', error);
        }
    }

    /**
     * Kiểm tra shift hiện tại và cập nhật trạng thái nút
     */
    async function checkCurrentShiftStatus() {
        if (!currentEditingOrder) return;
        
        try {
            const shiftsResponse = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/shifts?stage=${STAGE_CONFIG.KEY}`);
            const shiftsData = await shiftsResponse.json();
            
            // Tìm shift đang chạy (status = 'in_progress')
            const currentShift = shiftsData.shifts?.find(shift => shift.status === 'in_progress');
            
            // Cập nhật trạng thái nút
            const startBtn = document.getElementById('startBtn');
            const handoverBtn = document.getElementById('handoverShiftBtn');
            const stopAndHandoverBtn = document.getElementById('stopAndHandoverBtn');
            const handoverBtn2 = document.getElementById('handoverBtn');
            const resetBtn = document.getElementById('resetBtn');
            
            if (currentShift) {
                // Có shift đang chạy
        
                
                // Cập nhật UI dựa trên trạng thái ca kíp
                if (startBtn) {
                    startBtn.style.display = 'none';
                    startBtn.disabled = true;
                }
                
                if (handoverBtn) {
                    handoverBtn.style.display = 'flex';
                    handoverBtn.disabled = false;
                }
                
                if (stopAndHandoverBtn) {
                    stopAndHandoverBtn.style.display = 'flex';
                    stopAndHandoverBtn.disabled = false;
                }
                
                if (resetBtn) {
                    resetBtn.style.display = 'flex';
                    resetBtn.disabled = false;
                }
                
                // Lưu ID và thời gian bắt đầu của shift hiện tại
                window.currentShiftId = currentShift.id;
                window.currentShiftStartTime = currentShift.start_time;
                
                // Cập nhật hiển thị thời gian bắt đầu trong sidebar
                const startTimeInfo = document.getElementById('startTimeInfo');
                if (startTimeInfo) {
                    // Hiển thị thời gian đã được định dạng
                    startTimeInfo.textContent = formatDateTime(currentShift.start_time);
    
                }
                
                // Bắt đầu timer nếu chưa có
                if (!productionTimerId) {
                    startProductionTimer();
                }
                

            } else {
                // Không có shift đang chạy

                // Tạm thời bỏ điều kiện kiểm tra trạng thái lệnh
                // Luôn hiển thị nút bắt đầu khi không có shift đang chạy
                
                if (startBtn) {
                    // Hiển thị nút bắt đầu
                    startBtn.style.display = 'flex';
                    startBtn.disabled = false;
                }
                
                if (handoverBtn) {
                    handoverBtn.style.display = 'none';
                    handoverBtn.disabled = true;
                }
                
                if (stopAndHandoverBtn) {
                    stopAndHandoverBtn.style.display = 'none';
                    stopAndHandoverBtn.disabled = true;
                }
                
                if (resetBtn) {
                    resetBtn.style.display = 'none';
                    resetBtn.disabled = true;
                }
                
                // Dừng timer
                stopProductionTimer();
                
    
            }
            
        } catch (error) {
            console.error('❌ Lỗi kiểm tra trạng thái shift:', error);
        }
    }

    /**
     * Load và hiển thị số lượng còn lại
     */
    async function loadRemainingQuantity() {
        if (!currentEditingOrder) return;
        
        try {
            const remainingQuantity = await getRemainingQuantity(currentEditingOrder);
            
            // Cập nhật hiển thị số lượng còn lại
            const remainingQuantityDisplay = document.getElementById('remainingQuantityDisplay');
            if (remainingQuantityDisplay) {
                remainingQuantityDisplay.textContent = `${remainingQuantity} tờ giấy`;
            }
            
            // Cập nhật hiển thị tổng số lượng đã nhập
            const totalQuantityDisplay = document.getElementById('totalQuantityDisplay');
            if (totalQuantityDisplay) {
                const currentTotal = parseInt(getElementValue('goodQty') || 0) + 
                                   parseInt(getElementValue('ngQty') || 0) + 
                                   parseInt(getElementValue('ngStartEndQty') || 0) + 
                                   parseInt(getElementValue('returnQty') || 0);
                totalQuantityDisplay.textContent = `${currentTotal} / ${remainingQuantity}`;
            }
            
        } catch (error) {
            console.error('❌ Lỗi load số lượng còn lại:', error);
        }
    }
  </script>
  <!-- User Info Update Script -->
  <script>
    // Update user info when page loads
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(checkAuthAndUpdateUser, 100);
    });
    

    
    function checkAuthAndUpdateUser() {
      if (typeof auth === 'undefined') {
        setTimeout(checkAuthAndUpdateUser, 100);
        return;
      }
      
      if (!auth.isLoggedIn()) {
        showLoginPopup({
          onLoginSuccess: function(userData) {
            updateUserInfo();
            refreshData();
          },
          onLoginError: function(error) {
            console.error('Login failed:', error);
          }
        });
        return;
      }
      
      updateUserInfo();
    }
    
    function updateUserInfo() {
      const userNameElement = document.getElementById('userName');
      
      if (!userNameElement) {
        setTimeout(updateUserInfo, 100);
        return;
      }
      
      if (typeof auth === 'undefined') {
        setTimeout(updateUserInfo, 100);
        return;
      }
      
      const user = auth.getUser();
      
      if (user) {
        userNameElement.textContent = user.full_name;
      } else {
        userNameElement.textContent = 'Chưa đăng nhập';
      }
    }
    

    
    // Multi-Select Worker Functions
    function initializeWorkerMultiSelect(order) {
        const selectedWorkers = document.getElementById('selectedWorkers');
        const workerSearch = document.getElementById('workerSearch');
        const workerDropdown = document.getElementById('workerDropdown');
        const workerOptions = document.getElementById('workerOptions');
        
        // Lấy danh sách user từ API
        let availableWorkers = [];
        
        async function loadWorkersFromAPI() {
            try {
                const response = await fetch(`${API_BASE_URL}/data/user`);
                
                if (response.ok) {
                    const users = await response.json();
           
                    
                    // Kiểm tra format của response
                    if (Array.isArray(users)) {
                        availableWorkers = users.map(user => {
                            // Format: "Mã nhân viên - Tên nhân viên"
                            const name = `${user.ma_nhan_vien} - ${user.ten_nhan_vien}`;
                            return name;
                        }).filter(name => name && name.trim());
                    } else if (users.data && Array.isArray(users.data)) {
                        availableWorkers = users.data.map(user => `${user.ma_nhan_vien} - ${user.ten_nhan_vien}`).filter(name => name);
                    } else {
                        console.error('Unexpected API response format:', users);
                        availableWorkers = [];
                    }
                    
                    // Sau khi load workers, đề xuất user đăng nhập hiện tại
                    suggestCurrentUser();
                    
                    // Nếu dropdown đang mở, cập nhật lại options
                    if (workerDropdown.style.display === 'block') {
                        renderDropdownOptions(workerSearch.value);
                    }
                } else {
                    console.error('Failed to load workers from API, status:', response.status);
                    availableWorkers = [];
                }
            } catch (error) {
                console.error('Error loading workers:', error);
                availableWorkers = [];
            }
        }
        
        // Đề xuất user đăng nhập hiện tại
        function suggestCurrentUser() {
            
            if (typeof auth !== 'undefined') {
                const currentUser = auth.getUser();
                // 
                
                if (currentUser && currentUser.full_name) {

                    
                    // Tìm user trong danh sách available workers
                    const userWorkerName = availableWorkers.find(worker => 
                        worker.includes(currentUser.full_name) || 
                        worker.includes(currentUser.ma_nhan_vien)
                    );
                    
                    
                    if (userWorkerName && selectedWorkerList.length === 0) {
                        selectedWorkerList = [userWorkerName];
                        renderSelectedWorkers();
                        updateWorkerInput();
                
                    } else if (selectedWorkerList.length > 0) {
                    } else {
                    }
                } else {
                }
            } else {
            }
        }
        
        let selectedWorkerList = [];
        
        // Không load dữ liệu từ database, chỉ để trống để nhập mới
        
        // Render selected workers
        function renderSelectedWorkers() {
            selectedWorkers.innerHTML = '';
            selectedWorkerList.forEach(worker => {
                const tag = document.createElement('div');
                tag.className = 'selected-tag';
                tag.innerHTML = `
                    ${worker}
                    <button class="remove-btn" onclick="event.stopPropagation(); event.preventDefault(); removeWorker('${worker}')">×</button>
                `;
                selectedWorkers.appendChild(tag);
            });
        }
        
        // Render dropdown options
        function renderDropdownOptions(filter = '') {
            
            
            workerOptions.innerHTML = '';
            const filteredWorkers = availableWorkers.filter(worker => 
                worker.toLowerCase().includes(filter.toLowerCase()) &&
                !selectedWorkerList.includes(worker)
            );
            
            
            filteredWorkers.forEach(worker => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.textContent = worker;
                item.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    addWorker(worker);
                };
                workerOptions.appendChild(item);
            });
            
        }
        
        // Add worker
        window.addWorker = function(worker) {
            if (!selectedWorkerList.includes(worker)) {
                selectedWorkerList.push(worker);
                renderSelectedWorkers();
                renderDropdownOptions(workerSearch.value);
                updateWorkerInput();
            }
            // Không đóng dropdown ngay, để user có thể chọn thêm
            workerSearch.focus();
        };
        
        // Remove worker
        window.removeWorker = function(worker) {
            selectedWorkerList = selectedWorkerList.filter(w => w !== worker);
            renderSelectedWorkers();
            renderDropdownOptions(workerSearch.value);
            updateWorkerInput();
            // Focus lại vào search input sau khi xóa
            workerSearch.focus();
        };
        
        // Update hidden input for form submission
        function updateWorkerInput() {
            const workerInput = document.getElementById('worker');
            if (workerInput) {
                workerInput.value = selectedWorkerList.join(', ');
            }
        }
        
        // Event listeners
        workerSearch.addEventListener('focus', () => {
            workerDropdown.style.display = 'block';
            renderDropdownOptions();
        });
        
        // Ngăn chặn event propagation cho toàn bộ multi-select container
        const multiSelectContainer = document.querySelector('.multi-select-container');
        if (multiSelectContainer) {
            multiSelectContainer.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        }
        
        workerSearch.addEventListener('input', (e) => {
            renderDropdownOptions(e.target.value);
        });
        
        // Ngăn chặn event propagation cho dropdown
        workerDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            // Chỉ đóng dropdown nếu click outside multi-select và không phải click vào dropdown item
            if (!e.target.closest('.multi-select-container') && !e.target.closest('.dropdown-item')) {
                workerDropdown.style.display = 'none';
            }
        });
        
        // Initialize
        loadWorkersFromAPI().then(() => {
            renderSelectedWorkers();
            updateWorkerInput();
        });
    }
    
    // JavaScript cho phần chọn kệ - Áp dụng từ demo-ke-sidebar.html
    let keData = {};
    let selectedKe = 0;
    let totalKe = 0;
    let previousProcessData = {};
    
        // Hàm tạo kệ từ sheet_count khi không có dữ liệu từ input
    function createKeDataFromSheetCount(order) {
        if (!order || !order.sheet_count) {
            return;
        }
        
        // Tạo 1 kệ duy nhất với số lượng bằng sheet_count
        previousProcessData = {
            1: {
                name: 'Kệ mặc định',
                quantity: order.sheet_count,
                status: 'ready',
                current_stage: STAGE_CONFIG.KEY,
                original_data: {
                    order_id: order.id,
                    sheet_count: order.sheet_count,
                    created_at: new Date().toISOString()
                }
            }
        };
        
        // Cập nhật UI - không cần gọi updateKeToggleGrid ở đây vì loadCurrentStageKeData sẽ gọi
    }
    
    // Hàm lấy dữ liệu kệ từ input của công đoạn hiện tại
    async function loadCurrentStageKeData(order) {
        if (!order) {
            return;
        }
        try {
            // Lấy dữ liệu kệ từ input_json của công đoạn hiện tại
            const apiUrl = `${API_BASE_URL}/data/production_orders/${order.id}/input_json/${STAGE_CONFIG.KEY}`;
            
            const resp = await fetch(apiUrl);
            
            if (!resp.ok) {
                // Nếu không có dữ liệu, tạo từ sheet_count và cập nhật UI
                createKeDataFromSheetCount(order);
                updateKeToggleGrid();
                return;
            }
            
            const data = await resp.json();
            
            let raw = data && data.data ? data.data : null;
            if (!raw) {
                createKeDataFromSheetCount(order);
                updateKeToggleGrid();
                return;
            }
            
            if (typeof raw === 'string') {
                try { 
                    raw = JSON.parse(raw); 
                } catch (_) {
                    createKeDataFromSheetCount(order);
                    updateKeToggleGrid();
                    return;
                }
            }
            
            // Ưu tiên tìm records của công đoạn hiện tại trước
            const currentRecordsKey = `${STAGE_CONFIG.KEY}_ke_records`;
            
            let records = raw[currentRecordsKey] || [];
            
            // Nếu không có records của công đoạn hiện tại, thử tìm từ công đoạn trước
            if (records.length === 0) {
                // Tìm key có dạng *_ke_records (trừ current stage records)
                const availableKeys = Object.keys(raw).filter(key => key.endsWith('_ke_records') && key !== currentRecordsKey);
                
                if (availableKeys.length > 0) {
                    const previousKey = availableKeys[0]; // Lấy key đầu tiên tìm được
                    records = raw[previousKey] || [];
                }
            }
            
            if (records.length === 0) {
                createKeDataFromSheetCount(order);
                updateKeToggleGrid();
                return;
            }
            
            // Chuyển đổi dữ liệu thành format phù hợp
            previousProcessData = {};
            
            // Xác định prefix để lấy dữ liệu từ records
            let dataPrefix = STAGE_CONFIG.KEY;
            if (records.length > 0 && !records[0][`${STAGE_CONFIG.KEY}_ke_id`]) {
                // Nếu không có xen_ke_id, tìm prefix khác
                const firstRecord = records[0];
                const availablePrefixes = Object.keys(firstRecord).filter(key => key.endsWith('_ke_id'));
                if (availablePrefixes.length > 0) {
                    dataPrefix = availablePrefixes[0].replace('_ke_id', '');
                }
            }
            
            records.forEach((rec, index) => {
                const keId = rec[`${dataPrefix}_ke_id`] || `ke_${index + 1}`;
                const keName = rec[`${dataPrefix}_ke_name`] || `Kệ ${index + 1}`;
                const quantity = rec[`${dataPrefix}_quantity`] || 0;
                // Lấy status từ stage hiện tại, không phải từ dataPrefix
                const currentStageStatusKey = `${STAGE_CONFIG.KEY}_status`;
                const status = rec[currentStageStatusKey] || 'waiting';
                const match = keId.match(/(\d+)/);
                const keNumber = match ? parseInt(match[1]) : (index + 1);
                
                // Chỉ lưu các kệ có trạng thái waiting hoặc in_progress
                if (status === 'waiting' || status === 'in_progress') {
                    previousProcessData[keNumber] = {
                        name: keName,
                        quantity: quantity,
                        status: status,
                        current_stage: STAGE_CONFIG.KEY,
                        original_data: rec
                    };
                    console.log(`🔍 [loadCurrentStageKeData] Updated previousProcessData[${keNumber}]:`, {
                        name: keName,
                        quantity: quantity,
                        status: status,
                        current_stage: STAGE_CONFIG.KEY
                    });
                }
            });
            
            // Cập nhật UI
            updateKeToggleGrid();
        } catch (error) {
            console.error('❌ [loadCurrentStageKeData] Lỗi khi lấy dữ liệu kệ từ công đoạn hiện tại:', error);
            // Fallback: tạo từ sheet_count và cập nhật UI
            createKeDataFromSheetCount(order);
            updateKeToggleGrid();
        }
    }
    
    function createKeToggleItem(keNumber) {
        const processData = previousProcessData[keNumber];
        if (!processData) {
            return ''; // Không hiển thị nếu không có dữ liệu
        }
        
        // Xác định trạng thái và class
        let statusClass = '';
        let statusText = '';
        
        if (processData.current_stage === STAGE_CONFIG.KEY) {
            // Dữ liệu từ công đoạn hiện tại
            if (processData.status === 'completed') {
                statusClass = 'completed';
                statusText = 'Hoàn thành';
            } else if (processData.status === 'in_progress') {
                statusClass = 'in-progress';
                statusText = 'Đang xử lý';
            } else {
                statusClass = 'waiting';
                statusText = 'Chờ xử lý';
            }
        } else {
            // Dữ liệu từ công đoạn trước
            if (processData.status === 'completed') {
                statusClass = 'completed';
                statusText = 'Hoàn thành';
            } else if (processData.status === 'in_progress') {
                statusClass = 'in-progress';
                statusText = 'Đang xử lý';
            } else {
                statusClass = 'waiting';
                statusText = 'Chờ xử lý';
            }
        }
        
        return `
            <div class="ke-toggle-item ${statusClass}" id="ke-${keNumber}" onclick="toggleKe(${keNumber})">
                <div class="ke-toggle-header">
                    <div class="ke-info">
                        <div class="ke-title-row">
                            <svg class="ke-icon" viewBox="0 0 224 96.06" xmlns="http://www.w3.org/2000/svg">
                                <polygon class="cls-1" points="224 48.06 224 96.06 192 96.06 192 64.06 128 64.06 128 96.06 96 96.06 96 64.06 32 64.06 32 96.06 0 96.06 0 48.06 224 48.06"/>
                                <polygon class="cls-1" points="97 .06 88 40.06 48 40.06 72 .06 97 .06"/>
                                <polygon class="cls-1" points="152 .06 176 40.06 136 40.06 127 .06 152 .06"/>
                                <path class="cls-1" d="M67,.06c.73.64-3.45,6.24-4.18,7.32-7.49,11.06-15.25,22.04-23.32,32.68H1C14.27,25.89,29.07,13.08,43.5.06h23.5Z"/>
                                <path class="cls-1" d="M223,40.06h-38.5c-8.07-10.64-15.83-21.63-23.32-32.68-1.49-2.2-3.71-4.71-4.18-7.32h23.5c14.43,13.02,29.23,25.83,42.5,40Z"/>
                                <polygon class="cls-1" points="96 40.06 102.58 0 121.95 .11 128 40.06 96 40.06"/>
                            </svg>
                            <h6 class="ke-toggle-title">${processData.name}</h6>
                        </div>
                        <div class="ke-quantity">Số lượng: ${processData.quantity.toLocaleString()} tờ</div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function updateKeToggleGrid() {
        
        
        
        const grid = document.getElementById('keToggleGrid');
        if (!grid) {
            
            return;
        }
        
        grid.innerHTML = '';
        
        const keNumbers = Object.keys(previousProcessData).map(Number).sort((a, b) => a - b);
        
        
        if (keNumbers.length === 0) {
            
            grid.innerHTML = '<div class="no-ke-data">Không có dữ liệu kệ từ công đoạn hiện tại</div>';
            return;
        }
        
        keNumbers.forEach(keNumber => {
            const itemHtml = createKeToggleItem(keNumber);
            if (itemHtml) {
                grid.innerHTML += itemHtml;
            }
        });
        
        // Cập nhật tổng số kệ
        totalKe = keNumbers.length;
        
        
        // Tự động chọn kệ có trạng thái 'in_progress' cho stage hiện tại
        setTimeout(() => {
            
            autoSelectInProgressRacks();
        }, 100);
        
        updateSummary();
        
        // // Cập nhật hiển thị tổng số lượng đã nhập
        // setTimeout(() => {
        //     
        //     updateTotalQuantityDisplay();
        // }, 150);
    }
    
    function toggleKe(keNumber) {
        const item = document.getElementById(`ke-${keNumber}`);
        const isSelected = item.classList.contains('selected');
        
        
        
        if (isSelected) {
            item.classList.remove('selected');
            selectedKe--;
            delete keData[keNumber];
            
        } else {
            item.classList.add('selected');
            selectedKe++;
            
            // Lưu thông tin kệ được chọn
            keData[keNumber] = {
                process: previousProcessData[keNumber],
                status: 'selected'
            };
            
        }
        
        updateSummary();
    }
    
    function updateSummary() {
        
        
        const summarySection = document.getElementById('summarySection');
        if (!summarySection) {
            
            return;
        }
        
        if (selectedKe > 0) {
            
            summarySection.style.display = 'block';
            
            // Calculate summary
            let totalQuantity = 0;
            Object.values(keData).forEach(data => {
                totalQuantity += data.process.quantity;
            });
            
            
            
            document.getElementById('totalKe').textContent = totalKe;
            document.getElementById('selectedKe').textContent = selectedKe;
            document.getElementById('totalQuantity').textContent = totalQuantity.toLocaleString();
            document.getElementById('completionRate').textContent = Math.round((selectedKe / totalKe) * 100) + '%';
            
            // Update selected rack quantity display in sidebar
            
            updateSelectedRackQuantityDisplaySync();
            
            // // Cập nhật hiển thị tổng số lượng đã nhập
            // setTimeout(() => {
            //     updateTotalQuantityDisplay();
            // }, 50);
        } else {
            
            summarySection.style.display = 'none';
            
            // Clear selected rack quantity display
            const selectedRackDisplay = document.getElementById('selectedRackQuantityDisplay');
            if (selectedRackDisplay) {
                selectedRackDisplay.textContent = 'Chưa chọn kệ';
                selectedRackDisplay.style.color = '#9e9e9e';
                
            }
        }
        
        // Update handover button validation
        
        updateHandoverButtonValidationSync();
    }
    
    function toggleSelectAllKe(master) {
        const items = document.querySelectorAll('.ke-toggle-item');
        
        // Reset selectedKe count
        selectedKe = 0;
        keData = {};
        
        items.forEach(item => {
            const keNumberMatch = item.id.match(/ke-(\d+)/);
            const keNumber = keNumberMatch ? parseInt(keNumberMatch[1]) : null;
            
            if (keNumber && previousProcessData[keNumber]) {
                if (master.checked) {
                    item.classList.add('selected');
                    selectedKe++;
                    
                    keData[keNumber] = {
                        process: previousProcessData[keNumber],
                        status: 'selected'
                    };
                } else {
                    item.classList.remove('selected');
                }
            }
        });
        
        updateSummary();
    }
    
    function resetAllKe() {
        if (selectedKe === 0) return;
        
        const items = document.querySelectorAll('.ke-toggle-item.selected');
        items.forEach(item => item.classList.remove('selected'));
        
        selectedKe = 0;
        Object.keys(keData).forEach(key => delete keData[key]);
        
        updateSummary();
    }
    
    // Initialize ke toggle grid
    function initializeKeToggleGrid() {
        const grid = document.getElementById('keToggleGrid');
        if (grid) {
            // Không cần gọi updateKeToggleGrid ở đây vì sẽ được gọi khi có order
        }
    }
    
    // Khởi tạo khi trang load xong
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(() => {
            // Chỉ cập nhật summary section khi trang load
            updateSummary();
            // Cập nhật hiển thị tổng số lượng đã nhập
            setTimeout(() => {
                updateTotalQuantityDisplay();
            }, 200);
        }, 500);
    });
    
    // Thêm event listener để khởi tạo lại khi chuyển tab
    function initializeKeSelectionWhenTabActive() {
        
        
        const infoPanel = document.getElementById('info-panel');
        if (!infoPanel) {
            
            return;
        }
        
        
        
        if (infoPanel && infoPanel.classList.contains('active')) {
            
            setTimeout(() => {
                // Tự động tải dữ liệu kệ từ công đoạn hiện tại nếu có order
                if (currentEditingOrder) {
                    
                    loadCurrentStageKeData(currentEditingOrder);
                } else {
                    
                }
                // Cập nhật summary section khi tab info được kích hoạt
                updateSummary();
                // Cập nhật hiển thị tổng số lượng đã nhập
                setTimeout(() => {
                    updateTotalQuantityDisplay();
                }, 150);
            }, 100);
        } else {
            
        }
    }
    
    // Gọi function này khi chuyển tab
    if (typeof switchTab === 'function') {
        const originalSwitchTab = switchTab;
        window.switchTab = function(tabName) {
            
            originalSwitchTab(tabName);
            if (tabName === 'info') {
                
                initializeKeSelectionWhenTabActive();
            }
        };
    }
    
    // handleLogout đã được định nghĩa ở trên
    
    // ========================================
    // FUNCTIONS RIÊNG CHO PHẦN CHỌN KỆ
    // ========================================
    

    
    // ========================================
    // FUNCTIONS UI CHO PHẦN CHỌN KỆ
    // ========================================
    
    // Hàm lưu dữ liệu kệ từ UI
    async function saveKeDataToUI() {
      if (!currentEditingOrder) {
        alert('Vui lòng chọn một lệnh sản xuất trước!');
        return;
      }

      if (selectedKe === 0) {
        alert('Vui lòng chọn ít nhất một kệ trước khi lưu!');
        return;
      }

      try {
        // Hiển thị loading
        showLoading('Đang lưu dữ liệu kệ...');
        
        // Tạo dữ liệu JSON từ dữ liệu hiện tại
        const keDataJSON = createKeDataJSON();
        
        // Lưu vào database
        const result = await saveKeDataToDatabase(
          currentEditingOrder.id,
          'xen', // Stage hiện tại (có thể thay đổi)
          keDataJSON,
          currentEditingOrder.production_order
        );
        
        // Ẩn loading
        hideLoading();
        
        // Hiển thị thông báo thành công
        showSuccessMessage('Đã lưu dữ liệu kệ thành công!');
        
        
        
      } catch (error) {
        // Ẩn loading
        hideLoading();
        
        // Hiển thị thông báo lỗi
        showErrorMessage('Lỗi khi lưu dữ liệu kệ: ' + error.message);
        
        console.error('❌ Lỗi khi lưu dữ liệu kệ:', error);
      }
    }

    // Hàm tải dữ liệu kệ từ UI
    async function loadKeDataFromUI() {
      if (!currentEditingOrder) {
        alert('Vui lòng chọn một lệnh sản xuất trước!');
        return;
      }

      try {
        // Hiển thị loading
        showLoading('Đang tải dữ liệu kệ...');
        
        // Tải dữ liệu từ database
        const keDataJSON = await loadKeDataFromDatabase(
          currentEditingOrder.id,
          'xen' // Stage hiện tại (có thể thay đổi)
        );
        
        // Ẩn loading
        hideLoading();
        
        if (keDataJSON) {
          // Khôi phục dữ liệu kệ từ JSON
          restoreKeDataFromJSON(keDataJSON);
          
          // Hiển thị thông báo thành công
          showSuccessMessage('Đã tải dữ liệu kệ thành công!');
          
          
        } else {
          // Hiển thị thông báo không có dữ liệu
          showInfoMessage('Chưa có dữ liệu kệ để tải!');
        }
        
      } catch (error) {
        // Ẩn loading
        hideLoading();
        
        // Hiển thị thông báo lỗi
        showErrorMessage('Lỗi khi tải dữ liệu kệ: ' + error.message);
        
        console.error('❌ Lỗi khi tải dữ liệu kệ:', error);
      }
    }
    // Hàm xóa dữ liệu kệ từ UI
    async function deleteKeDataFromUI() {
      if (!currentEditingOrder) {
        alert('Vui lòng chọn một lệnh sản xuất trước!');
        return;
      }

      // Xác nhận xóa
      if (!confirm('Bạn có chắc chắn muốn xóa dữ liệu kệ? Hành động này không thể hoàn tác!')) {
        return;
      }

      try {
        // Hiển thị loading
        showLoading('Đang xóa dữ liệu kệ...');
        
        // Xóa dữ liệu từ database
        const result = await deleteKeDataFromDatabase(
          currentEditingOrder.id,
          'xen' // Stage hiện tại (có thể thay đổi)
        );
        
        // Ẩn loading
        hideLoading();
        
        // Reset dữ liệu kệ hiện tại
        resetAllKe();
        
        // Hiển thị thông báo thành công
        showSuccessMessage('Đã xóa dữ liệu kệ thành công!');
        
        
        
      } catch (error) {
        // Ẩn loading
        hideLoading();
        
        // Hiển thị thông báo lỗi
        showErrorMessage('Lỗi khi xóa dữ liệu kệ: ' + error.message);
        
        console.error('❌ Lỗi khi xóa dữ liệu kệ:', error);
      }
    }

    // Hàm hiển thị loading
    function showLoading(message = 'Đang xử lý...') {
      const loadingOverlay = document.getElementById('loadingOverlay');
      if (loadingOverlay) {
        const loadingText = loadingOverlay.querySelector('.mt-2');
        if (loadingText) {
          loadingText.textContent = message;
        }
        loadingOverlay.style.display = 'flex';
      }
    }

    // Hàm ẩn loading
    function hideLoading() {
      const loadingOverlay = document.getElementById('loadingOverlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
      }
    }

    // Hàm hiển thị thông báo thành công
    function showSuccessMessage(message) {
      // Tạo toast notification
      const toast = document.createElement('div');
      toast.className = 'alert alert-success alert-dismissible fade show position-fixed';
      toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
      toast.innerHTML = `
        <i class="bi bi-check-circle me-2"></i>
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(toast);
      
      // Tự động ẩn sau 3 giây
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 3000);
    }

    // Hàm hiển thị thông báo lỗi
    function showErrorMessage(message) {
      // Tạo toast notification
      const toast = document.createElement('div');
      toast.className = 'alert alert-danger alert-dismissible fade show position-fixed';
      toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
      toast.innerHTML = `
        <i class="bi bi-exclamation-triangle me-2"></i>
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(toast);
      
      // Tự động ẩn sau 5 giây
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 5000);
    }

    // Hàm hiển thị thông báo thông tin
    function showInfoMessage(message) {
      // Tạo toast notification
      const toast = document.createElement('div');
      toast.className = 'alert alert-info alert-dismissible fade show position-fixed';
      toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
      toast.innerHTML = `
        <i class="bi bi-info-circle me-2"></i>
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      document.body.appendChild(toast);
      
      // Tự động ẩn sau 3 giây
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 3000);
    }
    
    // ========================================
    // FUNCTIONS HIỂN THỊ DỮ LIỆU KỆ ĐÃ LƯU
    // ========================================
    
    // Hàm tải dữ liệu kệ đã lưu từ database
    async function loadSavedKeData() {
      if (!currentEditingOrder) {
        
        return;
      }
      
      try {
        showLoading('Đang tải dữ liệu kệ...');
        
        // Sử dụng API mới từ production_orders
        const response = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/handover_json/${STAGE_CONFIG.KEY}`);
        
        if (response.ok) {
          const result = await response.json();
          
          if (result.success && result.data.ke_data_json) {
            displaySavedKeData(result.data.ke_data_json);
            document.getElementById('savedKeSection').style.display = 'block';
            
          } else {
            
            document.getElementById('savedKeSection').style.display = 'none';
          }
        } else if (response.status === 404) {
          
          document.getElementById('savedKeSection').style.display = 'none';
        } else {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Lỗi khi tải dữ liệu kệ');
        }
      } catch (error) {
        console.error('❌ Lỗi khi tải dữ liệu kệ:', error);
        showNotification('Lỗi khi tải dữ liệu kệ: ' + error.message, 'error');
      } finally {
        hideLoading();
      }
    }
    
    // Hàm hiển thị dữ liệu kệ đã lưu
    function displaySavedKeData(keData) {
      const contentElement = document.getElementById('savedKeContent');
      if (!contentElement) return;
      
      if (!keData.ke_records || keData.ke_records.length === 0) {
        contentElement.innerHTML = '<p class="text-muted text-center">Không có dữ liệu kệ nào</p>';
        return;
      }
      
      const keItemsHTML = keData.ke_records.map(ke => `
        <div class="saved-ke-item">
          <div class="saved-ke-info">
            <div class="saved-ke-name">${ke.ke_name}</div>
            <div class="saved-ke-details">
              <i class="bi bi-person me-1"></i>${ke.operator || 'N/A'} | 
              <i class="bi bi-clock me-1"></i>${ke.shift || 'N/A'} | 
              <i class="bi bi-calendar me-1"></i>${formatDateTime(ke.handover_time) || 'N/A'}
            </div>
            ${ke.notes ? `<div class="saved-ke-details mt-1"><i class="bi bi-chat-text me-1"></i>${ke.notes}</div>` : ''}
          </div>
          <div class="saved-ke-quantity">${ke.quantity}</div>
        </div>
      `).join('');
      
      contentElement.innerHTML = keItemsHTML;
    }
    
    // Hàm xóa dữ liệu kệ đã lưu
    async function clearSavedKeData() {
      if (!currentEditingOrder) {
        showNotification('Không có lệnh sản xuất nào đang được chỉnh sửa', 'warning');
        return;
      }
      
      const confirmed = confirm(`Xác nhận xóa dữ liệu kệ đã lưu cho lệnh ${currentEditingOrder.production_order}?\n\nDữ liệu này sẽ bị xóa vĩnh viễn!`);
      
      if (!confirmed) return;
      
      try {
        showLoading('Đang xóa dữ liệu kệ...');
        
        // Sử dụng API mới từ production_orders
        const response = await fetch(`${API_BASE_URL}/data/production_orders/${currentEditingOrder.id}/handover_json/${STAGE_CONFIG.KEY}`, {
          method: 'DELETE'
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Lỗi khi xóa dữ liệu kệ');
        }
        
        const result = await response.json();
        
        
        // Ẩn section và hiển thị thông báo
        document.getElementById('savedKeSection').style.display = 'none';
        showNotification('✅ Đã xóa dữ liệu kệ thành công!', 'success');
        
      } catch (error) {
        console.error('❌ Lỗi khi xóa dữ liệu kệ:', error);
        showNotification('Lỗi khi xóa dữ liệu kệ: ' + error.message, 'error');
      } finally {
        hideLoading();
      }
    }
  </script>

  <!-- Details Panel - Will be generated dynamically -->
  <div class="details-panel" id="detailsPanel">
    <!-- Content will be generated by showOrderDetails() function -->
  </div>
  
  <!-- Loading Overlay -->
  <div id="loadingOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; justify-content: center; align-items: center;">
    <div class="text-center text-white">
      <div class="spinner-border" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <div class="mt-2">Đang tải dữ liệu từ API...</div>
    </div>
  </div>
  
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>